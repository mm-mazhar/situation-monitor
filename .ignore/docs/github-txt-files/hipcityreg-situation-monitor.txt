Directory structure:
└── hipcityreg-situation-monitor/
    ├── CLAUDE.md
    ├── eslint.config.js
    ├── package.json
    ├── playwright.config.ts
    ├── postcss.config.js
    ├── svelte.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── vercel.json
    ├── vite.config.ts
    ├── vitest.config.ts
    ├── .env.example
    ├── .prettierignore
    ├── .prettierrc
    ├── src/
    │   ├── app.css
    │   ├── app.html
    │   ├── lib/
    │   │   ├── analysis/
    │   │   │   ├── correlation.test.ts
    │   │   │   ├── correlation.ts
    │   │   │   ├── index.ts
    │   │   │   ├── main-character.test.ts
    │   │   │   ├── main-character.ts
    │   │   │   ├── narrative.test.ts
    │   │   │   └── narrative.ts
    │   │   ├── api/
    │   │   │   ├── fred.ts
    │   │   │   ├── index.ts
    │   │   │   ├── leaders.ts
    │   │   │   ├── markets.ts
    │   │   │   ├── misc.ts
    │   │   │   └── news.ts
    │   │   ├── components/
    │   │   │   ├── index.ts
    │   │   │   ├── common/
    │   │   │   │   ├── Badge.svelte
    │   │   │   │   ├── ErrorMessage.svelte
    │   │   │   │   ├── HeatmapCell.svelte
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── LoadingSpinner.svelte
    │   │   │   │   ├── MarketItem.svelte
    │   │   │   │   ├── NewsItem.svelte
    │   │   │   │   └── Panel.svelte
    │   │   │   ├── layout/
    │   │   │   │   ├── Dashboard.svelte
    │   │   │   │   ├── Header.svelte
    │   │   │   │   └── index.ts
    │   │   │   ├── modals/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── Modal.svelte
    │   │   │   │   ├── MonitorFormModal.svelte
    │   │   │   │   ├── OnboardingModal.svelte
    │   │   │   │   └── SettingsModal.svelte
    │   │   │   └── panels/
    │   │   │       ├── CommoditiesPanel.svelte
    │   │   │       ├── ContractsPanel.svelte
    │   │   │       ├── CorrelationPanel.svelte
    │   │   │       ├── CryptoPanel.svelte
    │   │   │       ├── FedPanel.svelte
    │   │   │       ├── HeatmapPanel.svelte
    │   │   │       ├── index.ts
    │   │   │       ├── IntelPanel.svelte
    │   │   │       ├── LayoffsPanel.svelte
    │   │   │       ├── MainCharPanel.svelte
    │   │   │       ├── MapPanel.svelte
    │   │   │       ├── MarketsPanel.svelte
    │   │   │       ├── MonitorsPanel.svelte
    │   │   │       ├── NarrativePanel.svelte
    │   │   │       ├── NewsPanel.svelte
    │   │   │       ├── PolymarketPanel.svelte
    │   │   │       ├── PrinterPanel.svelte
    │   │   │       ├── SituationPanel.svelte
    │   │   │       ├── WhalePanel.svelte
    │   │   │       └── WorldLeadersPanel.svelte
    │   │   ├── config/
    │   │   │   ├── analysis.ts
    │   │   │   ├── api.ts
    │   │   │   ├── feeds.ts
    │   │   │   ├── index.ts
    │   │   │   ├── keywords.ts
    │   │   │   ├── leaders.ts
    │   │   │   ├── map.ts
    │   │   │   ├── markets.ts
    │   │   │   ├── panels.ts
    │   │   │   └── presets.ts
    │   │   ├── services/
    │   │   │   ├── cache.test.ts
    │   │   │   ├── cache.ts
    │   │   │   ├── circuit-breaker.test.ts
    │   │   │   ├── circuit-breaker.ts
    │   │   │   ├── client.ts
    │   │   │   ├── deduplicator.test.ts
    │   │   │   ├── deduplicator.ts
    │   │   │   ├── errors.ts
    │   │   │   ├── index.ts
    │   │   │   ├── registry.test.ts
    │   │   │   └── registry.ts
    │   │   ├── stores/
    │   │   │   ├── fed.ts
    │   │   │   ├── index.ts
    │   │   │   ├── markets.test.ts
    │   │   │   ├── markets.ts
    │   │   │   ├── monitors.test.ts
    │   │   │   ├── monitors.ts
    │   │   │   ├── news.test.ts
    │   │   │   ├── news.ts
    │   │   │   ├── refresh.test.ts
    │   │   │   ├── refresh.ts
    │   │   │   ├── settings.test.ts
    │   │   │   └── settings.ts
    │   │   ├── types/
    │   │   │   └── index.ts
    │   │   └── utils/
    │   │       ├── format.ts
    │   │       └── index.ts
    │   └── routes/
    │       ├── +layout.svelte
    │       ├── +layout.ts
    │       └── +page.svelte
    ├── tests/
    │   └── e2e/
    │       ├── app.spec.ts
    │       └── legacy.spec.ts
    └── .github/
        └── workflows/
            └── deploy.yml

================================================
FILE: CLAUDE.md
================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Workflow

When working on a new feature:
1. Create a new branch before making any changes
2. Make all commits on that feature branch
3. Before opening a PR, run the `code-simplifier` agent to clean up the code

## Build & Development Commands

```bash
npm run dev          # Start dev server (localhost:5173)
npm run build        # Build to /build directory
npm run preview      # Preview production build (localhost:4173)
npm run check        # TypeScript type checking
npm run check:watch  # Type checking in watch mode
npm run test         # Run Vitest in watch mode
npm run test:unit    # Run unit tests once
npm run test:e2e     # Run Playwright E2E tests (requires preview server)
npm run lint         # ESLint + Prettier check
npm run format       # Auto-format with Prettier
```

## Technology Stack

- **SvelteKit 2.0** with Svelte 5 reactivity (`$state`, `$derived`, `$effect` runes)
- **TypeScript** (strict mode enabled)
- **Tailwind CSS** with custom dark theme
- **Vitest** (unit) + **Playwright** (E2E) for testing
- **Static adapter** - deploys as pure static site to GitHub Pages

## Project Architecture

### Core Directories (`src/lib/`)

- **`analysis/`** - Pattern correlation, narrative tracking, main character detection across news items
- **`api/`** - Data fetching from GDELT, RSS feeds (30+ sources), market APIs, CoinGecko
- **`components/`** - Svelte components organized into layout/, panels/, modals/, common/
- **`config/`** - Centralized configuration for feeds, keywords, analysis patterns, panels, map hotspots
- **`services/`** - Resilience layer: CacheManager, CircuitBreaker, RequestDeduplicator, ServiceClient
- **`stores/`** - Svelte stores for settings, news, markets, monitors, refresh orchestration
- **`types/`** - TypeScript interfaces

### Path Aliases

```typescript
$lib        → src/lib
$components → src/lib/components
$stores     → src/lib/stores
$services   → src/lib/services
$config     → src/lib/config
$types      → src/lib/types
```

## Key Architectural Patterns

### Service Layer (`src/lib/services/`)
All HTTP requests go through `ServiceClient` which integrates:
- **CacheManager**: Per-service caching with TTL
- **CircuitBreaker**: Prevents cascading failures
- **RequestDeduplicator**: Prevents concurrent duplicate requests

### Multi-Stage Refresh (`src/lib/stores/refresh.ts`)
Data fetches happen in 3 stages with staggered delays:
1. Critical (0ms): News, markets, alerts
2. Secondary (2s): Crypto, commodities, intel
3. Tertiary (4s): Contracts, whales, layoffs, polymarket

### Analysis Engine (`src/lib/analysis/`)
Unique business logic for intelligence analysis:
- Correlation detection across disparate news items
- Narrative tracking (fringe → mainstream progression)
- Entity prominence calculation ("main character" analysis)
- All use configurable regex patterns from `src/lib/config/analysis.ts`

### Configuration-Driven Design (`src/lib/config/`)
- `feeds.ts`: 30+ RSS sources across 6 categories (politics, tech, finance, gov, ai, intel)
- `keywords.ts`: Alert keywords, region detection, topic detection
- `analysis.ts`: Correlation topics and narrative patterns with severity levels
- `panels.ts`: Panel registry with display order
- `map.ts`: Geopolitical hotspots, conflict zones, strategic locations

## Testing

**Unit tests**: Located alongside source as `*.test.ts` or `*.spec.ts`
**E2E tests**: In `tests/e2e/*.spec.ts`, run against preview server

## Deployment

GitHub Actions workflow builds with `BASE_PATH=/situation-monitor` and deploys to GitHub Pages at `https://hipcityreg.github.io/situation-monitor/`

## External Dependencies

- **D3.js** for interactive map visualization
- **CORS proxy** (Cloudflare Worker) for RSS feed parsing
- **CoinGecko API** for cryptocurrency data



================================================
FILE: eslint.config.js
================================================
import eslint from '@eslint/js';
import tseslint from 'typescript-eslint';
import svelte from 'eslint-plugin-svelte';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

export default tseslint.config(
	eslint.configs.recommended,
	...tseslint.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node,
				// GeoJSON types are globally available in TypeScript projects with @types/geojson
				GeoJSON: 'readonly'
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: tseslint.parser
			}
		}
	},
	{
		ignores: [
			'build/',
			'.svelte-kit/',
			'dist/',
			// Legacy files - not part of SvelteKit migration
			'js/',
			'workers/',
			'static/js/',
			'static/legacy.html',
			// Test utility files
			'test-node.mjs'
		]
	}
);



================================================
FILE: package.json
================================================
{
	"name": "situation-monitor",
	"version": "2.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"test": "vitest",
		"test:unit": "vitest run",
		"test:e2e": "playwright test",
		"lint": "eslint . && prettier --check .",
		"format": "prettier --write ."
	},
	"devDependencies": {
		"@playwright/test": "^1.49.0",
		"@sveltejs/adapter-static": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^5.0.0",
		"@testing-library/svelte": "^5.0.0",
		"@types/d3": "^7.4.0",
		"@types/node": "^22.0.0",
		"@types/topojson-client": "^3.1.0",
		"@typescript-eslint/eslint-plugin": "^8.0.0",
		"@typescript-eslint/parser": "^8.0.0",
		"autoprefixer": "^10.4.0",
		"eslint": "^9.0.0",
		"eslint-config-prettier": "^9.0.0",
		"eslint-plugin-svelte": "^2.0.0",
		"globals": "^15.0.0",
		"jsdom": "^25.0.0",
		"postcss": "^8.4.0",
		"prettier": "^3.0.0",
		"prettier-plugin-svelte": "^3.0.0",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwindcss": "^3.4.0",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.52.0",
		"vite": "^6.0.0",
		"vitest": "^2.0.0"
	},
	"dependencies": {
		"d3": "^7.9.0",
		"topojson-client": "^3.1.0"
	}
}



================================================
FILE: playwright.config.ts
================================================
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
	testDir: './tests/e2e',
	fullyParallel: true,
	forbidOnly: !!process.env.CI,
	retries: process.env.CI ? 2 : 0,
	workers: process.env.CI ? 1 : undefined,
	reporter: 'html',
	use: {
		baseURL: 'http://localhost:4173',
		trace: 'on-first-retry'
	},
	projects: [
		{
			name: 'chromium',
			use: { ...devices['Desktop Chrome'] }
		}
	],
	webServer: {
		command: 'npm run preview',
		url: 'http://localhost:4173',
		reuseExistingServer: !process.env.CI
	}
});



================================================
FILE: postcss.config.js
================================================
export default {
	plugins: {
		tailwindcss: {},
		autoprefixer: {}
	}
};



================================================
FILE: svelte.config.js
================================================
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	preprocess: vitePreprocess(),

	kit: {
		// Static adapter for deployment to any static host
		adapter: adapter({
			pages: 'build',
			assets: 'build',
			fallback: 'app.html',
			precompress: false,
			strict: true
		}),
		paths: {
			base: process.env.BASE_PATH || ''
		},
		alias: {
			$lib: 'src/lib',
			$components: 'src/lib/components',
			$stores: 'src/lib/stores',
			$services: 'src/lib/services',
			$config: 'src/lib/config',
			$types: 'src/lib/types'
		}
	}
};

export default config;



================================================
FILE: tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
	content: ['./src/**/*.{html,js,svelte,ts}'],
	theme: {
		extend: {
			colors: {
				bg: '#0a0a0a',
				surface: '#141414',
				'surface-hover': '#1a1a1a',
				border: '#2a2a2a',
				'border-light': '#3a3a3a',
				'text-primary': '#e8e8e8',
				'text-dim': '#888888',
				'text-muted': '#666666',
				accent: '#ffffff',
				danger: '#ff4444',
				success: '#44ff88',
				warning: '#ffaa00',
				info: '#4488ff'
			},
			fontFamily: {
				mono: ['SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'monospace']
			},
			fontSize: {
				'2xs': '0.65rem'
			},
			animation: {
				shimmer: 'shimmer 1.5s infinite'
			},
			keyframes: {
				shimmer: {
					'0%': { backgroundPosition: '-200% 0' },
					'100%': { backgroundPosition: '200% 0' }
				}
			}
		}
	},
	plugins: []
};



================================================
FILE: tsconfig.json
================================================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"strict": true,
		"noImplicitAny": true,
		"strictNullChecks": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"forceConsistentCasingInFileNames": true,
		"moduleResolution": "bundler",
		"target": "ES2022",
		"lib": ["ES2022", "DOM", "DOM.Iterable"],
		"allowJs": true,
		"checkJs": true,
		"skipLibCheck": true
	}
}



================================================
FILE: vercel.json
================================================
{
  "buildCommand": "npm run build",
  "outputDirectory": "build",
  "framework": "sveltekit"
}



================================================
FILE: vite.config.ts
================================================
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit()]
});



================================================
FILE: vitest.config.ts
================================================
import { defineConfig, mergeConfig } from 'vitest/config';
import viteConfig from './vite.config';

export default mergeConfig(
	viteConfig,
	defineConfig({
		test: {
			include: ['src/**/*.{test,spec}.{js,ts}'],
			environment: 'jsdom',
			globals: true
		}
	})
);



================================================
FILE: .env.example
================================================
# Finnhub API Key
# Get your free key at: https://finnhub.io/
# Free tier: 60 calls/minute
VITE_FINNHUB_API_KEY=your_api_key_here



================================================
FILE: .prettierignore
================================================
# Package managers
package-lock.json
pnpm-lock.yaml

# Build output
.svelte-kit
build
dist

# Legacy files (until migrated)
js/
styles.css
index.html
static/js/
static/legacy.html
workers/

# Test utility files
test-modules.html
test-node.mjs

# IDE settings
.claude/



================================================
FILE: .prettierrc
================================================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	]
}



================================================
FILE: src/app.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* CSS Custom Properties for theming */
:root {
	--bg: #0a0a0a;
	--surface: #141414;
	--surface-hover: #1a1a1a;
	--border: #2a2a2a;
	--border-light: #3a3a3a;
	--text: #e8e8e8;
	--text-dim: #888;
	--text-muted: #666;
	--accent: #fff;
	--red: #ff4444;
	--green: #44ff88;
	--yellow: #ffaa00;
	--blue: #4488ff;
}

/* Base styles */
html {
	font-family: 'SF Mono', Monaco, Inconsolata, 'Fira Code', monospace;
	background-color: var(--bg);
	color: var(--text);
}

body {
	margin: 0;
	min-height: 100vh;
}

/* Scrollbar styling */
::-webkit-scrollbar {
	width: 6px;
	height: 6px;
}

::-webkit-scrollbar-track {
	background: var(--surface);
}

::-webkit-scrollbar-thumb {
	background: var(--border-light);
	border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
	background: var(--text-muted);
}

/* Link styles */
a {
	color: inherit;
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

/* Focus styles for accessibility */
:focus-visible {
	outline: 2px solid var(--accent);
	outline-offset: 2px;
}

/* Utility classes that are hard to do in Tailwind */
.shimmer {
	background: linear-gradient(90deg, var(--surface) 25%, var(--border) 50%, var(--surface) 75%);
	background-size: 200% 100%;
	animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
	0% {
		background-position: -200% 0;
	}
	100% {
		background-position: 200% 0;
	}
}

/* D3 Map styles - keeping here since they're complex */
.map-container {
	position: relative;
	background: var(--surface);
	border-radius: 4px;
	overflow: hidden;
}

.map-container svg {
	display: block;
	width: 100%;
	height: auto;
}

.country {
	fill: var(--border);
	stroke: var(--surface);
	stroke-width: 0.5;
	transition: fill 0.2s;
}

.country:hover {
	fill: var(--border-light);
}

.hotspot {
	cursor: pointer;
}

.hotspot circle {
	transition: r 0.2s;
}

.hotspot:hover circle {
	r: 8;
}

.hotspot-tooltip {
	position: absolute;
	background: var(--surface);
	border: 1px solid var(--border);
	padding: 8px 12px;
	border-radius: 4px;
	font-size: 0.75rem;
	pointer-events: none;
	z-index: 100;
	max-width: 300px;
}



================================================
FILE: src/app.html
================================================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="description" content="Real-time global situation monitoring dashboard" />
		<link rel="icon" href="%sveltekit.assets%/favicon.ico" />
		<title>Situation Monitor</title>
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>



================================================
FILE: src/lib/analysis/correlation.test.ts
================================================
/**
 * Tests for correlation engine
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { analyzeCorrelations, getCorrelationSummary, clearCorrelationHistory } from './correlation';
import type { NewsItem } from '$lib/types';

describe('Correlation Engine', () => {
	beforeEach(() => {
		clearCorrelationHistory();
	});

	it('should return null for empty news', () => {
		expect(analyzeCorrelations([])).toBeNull();
		expect(analyzeCorrelations(null as unknown as NewsItem[])).toBeNull();
	});

	it('should detect emerging patterns', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Ukraine announces new policy',
				source: 'BBC',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Ukraine military update',
				source: 'CNN',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '3',
				title: 'Zelensky addresses nation',
				source: 'NYT',
				link: 'c',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeCorrelations(news);

		expect(results).not.toBeNull();
		expect(results!.emergingPatterns.length).toBeGreaterThan(0);

		const ukrainePattern = results!.emergingPatterns.find((p) => p.id === 'russia-ukraine');
		expect(ukrainePattern).toBeDefined();
		expect(ukrainePattern!.count).toBeGreaterThanOrEqual(3);
		expect(ukrainePattern!.level).toBe('emerging');
	});

	it('should categorize pattern levels correctly', () => {
		// Create many Ukraine-related articles to trigger 'high' level
		const news: NewsItem[] = Array.from({ length: 10 }, (_, i) => ({
			id: String(i),
			title: `Ukraine news ${i}`,
			source: `Source${i}`,
			link: `link${i}`,
			timestamp: Date.now(),
			category: 'politics' as const
		}));

		const results = analyzeCorrelations(news);
		const ukrainePattern = results?.emergingPatterns.find((p) => p.id === 'russia-ukraine');

		expect(ukrainePattern?.level).toBe('high');
	});

	it('should track cross-source correlations', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Tariff news today',
				source: 'BBC',
				link: 'a',
				timestamp: Date.now(),
				category: 'finance'
			},
			{
				id: '2',
				title: 'Trade war escalates',
				source: 'CNN',
				link: 'b',
				timestamp: Date.now(),
				category: 'finance'
			},
			{
				id: '3',
				title: 'Import tax increases',
				source: 'NYT',
				link: 'c',
				timestamp: Date.now(),
				category: 'finance'
			},
			{
				id: '4',
				title: 'Customs duty update',
				source: 'WSJ',
				link: 'd',
				timestamp: Date.now(),
				category: 'finance'
			}
		];

		const results = analyzeCorrelations(news);
		const tariffCorrelation = results?.crossSourceCorrelations.find((c) => c.id === 'tariffs');

		expect(tariffCorrelation).toBeDefined();
		expect(tariffCorrelation!.sourceCount).toBe(4);
		expect(tariffCorrelation!.sources).toContain('BBC');
	});

	it('should generate predictive signals for high scores', () => {
		// Create many tariff articles to generate predictive signals
		const news: NewsItem[] = Array.from({ length: 8 }, (_, i) => ({
			id: String(i),
			title: `Tariff policy update ${i}`,
			source: `Source${i % 4}`,
			link: `link${i}`,
			timestamp: Date.now(),
			category: 'finance' as const
		}));

		const results = analyzeCorrelations(news);

		expect(results?.predictiveSignals.length).toBeGreaterThan(0);

		const tariffSignal = results?.predictiveSignals.find((s) => s.id === 'tariffs');
		if (tariffSignal) {
			expect(tariffSignal.prediction).toContain('volatility');
		}
	});

	it('should collect headlines for patterns', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Gaza conflict escalates',
				source: 'BBC',
				link: 'https://bbc.com/1',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Hamas negotiations',
				source: 'CNN',
				link: 'https://cnn.com/2',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '3',
				title: 'Israel Gaza update',
				source: 'NYT',
				link: 'https://nyt.com/3',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeCorrelations(news);
		const gazaPattern = results?.emergingPatterns.find((p) => p.id === 'israel-gaza');

		expect(gazaPattern?.headlines.length).toBeGreaterThan(0);
		expect(gazaPattern?.headlines[0].link).toBeDefined();
		expect(gazaPattern?.headlines[0].source).toBeDefined();
	});

	it('should return correct summary', () => {
		expect(getCorrelationSummary(null)).toEqual({ totalSignals: 0, status: 'NO DATA' });

		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Ukraine update',
				source: 'BBC',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Ukraine news',
				source: 'CNN',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '3',
				title: 'Zelensky speaks',
				source: 'NYT',
				link: 'c',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeCorrelations(news);
		const summary = getCorrelationSummary(results);

		expect(summary.totalSignals).toBeGreaterThan(0);
		expect(summary.status).toMatch(/SIGNALS/);
	});
});



================================================
FILE: src/lib/analysis/correlation.ts
================================================
/**
 * Correlation engine - analyzes patterns across news items
 */

import type { NewsItem } from '$lib/types';
import { CORRELATION_TOPICS, type CorrelationTopic } from '$lib/config/analysis';

// Types for correlation results
export interface EmergingPattern {
	id: string;
	name: string;
	category: string;
	count: number;
	level: 'high' | 'elevated' | 'emerging';
	sources: string[];
	headlines: Array<{ title: string; link: string; source: string }>;
}

export interface MomentumSignal {
	id: string;
	name: string;
	category: string;
	current: number;
	delta: number;
	momentum: 'surging' | 'rising' | 'stable';
	headlines: Array<{ title: string; link: string; source: string }>;
}

export interface CrossSourceCorrelation {
	id: string;
	name: string;
	category: string;
	sourceCount: number;
	sources: string[];
	level: 'high' | 'elevated' | 'emerging';
	headlines: Array<{ title: string; link: string; source: string }>;
}

export interface PredictiveSignal {
	id: string;
	name: string;
	category: string;
	score: number;
	confidence: number;
	prediction: string;
	level: 'high' | 'medium' | 'low';
	headlines: Array<{ title: string; link: string; source: string }>;
}

export interface CorrelationResults {
	emergingPatterns: EmergingPattern[];
	momentumSignals: MomentumSignal[];
	crossSourceCorrelations: CrossSourceCorrelation[];
	predictiveSignals: PredictiveSignal[];
}

// Topic history for momentum analysis
const topicHistory: Record<number, Record<string, number>> = {};

// History retention in minutes
const HISTORY_RETENTION_MINUTES = 30;

// Time window for momentum comparison in minutes
const MOMENTUM_WINDOW_MINUTES = 10;

/**
 * Format topic ID to display name
 */
function formatTopicName(id: string): string {
	return id.replace(/-/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
}

/**
 * Analyze correlations across all news items
 */
export function analyzeCorrelations(allNews: NewsItem[]): CorrelationResults | null {
	if (!allNews || allNews.length === 0) return null;

	const now = Date.now();
	const currentTime = Math.floor(now / 60000); // Current minute

	const results: CorrelationResults = {
		emergingPatterns: [],
		momentumSignals: [],
		crossSourceCorrelations: [],
		predictiveSignals: []
	};

	// Count topics and track sources/headlines
	const topicCounts: Record<string, number> = {};
	const topicSources: Record<string, Set<string>> = {};
	const topicHeadlines: Record<string, Array<{ title: string; link: string; source: string }>> = {};

	// Analyze each news item
	for (const item of allNews) {
		const title = item.title || '';
		const source = item.source || 'Unknown';

		for (const topic of CORRELATION_TOPICS) {
			const matches = topic.patterns.some((p) => p.test(title));
			if (matches) {
				if (!topicCounts[topic.id]) {
					topicCounts[topic.id] = 0;
					topicSources[topic.id] = new Set();
					topicHeadlines[topic.id] = [];
				}
				topicCounts[topic.id]++;
				topicSources[topic.id].add(source);
				if (topicHeadlines[topic.id].length < 5) {
					topicHeadlines[topic.id].push({ title, link: item.link, source });
				}
			}
		}
	}

	// Update topic history for momentum tracking
	if (!topicHistory[currentTime]) {
		topicHistory[currentTime] = { ...topicCounts };

		// Clean old history entries
		for (const timeKey of Object.keys(topicHistory)) {
			if (currentTime - parseInt(timeKey) > HISTORY_RETENTION_MINUTES) {
				delete topicHistory[parseInt(timeKey)];
			}
		}
	}

	// Get old counts for momentum comparison
	const oldTime = currentTime - MOMENTUM_WINDOW_MINUTES;
	const oldCounts = topicHistory[oldTime] || {};

	// Process each topic
	for (const topic of CORRELATION_TOPICS) {
		const count = topicCounts[topic.id] || 0;
		const sources = topicSources[topic.id] ? Array.from(topicSources[topic.id]) : [];
		const headlines = topicHeadlines[topic.id] || [];
		const oldCount = oldCounts[topic.id] || 0;
		const delta = count - oldCount;

		// Emerging Patterns (3+ mentions)
		if (count >= 3) {
			const level: EmergingPattern['level'] =
				count >= 8 ? 'high' : count >= 5 ? 'elevated' : 'emerging';

			results.emergingPatterns.push({
				id: topic.id,
				name: formatTopicName(topic.id),
				category: topic.category,
				count,
				level,
				sources,
				headlines
			});
		}

		// Momentum Signals (rising topics)
		if (delta >= 2 || (count >= 3 && delta >= 1)) {
			const momentum: MomentumSignal['momentum'] =
				delta >= 4 ? 'surging' : delta >= 2 ? 'rising' : 'stable';

			results.momentumSignals.push({
				id: topic.id,
				name: formatTopicName(topic.id),
				category: topic.category,
				current: count,
				delta,
				momentum,
				headlines
			});
		}

		// Cross-Source Correlations (3+ sources)
		if (sources.length >= 3) {
			const level: CrossSourceCorrelation['level'] =
				sources.length >= 5 ? 'high' : sources.length >= 4 ? 'elevated' : 'emerging';

			results.crossSourceCorrelations.push({
				id: topic.id,
				name: formatTopicName(topic.id),
				category: topic.category,
				sourceCount: sources.length,
				sources,
				level,
				headlines
			});
		}

		// Predictive Signals (based on combined score)
		const score = count * 2 + sources.length * 3 + delta * 5;

		if (score >= 15) {
			const confidence = Math.min(95, Math.round(score * 1.5));
			const prediction = getPrediction(topic, count);
			const level: PredictiveSignal['level'] =
				confidence >= 70 ? 'high' : confidence >= 50 ? 'medium' : 'low';

			results.predictiveSignals.push({
				id: topic.id,
				name: formatTopicName(topic.id),
				category: topic.category,
				score,
				confidence,
				prediction,
				level,
				headlines
			});
		}
	}

	// Sort results
	results.emergingPatterns.sort((a, b) => b.count - a.count);
	results.momentumSignals.sort((a, b) => b.delta - a.delta);
	results.crossSourceCorrelations.sort((a, b) => b.sourceCount - a.sourceCount);
	results.predictiveSignals.sort((a, b) => b.score - a.score);

	return results;
}

/**
 * Generate prediction text based on topic and count
 */
function getPrediction(topic: CorrelationTopic, count: number): string {
	if (topic.id === 'tariffs' && count >= 4) {
		return 'Market volatility likely in next 24-48h';
	}
	if (topic.id === 'fed-rates') {
		return 'Expect increased financial sector coverage';
	}
	if (topic.id.includes('china') || topic.id.includes('russia')) {
		return 'Geopolitical escalation narrative forming';
	}
	if (topic.id === 'layoffs') {
		return 'Employment concerns may dominate news cycle';
	}
	if (topic.category === 'Conflict') {
		return 'Breaking developments likely within hours';
	}
	return 'Topic gaining mainstream traction';
}

/**
 * Get correlation summary for status display
 */
export function getCorrelationSummary(results: CorrelationResults | null): {
	totalSignals: number;
	status: string;
} {
	if (!results) {
		return { totalSignals: 0, status: 'NO DATA' };
	}

	const totalSignals =
		results.emergingPatterns.length +
		results.momentumSignals.length +
		results.predictiveSignals.length;

	return {
		totalSignals,
		status: totalSignals > 0 ? `${totalSignals} SIGNALS` : 'MONITORING'
	};
}

/**
 * Clear topic history (for testing or reset)
 */
export function clearCorrelationHistory(): void {
	for (const key of Object.keys(topicHistory)) {
		delete topicHistory[parseInt(key)];
	}
}



================================================
FILE: src/lib/analysis/index.ts
================================================
/**
 * Analysis module barrel file
 */

// Correlation engine
export {
	analyzeCorrelations,
	getCorrelationSummary,
	clearCorrelationHistory,
	type EmergingPattern,
	type MomentumSignal,
	type CrossSourceCorrelation,
	type PredictiveSignal,
	type CorrelationResults
} from './correlation';

// Narrative tracker
export {
	analyzeNarratives,
	getNarrativeSummary,
	clearNarrativeHistory,
	type NarrativeData,
	type EmergingFringe,
	type FringeToMainstream,
	type NarrativeResults
} from './narrative';

// Main character
export {
	calculateMainCharacter,
	getMainCharacterSummary,
	calculateDominance,
	type MainCharacterEntry,
	type MainCharacterResults
} from './main-character';



================================================
FILE: src/lib/analysis/main-character.test.ts
================================================
/**
 * Tests for main character analysis
 */

import { describe, it, expect } from 'vitest';
import {
	calculateMainCharacter,
	getMainCharacterSummary,
	calculateDominance
} from './main-character';
import type { NewsItem } from '$lib/types';

describe('Main Character Analysis', () => {
	it('should return empty results for empty news', () => {
		const results = calculateMainCharacter([]);
		expect(results.characters).toEqual([]);
		expect(results.topCharacter).toBeNull();
	});

	it('should count mentions correctly', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Trump announces policy',
				source: 'BBC',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Trump speaks at rally',
				source: 'CNN',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '3',
				title: 'Biden meets with leaders',
				source: 'NYT',
				link: 'c',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = calculateMainCharacter(news);

		expect(results.characters.length).toBeGreaterThan(0);
		expect(results.topCharacter?.name).toBe('Trump');
		expect(results.topCharacter?.count).toBe(2);
	});

	it('should rank characters by mention count', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Musk buys company',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '2',
				title: 'Elon announces feature',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '3',
				title: 'Musk tweets again',
				source: 'C',
				link: 'c',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '4',
				title: 'Trump rally today',
				source: 'D',
				link: 'd',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = calculateMainCharacter(news);

		expect(results.characters[0].name).toBe('Elon Musk');
		expect(results.characters[0].count).toBe(3);
		expect(results.characters[0].rank).toBe(1);
	});

	it('should limit results to top 10', () => {
		// Create news mentioning many different people
		const names = [
			'Trump',
			'Biden',
			'Musk',
			'Putin',
			'Zelensky',
			'Xi',
			'Netanyahu',
			'Sam Altman',
			'Zuckerberg',
			'Bezos',
			'Tim Cook',
			'Powell'
		];

		const news: NewsItem[] = names.map((name, i) => ({
			id: String(i),
			title: `${name} in the news`,
			source: 'Source',
			link: `link${i}`,
			timestamp: Date.now(),
			category: 'politics' as const
		}));

		const results = calculateMainCharacter(news);

		expect(results.characters.length).toBeLessThanOrEqual(10);
	});

	it('should match multiple patterns for same person', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Elon Musk announces',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '2',
				title: 'Musk speaks out',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'tech'
			}
		];

		const results = calculateMainCharacter(news);

		// "Elon Musk" matches both "elon" and "musk" patterns, plus "Musk" matches "musk"
		// So total count is 3 (2 from first headline + 1 from second)
		expect(results.topCharacter?.name).toBe('Elon Musk');
		expect(results.topCharacter?.count).toBe(3);
	});

	it('should return correct summary', () => {
		const emptyResults = calculateMainCharacter([]);
		expect(getMainCharacterSummary(emptyResults)).toEqual({
			name: '',
			count: 0,
			status: 'NO DATA'
		});

		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Putin addresses nation',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Putin speaks on economy',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = calculateMainCharacter(news);
		const summary = getMainCharacterSummary(results);

		expect(summary.name).toBe('Putin');
		expect(summary.count).toBe(2);
		expect(summary.status).toContain('Putin');
		expect(summary.status).toContain('2 mentions');
	});

	it('should calculate dominance correctly', () => {
		// Single character = 100% dominance
		const singleNews: NewsItem[] = [
			{
				id: '1',
				title: 'Trump news',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			}
		];
		expect(calculateDominance(calculateMainCharacter(singleNews))).toBe(100);

		// Empty returns 100 (no competition = full dominance, edge case)
		expect(calculateDominance(calculateMainCharacter([]))).toBe(100);

		// Two characters with same count = 0% dominance
		const evenNews: NewsItem[] = [
			{
				id: '1',
				title: 'Trump speaks',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Biden responds',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			}
		];
		expect(calculateDominance(calculateMainCharacter(evenNews))).toBe(0);

		// Clear leader = high dominance (capped at 100)
		const dominantNews: NewsItem[] = [
			{
				id: '1',
				title: 'Musk announcement',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '2',
				title: 'Elon tweets',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '3',
				title: 'Musk company news',
				source: 'C',
				link: 'c',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '4',
				title: 'Trump rally',
				source: 'D',
				link: 'd',
				timestamp: Date.now(),
				category: 'politics'
			}
		];
		const dominance = calculateDominance(calculateMainCharacter(dominantNews));
		expect(dominance).toBe(100); // Dominance is capped at 100
	});

	it('should handle case insensitivity', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'TRUMP announces policy',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'trump speaks today',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = calculateMainCharacter(news);
		expect(results.topCharacter?.name).toBe('Trump');
		expect(results.topCharacter?.count).toBe(2);
	});
});



================================================
FILE: src/lib/analysis/main-character.ts
================================================
/**
 * Main Character analysis - tracks prominent figures in news
 */

import type { NewsItem } from '$lib/types';
import { PERSON_PATTERNS } from '$lib/config/analysis';

export interface MainCharacterEntry {
	name: string;
	count: number;
	rank: number;
}

export interface MainCharacterResults {
	characters: MainCharacterEntry[];
	topCharacter: MainCharacterEntry | null;
}

/**
 * Calculate the "Main Character" (most mentioned person) from news headlines
 */
export function calculateMainCharacter(allNews: NewsItem[]): MainCharacterResults {
	if (!allNews || allNews.length === 0) {
		return { characters: [], topCharacter: null };
	}

	const counts: Record<string, number> = {};

	// Count mentions for each person
	for (const item of allNews) {
		const text = (item.title || '').toLowerCase();

		for (const { pattern, name } of PERSON_PATTERNS) {
			// Reset lastIndex for global regex
			pattern.lastIndex = 0;
			const matches = text.match(pattern);

			if (matches) {
				counts[name] = (counts[name] || 0) + matches.length;
			}
		}
	}

	// Sort by count and create ranked entries
	const sorted = Object.entries(counts)
		.sort((a, b) => b[1] - a[1])
		.slice(0, 10)
		.map(([name, count], index) => ({
			name,
			count,
			rank: index + 1
		}));

	return {
		characters: sorted,
		topCharacter: sorted[0] || null
	};
}

/**
 * Get a summary of the main character for display
 */
export function getMainCharacterSummary(results: MainCharacterResults): {
	name: string;
	count: number;
	status: string;
} {
	if (!results.topCharacter) {
		return { name: '', count: 0, status: 'NO DATA' };
	}

	const { name, count } = results.topCharacter;
	return {
		name,
		count,
		status: `${name} (${count} mentions)`
	};
}

/**
 * Calculate relative dominance of main character
 * Returns a value 0-100 representing how dominant the top character is
 */
export function calculateDominance(results: MainCharacterResults): number {
	if (results.characters.length < 2) return 100;

	const top = results.characters[0];
	const second = results.characters[1];

	if (!top || top.count === 0) return 0;
	if (!second || second.count === 0) return 100;

	// Dominance is how much more the top is mentioned vs second
	const ratio = top.count / second.count;
	// Convert to 0-100 scale (ratio of 2 = 100% dominant)
	return Math.min(100, Math.round((ratio - 1) * 100));
}



================================================
FILE: src/lib/analysis/narrative.test.ts
================================================
/**
 * Tests for narrative tracker
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { analyzeNarratives, getNarrativeSummary, clearNarrativeHistory } from './narrative';
import type { NewsItem } from '$lib/types';

describe('Narrative Tracker', () => {
	beforeEach(() => {
		clearNarrativeHistory();
	});

	it('should return null for empty news', () => {
		expect(analyzeNarratives([])).toBeNull();
		expect(analyzeNarratives(null as unknown as NewsItem[])).toBeNull();
	});

	it('should detect narrative patterns', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Deep state allegations surface',
				source: 'Test',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Shadow government concerns',
				source: 'Test2',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeNarratives(news);

		expect(results).not.toBeNull();
		const deepState =
			results!.emergingFringe.find((n) => n.id === 'deep-state') ||
			results!.narrativeWatch.find((n) => n.id === 'deep-state');

		expect(deepState).toBeDefined();
		expect(deepState!.count).toBe(2);
	});

	it('should classify disinfo patterns', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Depopulation agenda exposed',
				source: 'Fringe',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeNarratives(news);

		expect(results!.disinfoSignals.length).toBeGreaterThan(0);
		expect(results!.disinfoSignals.find((n) => n.id === 'depopulation')).toBeDefined();
	});

	it('should detect fringe-to-mainstream crossover', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Lab leak theory gains traction',
				source: 'ZeroHedge',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '2',
				title: 'Lab leak investigation continues',
				source: 'BBC News',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics'
			},
			{
				id: '3',
				title: 'Bioweapon research concerns',
				source: 'CNN',
				link: 'c',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeNarratives(news);

		// Should detect the bio-weapon narrative crossing from fringe to mainstream
		expect(results!.fringeToMainstream.length).toBeGreaterThan(0);
	});

	it('should classify source types correctly', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Dollar collapse imminent',
				source: 'ZeroHedge',
				link: 'a',
				timestamp: Date.now(),
				category: 'finance'
			},
			{
				id: '2',
				title: 'Dedollarization fears',
				source: 'Infowars',
				link: 'b',
				timestamp: Date.now(),
				category: 'finance'
			}
		];

		const results = analyzeNarratives(news);

		const dollarNarrative = results!.emergingFringe.find((n) => n.id === 'dollar-collapse');

		expect(dollarNarrative).toBeDefined();
		expect(dollarNarrative!.fringeCount).toBeGreaterThan(0);
	});

	it('should track keywords and headlines', () => {
		const news: NewsItem[] = [
			{
				id: '1',
				title: 'AI doom predictions increase',
				source: 'Tech',
				link: 'a',
				timestamp: Date.now(),
				category: 'tech'
			},
			{
				id: '2',
				title: 'AI extinction risk debated',
				source: 'Tech2',
				link: 'b',
				timestamp: Date.now(),
				category: 'tech'
			}
		];

		const results = analyzeNarratives(news);

		const aiDoom =
			results!.emergingFringe.find((n) => n.id === 'ai-doom') ||
			results!.narrativeWatch.find((n) => n.id === 'ai-doom');

		expect(aiDoom).toBeDefined();
		expect(aiDoom!.keywords).toContain('ai doom');
		expect(aiDoom!.headlines.length).toBeGreaterThan(0);
	});

	it('should return correct summary', () => {
		expect(getNarrativeSummary(null)).toEqual({ total: 0, status: 'NO DATA' });

		const news: NewsItem[] = [
			{
				id: '1',
				title: 'Great reset concerns',
				source: 'Test',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics'
			}
		];

		const results = analyzeNarratives(news);
		const summary = getNarrativeSummary(results);

		expect(summary.total).toBeGreaterThan(0);
		expect(summary.status).toMatch(/ACTIVE/);
	});

	it('should limit sources to 5', () => {
		const news: NewsItem[] = Array.from({ length: 10 }, (_, i) => ({
			id: String(i),
			title: 'Deep state news',
			source: `Source${i}`,
			link: `link${i}`,
			timestamp: Date.now(),
			category: 'politics' as const
		}));

		const results = analyzeNarratives(news);

		const deepState =
			results!.emergingFringe.find((n) => n.id === 'deep-state') ||
			results!.narrativeWatch.find((n) => n.id === 'deep-state');

		expect(deepState!.sources.length).toBeLessThanOrEqual(5);
	});
});



================================================
FILE: src/lib/analysis/narrative.ts
================================================
/**
 * Narrative tracker - analyzes fringe-to-mainstream narrative propagation
 */

import type { NewsItem } from '$lib/types';
import { NARRATIVE_PATTERNS, SOURCE_TYPES, type NarrativePattern } from '$lib/config/analysis';

// Types for narrative results
export interface NarrativeData {
	id: string;
	name: string;
	category: string;
	severity: NarrativePattern['severity'];
	count: number;
	fringeCount: number;
	mainstreamCount: number;
	sources: string[];
	headlines: NewsItem[];
	keywords: string[];
}

export interface EmergingFringe extends NarrativeData {
	status: 'emerging' | 'spreading' | 'viral';
}

export interface FringeToMainstream extends NarrativeData {
	status: 'crossing';
	crossoverLevel: number;
}

export interface NarrativeResults {
	emergingFringe: EmergingFringe[];
	fringeToMainstream: FringeToMainstream[];
	narrativeWatch: NarrativeData[];
	disinfoSignals: NarrativeData[];
}

// Track narrative history for crossover detection
const narrativeHistory: Record<
	string,
	{
		firstSeen: number;
		sources: Set<string>;
	}
> = {};

/**
 * Format narrative ID to display name
 */
function formatNarrativeName(id: string): string {
	return id.replace(/-/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
}

/**
 * Classify source type
 */
function classifySource(source: string): 'fringe' | 'alternative' | 'mainstream' | null {
	const lowerSource = source.toLowerCase();

	for (const fringeSource of SOURCE_TYPES.fringe) {
		if (lowerSource.includes(fringeSource)) return 'fringe';
	}
	for (const altSource of SOURCE_TYPES.alternative) {
		if (lowerSource.includes(altSource)) return 'alternative';
	}
	for (const msSource of SOURCE_TYPES.mainstream) {
		if (lowerSource.includes(msSource)) return 'mainstream';
	}
	return null;
}

/**
 * Analyze narratives across all news items
 */
export function analyzeNarratives(allNews: NewsItem[]): NarrativeResults | null {
	if (!allNews || allNews.length === 0) return null;

	const now = Date.now();
	const results: NarrativeResults = {
		emergingFringe: [],
		fringeToMainstream: [],
		narrativeWatch: [],
		disinfoSignals: []
	};

	for (const narrative of NARRATIVE_PATTERNS) {
		const matches: NewsItem[] = [];
		const sourceMatches: {
			fringe: NewsItem[];
			alternative: NewsItem[];
			mainstream: NewsItem[];
		} = {
			fringe: [],
			alternative: [],
			mainstream: []
		};

		// Find matching news items
		for (const item of allNews) {
			const title = (item.title || '').toLowerCase();
			const source = (item.source || '').toLowerCase();

			const hasMatch = narrative.keywords.some((kw) => title.includes(kw.toLowerCase()));

			if (hasMatch) {
				matches.push(item);

				const sourceType = classifySource(source);
				if (sourceType) {
					sourceMatches[sourceType].push(item);
				}
			}
		}

		if (matches.length === 0) continue;

		// Update narrative history
		if (!narrativeHistory[narrative.id]) {
			narrativeHistory[narrative.id] = {
				firstSeen: now,
				sources: new Set()
			};
		}
		for (const match of matches) {
			narrativeHistory[narrative.id].sources.add(match.source);
		}

		// Build narrative data
		const narrativeData: NarrativeData = {
			id: narrative.id,
			name: formatNarrativeName(narrative.id),
			category: narrative.category,
			severity: narrative.severity,
			count: matches.length,
			fringeCount: sourceMatches.fringe.length,
			mainstreamCount: sourceMatches.mainstream.length,
			sources: [...new Set(matches.map((m) => m.source))].slice(0, 5),
			headlines: matches.slice(0, 3),
			keywords: narrative.keywords
		};

		// Categorize narrative
		if (sourceMatches.mainstream.length > 0 && sourceMatches.fringe.length > 0) {
			// Fringe to Mainstream crossover
			results.fringeToMainstream.push({
				...narrativeData,
				status: 'crossing',
				crossoverLevel: sourceMatches.mainstream.length / matches.length
			});
		} else if (narrative.severity === 'disinfo') {
			// Known disinformation pattern
			results.disinfoSignals.push(narrativeData);
		} else if (sourceMatches.fringe.length > 0 || sourceMatches.alternative.length > 0) {
			// Emerging from fringe sources
			const status: EmergingFringe['status'] =
				matches.length >= 5 ? 'viral' : matches.length >= 3 ? 'spreading' : 'emerging';

			results.emergingFringe.push({
				...narrativeData,
				status
			});
		} else {
			// General narrative watch
			results.narrativeWatch.push(narrativeData);
		}
	}

	// Sort results
	results.emergingFringe.sort((a, b) => b.count - a.count);
	results.fringeToMainstream.sort((a, b) => b.crossoverLevel - a.crossoverLevel);
	results.narrativeWatch.sort((a, b) => b.count - a.count);
	results.disinfoSignals.sort((a, b) => b.count - a.count);

	return results;
}

/**
 * Get narrative summary for status display
 */
export function getNarrativeSummary(results: NarrativeResults | null): {
	total: number;
	status: string;
} {
	if (!results) {
		return { total: 0, status: 'NO DATA' };
	}

	const total =
		results.emergingFringe.length +
		results.fringeToMainstream.length +
		results.narrativeWatch.length +
		results.disinfoSignals.length;

	return {
		total,
		status: total > 0 ? `${total} ACTIVE` : 'MONITORING'
	};
}

/**
 * Clear narrative history (for testing or reset)
 */
export function clearNarrativeHistory(): void {
	for (const key of Object.keys(narrativeHistory)) {
		delete narrativeHistory[key];
	}
}



================================================
FILE: src/lib/api/fred.ts
================================================
/**
 * FRED API - Federal Reserve Economic Data
 * Also includes Fed RSS feed fetching for news/speeches
 *
 * Get your free API key at: https://fred.stlouisfed.org/docs/api/api_key.html
 */

import { FRED_API_KEY, FRED_BASE_URL, logger, fetchWithProxy } from '$lib/config/api';

export interface FredObservation {
	date: string;
	value: string;
}

export interface FredSeriesResponse {
	observations: FredObservation[];
}

export interface EconomicIndicator {
	seriesId: string;
	name: string;
	value: number | null;
	previousValue: number | null;
	change: number | null;
	unit: string;
	date: string | null;
}

export interface FedIndicators {
	fedFundsRate: EconomicIndicator;
	cpi: EconomicIndicator;
	treasury10Y: EconomicIndicator;
}

/**
 * Check if FRED API key is configured
 */
export function isFredConfigured(): boolean {
	return FRED_API_KEY.length > 0;
}

/**
 * Create an empty indicator (used for error/missing data states)
 */
function createEmptyIndicator(seriesId: string, name: string, unit: string): EconomicIndicator {
	return {
		seriesId,
		name,
		value: null,
		previousValue: null,
		change: null,
		unit,
		date: null
	};
}

/**
 * Fetch a single FRED series with the latest 2 observations
 */
async function fetchFredSeries(seriesId: string): Promise<FredObservation[]> {
	try {
		const url = `${FRED_BASE_URL}/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&sort_order=desc&limit=2`;
		const response = await fetch(url);

		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		const data: FredSeriesResponse = await response.json();
		return data.observations || [];
	} catch (error) {
		logger.error('FRED API', `Error fetching series ${seriesId}:`, error);
		return [];
	}
}

/**
 * Parse FRED observation value (handles "." for missing data)
 */
function parseValue(obs: FredObservation | undefined): number | null {
	if (!obs || obs.value === '.') return null;
	const val = parseFloat(obs.value);
	return isNaN(val) ? null : val;
}

/**
 * Fetch Federal Funds Effective Rate
 * Series: FEDFUNDS (monthly)
 */
async function fetchFedFundsRate(): Promise<EconomicIndicator> {
	const seriesId = 'FEDFUNDS';
	const name = 'Fed Funds Rate';
	const unit = '%';

	if (!isFredConfigured()) {
		return createEmptyIndicator(seriesId, name, unit);
	}

	const observations = await fetchFredSeries(seriesId);
	const current = parseValue(observations[0]);
	const previous = parseValue(observations[1]);

	return {
		seriesId,
		name,
		value: current,
		previousValue: previous,
		change: current !== null && previous !== null ? current - previous : null,
		unit,
		date: observations[0]?.date || null
	};
}

/**
 * Fetch Consumer Price Index (Year-over-Year % Change)
 * Series: CPIAUCSL (monthly, we calculate YoY change)
 */
async function fetchCPI(): Promise<EconomicIndicator> {
	const seriesId = 'CPIAUCSL';
	const name = 'CPI Inflation';
	const unit = '%';

	if (!isFredConfigured()) {
		return createEmptyIndicator(seriesId, name, unit);
	}

	try {
		// Fetch 14 observations: current + 12 months ago, plus previous month + 13 months ago
		const url = `${FRED_BASE_URL}/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&sort_order=desc&limit=14`;
		const response = await fetch(url);

		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		const data: FredSeriesResponse = await response.json();
		const observations = data.observations || [];

		if (observations.length < 13) {
			return createEmptyIndicator(seriesId, name, unit);
		}

		const currentCPI = parseValue(observations[0]);
		const yearAgoCPI = parseValue(observations[12]);
		const previousMonthCPI = parseValue(observations[1]);
		const prevYearAgoCPI = observations.length >= 14 ? parseValue(observations[13]) : yearAgoCPI;

		if (currentCPI === null || yearAgoCPI === null) {
			return createEmptyIndicator(seriesId, name, unit);
		}

		const yoyChange = ((currentCPI - yearAgoCPI) / yearAgoCPI) * 100;
		const prevYoyChange =
			previousMonthCPI !== null && prevYearAgoCPI !== null
				? ((previousMonthCPI - prevYearAgoCPI) / prevYearAgoCPI) * 100
				: null;

		return {
			seriesId,
			name,
			value: Math.round(yoyChange * 100) / 100,
			previousValue: prevYoyChange !== null ? Math.round(prevYoyChange * 100) / 100 : null,
			change: prevYoyChange !== null ? Math.round((yoyChange - prevYoyChange) * 100) / 100 : null,
			unit,
			date: observations[0]?.date || null
		};
	} catch (error) {
		logger.error('FRED API', 'Error fetching CPI:', error);
		return createEmptyIndicator(seriesId, name, unit);
	}
}

/**
 * Fetch 10-Year Treasury Constant Maturity Rate
 * Series: DGS10 (daily)
 */
async function fetchTreasury10Y(): Promise<EconomicIndicator> {
	const seriesId = 'DGS10';
	const name = '10Y Treasury';
	const unit = '%';

	if (!isFredConfigured()) {
		return createEmptyIndicator(seriesId, name, unit);
	}

	const observations = await fetchFredSeries(seriesId);
	const current = parseValue(observations[0]);
	const previous = parseValue(observations[1]);

	return {
		seriesId,
		name,
		value: current,
		previousValue: previous,
		change:
			current !== null && previous !== null ? Math.round((current - previous) * 100) / 100 : null,
		unit,
		date: observations[0]?.date || null
	};
}

/**
 * Fetch all Fed economic indicators
 */
export async function fetchFedIndicators(): Promise<FedIndicators> {
	logger.log('FRED API', 'Fetching Fed indicators');

	const [fedFundsRate, cpi, treasury10Y] = await Promise.all([
		fetchFedFundsRate(),
		fetchCPI(),
		fetchTreasury10Y()
	]);

	return { fedFundsRate, cpi, treasury10Y };
}

// ============================================================================
// Fed RSS News Fetching
// ============================================================================

const FED_BASE_URL = 'https://www.federalreserve.gov';

/**
 * Fed RSS feed configuration
 */
const FED_RSS_FEEDS = [
	{ url: `${FED_BASE_URL}/feeds/press_monetary.xml`, type: 'monetary', label: 'Monetary Policy' },
	{ url: `${FED_BASE_URL}/feeds/s_t_powell.xml`, type: 'powell', label: 'Chair Powell' },
	{ url: `${FED_BASE_URL}/feeds/speeches.xml`, type: 'speech', label: 'Speeches' },
	{ url: `${FED_BASE_URL}/feeds/testimony.xml`, type: 'testimony', label: 'Testimony' },
	{ url: `${FED_BASE_URL}/feeds/press_other.xml`, type: 'announcement', label: 'Announcements' }
] as const;

export type FedNewsType = (typeof FED_RSS_FEEDS)[number]['type'];

export interface FedNewsItem {
	id: string;
	title: string;
	link: string;
	description: string;
	pubDate: string;
	timestamp: number;
	type: FedNewsType;
	typeLabel: string;
	isPowellRelated: boolean;
	hasVideo: boolean;
}

/**
 * Simple hash for generating unique IDs
 */
function hashString(str: string): string {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		const char = str.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash = hash & hash;
	}
	return Math.abs(hash).toString(36);
}

/**
 * Parse RSS XML and extract items
 */
function parseRssXml(xml: string, type: FedNewsType, typeLabel: string): FedNewsItem[] {
	const items: FedNewsItem[] = [];

	// Simple regex-based XML parsing for RSS items
	const itemRegex = /<item>([\s\S]*?)<\/item>/gi;
	const titleRegex = /<title>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/title>/i;
	const linkRegex = /<link>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/link>/i;
	const descRegex = /<description>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/description>/i;
	const pubDateRegex = /<pubDate>([\s\S]*?)<\/pubDate>/i;

	let match;
	while ((match = itemRegex.exec(xml)) !== null) {
		const itemXml = match[1];

		const titleMatch = titleRegex.exec(itemXml);
		const linkMatch = linkRegex.exec(itemXml);
		const descMatch = descRegex.exec(itemXml);
		const pubDateMatch = pubDateRegex.exec(itemXml);

		const title = titleMatch?.[1]?.trim() || '';
		const link = linkMatch?.[1]?.trim() || '';
		const description = descMatch?.[1]?.trim().replace(/<[^>]*>/g, '') || '';
		const pubDate = pubDateMatch?.[1]?.trim() || '';

		if (!title || !link) continue;

		const fullText = `${title} ${description}`.toLowerCase();
		const isPowellRelated = type === 'powell' || /powell|chair(?:man)?/.test(fullText);
		const hasVideo = /video|webcast|watch|broadcast|live/.test(fullText);

		items.push({
			id: `fed-${type}-${hashString(link)}`,
			title,
			link: link.startsWith('http') ? link : `${FED_BASE_URL}${link}`,
			description,
			pubDate,
			timestamp: pubDate ? new Date(pubDate).getTime() : Date.now(),
			type,
			typeLabel,
			isPowellRelated,
			hasVideo
		});
	}

	return items;
}

/**
 * Fetch a single Fed RSS feed
 */
async function fetchFedRssFeed(
	url: string,
	type: FedNewsType,
	typeLabel: string
): Promise<FedNewsItem[]> {
	try {
		logger.log('Fed RSS', `Fetching ${typeLabel} from ${url}`);
		const response = await fetchWithProxy(url);

		if (!response.ok) {
			throw new Error(`HTTP ${response.status}`);
		}

		const xml = await response.text();
		return parseRssXml(xml, type, typeLabel);
	} catch (error) {
		logger.error('Fed RSS', `Error fetching ${typeLabel}:`, error);
		return [];
	}
}

/**
 * Fetch all Fed news from RSS feeds
 */
export async function fetchFedNews(): Promise<FedNewsItem[]> {
	logger.log('Fed RSS', 'Fetching all Fed news feeds');

	const results = await Promise.all(
		FED_RSS_FEEDS.map((feed) => fetchFedRssFeed(feed.url, feed.type, feed.label))
	);

	// Flatten and dedupe by link
	const seen = new Set<string>();
	const allItems: FedNewsItem[] = [];

	for (const items of results) {
		for (const item of items) {
			if (!seen.has(item.link)) {
				seen.add(item.link);
				allItems.push(item);
			}
		}
	}

	// Sort by timestamp (newest first), with Powell items boosted
	return allItems.sort((a, b) => {
		// Powell items get priority
		if (a.isPowellRelated && !b.isPowellRelated) return -1;
		if (!a.isPowellRelated && b.isPowellRelated) return 1;
		// Then by timestamp
		return b.timestamp - a.timestamp;
	});
}



================================================
FILE: src/lib/api/index.ts
================================================
/**
 * API barrel exports
 */

export { fetchCategoryNews, fetchAllNews } from './news';
export {
	fetchCryptoPrices,
	fetchIndices,
	fetchSectorPerformance,
	fetchCommodities,
	fetchAllMarkets
} from './markets';
export { fetchPolymarket, fetchWhaleTransactions, fetchGovContracts, fetchLayoffs } from './misc';
export type { Prediction, WhaleTransaction, Contract, Layoff } from './misc';
export { fetchWorldLeaders } from './leaders';
export { fetchFedIndicators, fetchFedNews, isFredConfigured } from './fred';
export type { FedIndicators, EconomicIndicator, FedNewsItem, FedNewsType } from './fred';



================================================
FILE: src/lib/api/leaders.ts
================================================
/**
 * World Leaders API - Fetch news for world leaders from GDELT
 */

import { WORLD_LEADERS } from '$lib/config/leaders';
import type { WorldLeader, LeaderNews } from '$lib/types';
import { CORS_PROXY_URL, logger } from '$lib/config/api';

interface GdeltArticle {
	title: string;
	url: string;
	seendate: string;
	domain: string;
}

interface GdeltResponse {
	articles?: GdeltArticle[];
}

/**
 * Fetch news for a single leader
 */
async function fetchLeaderNews(leader: WorldLeader): Promise<WorldLeader> {
	// Build query from leader's keywords
	const query = leader.keywords.map((k) => `"${k}"`).join(' OR ');

	try {
		const gdeltUrl = `https://api.gdeltproject.org/api/v2/doc/doc?query=${query}&mode=artlist&maxrecords=5&format=json&sort=date`;
		const proxyUrl = CORS_PROXY_URL + encodeURIComponent(gdeltUrl);

		const response = await fetch(proxyUrl);
		if (!response.ok) {
			throw new Error(`HTTP ${response.status}`);
		}

		const contentType = response.headers.get('content-type');
		if (!contentType?.includes('application/json')) {
			return { ...leader, news: [] };
		}

		const text = await response.text();
		let data: GdeltResponse;
		try {
			data = JSON.parse(text);
		} catch {
			return { ...leader, news: [] };
		}

		const news: LeaderNews[] = (data.articles || []).map((article) => ({
			source: article.domain || 'Unknown',
			title: article.title || '',
			link: article.url || '',
			pubDate: article.seendate || ''
		}));

		return { ...leader, news };
	} catch (error) {
		logger.warn('Leaders API', `Error fetching news for ${leader.name}:`, error);
		return { ...leader, news: [] };
	}
}

/**
 * Fetch news for all world leaders
 * Batches requests to avoid rate limits
 */
export async function fetchWorldLeaders(): Promise<WorldLeader[]> {
	const batchSize = 5;
	const results: WorldLeader[] = [];

	// Fetch in batches to avoid rate limits
	for (let i = 0; i < WORLD_LEADERS.length; i += batchSize) {
		const batch = WORLD_LEADERS.slice(i, i + batchSize);
		const batchResults = await Promise.allSettled(batch.map(fetchLeaderNews));

		for (const result of batchResults) {
			if (result.status === 'fulfilled') {
				results.push(result.value);
			}
		}

		// Small delay between batches
		if (i + batchSize < WORLD_LEADERS.length) {
			await new Promise((resolve) => setTimeout(resolve, 300));
		}
	}

	// Sort by news activity (leaders with more news first)
	return results.sort((a, b) => (b.news?.length || 0) - (a.news?.length || 0));
}



================================================
FILE: src/lib/api/markets.ts
================================================
/**
 * Markets API - Fetch market data from Finnhub
 *
 * Get your free API key at: https://finnhub.io/
 * Free tier: 60 calls/minute
 */

import { INDICES, SECTORS, COMMODITIES, CRYPTO } from '$lib/config/markets';
import type { MarketItem, SectorPerformance, CryptoItem } from '$lib/types';
import { fetchWithProxy, logger, FINNHUB_API_KEY, FINNHUB_BASE_URL } from '$lib/config/api';

interface CoinGeckoPrice {
	usd: number;
	usd_24h_change?: number;
}

interface CoinGeckoPricesResponse {
	[key: string]: CoinGeckoPrice;
}

interface FinnhubQuote {
	c: number; // Current price
	d: number; // Change
	dp: number; // Percent change
	h: number; // High price of the day
	l: number; // Low price of the day
	o: number; // Open price of the day
	pc: number; // Previous close price
	t: number; // Timestamp
}

/**
 * Check if Finnhub API key is configured
 */
function hasFinnhubApiKey(): boolean {
	return Boolean(FINNHUB_API_KEY && FINNHUB_API_KEY.length > 0);
}

/**
 * Create an empty market item (used for error/missing data states)
 */
function createEmptyMarketItem<T extends 'index' | 'commodity'>(
	symbol: string,
	name: string,
	type: T
): MarketItem {
	return { symbol, name, price: NaN, change: NaN, changePercent: NaN, type };
}

/**
 * Create an empty sector performance item
 */
function createEmptySectorItem(symbol: string, name: string): SectorPerformance {
	return { symbol, name, price: NaN, change: NaN, changePercent: NaN };
}

// Map index symbols to ETF proxies (free tier doesn't support direct indices)
const INDEX_ETF_MAP: Record<string, string> = {
	'^DJI': 'DIA', // Dow Jones -> SPDR Dow Jones ETF
	'^GSPC': 'SPY', // S&P 500 -> SPDR S&P 500 ETF
	'^IXIC': 'QQQ', // NASDAQ -> Invesco QQQ (NASDAQ-100)
	'^RUT': 'IWM' // Russell 2000 -> iShares Russell 2000 ETF
};

/**
 * Fetch a quote from Finnhub
 */
async function fetchFinnhubQuote(symbol: string): Promise<FinnhubQuote | null> {
	try {
		const url = `${FINNHUB_BASE_URL}/quote?symbol=${encodeURIComponent(symbol)}&token=${FINNHUB_API_KEY}`;
		const response = await fetch(url);

		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		const data: FinnhubQuote = await response.json();

		// Finnhub returns all zeros when symbol not found
		if (data.c === 0 && data.pc === 0) {
			return null;
		}

		return data;
	} catch (error) {
		logger.error('Markets API', `Error fetching quote for ${symbol}:`, error);
		return null;
	}
}

/**
 * Fetch crypto prices from CoinGecko via proxy
 */
export async function fetchCryptoPrices(): Promise<CryptoItem[]> {
	try {
		const ids = CRYPTO.map((c) => c.id).join(',');
		const coinGeckoUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24hr_change=true`;

		logger.log('Markets API', 'Fetching crypto from CoinGecko');

		const response = await fetchWithProxy(coinGeckoUrl);
		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		const data: CoinGeckoPricesResponse = await response.json();

		return CRYPTO.map((crypto) => {
			const priceData = data[crypto.id];
			return {
				id: crypto.id,
				symbol: crypto.symbol,
				name: crypto.name,
				current_price: priceData?.usd || 0,
				price_change_24h: priceData?.usd_24h_change || 0,
				price_change_percentage_24h: priceData?.usd_24h_change || 0
			};
		});
	} catch (error) {
		logger.error('Markets API', 'Error fetching crypto:', error);
		return CRYPTO.map((c) => ({
			id: c.id,
			symbol: c.symbol,
			name: c.name,
			current_price: 0,
			price_change_24h: 0,
			price_change_percentage_24h: 0
		}));
	}
}

/**
 * Fetch market indices from Finnhub
 */
export async function fetchIndices(): Promise<MarketItem[]> {
	const createEmptyIndices = () =>
		INDICES.map((i) => createEmptyMarketItem(i.symbol, i.name, 'index'));

	if (!hasFinnhubApiKey()) {
		logger.warn('Markets API', 'Finnhub API key not configured. Add VITE_FINNHUB_API_KEY to .env');
		return createEmptyIndices();
	}

	try {
		logger.log('Markets API', 'Fetching indices from Finnhub');

		const quotes = await Promise.all(
			INDICES.map(async (index) => {
				const etfSymbol = INDEX_ETF_MAP[index.symbol] || index.symbol;
				const quote = await fetchFinnhubQuote(etfSymbol);
				return { index, quote };
			})
		);

		return quotes.map(({ index, quote }) => ({
			symbol: index.symbol,
			name: index.name,
			price: quote?.c ?? NaN,
			change: quote?.d ?? NaN,
			changePercent: quote?.dp ?? NaN,
			type: 'index' as const
		}));
	} catch (error) {
		logger.error('Markets API', 'Error fetching indices:', error);
		return createEmptyIndices();
	}
}

/**
 * Fetch sector performance from Finnhub (using sector ETFs)
 */
export async function fetchSectorPerformance(): Promise<SectorPerformance[]> {
	const createEmptySectors = () =>
		SECTORS.map((s) => createEmptySectorItem(s.symbol, s.name));

	if (!hasFinnhubApiKey()) {
		logger.warn('Markets API', 'Finnhub API key not configured');
		return createEmptySectors();
	}

	try {
		logger.log('Markets API', 'Fetching sector performance from Finnhub');

		const quotes = await Promise.all(
			SECTORS.map(async (sector) => {
				const quote = await fetchFinnhubQuote(sector.symbol);
				return { sector, quote };
			})
		);

		return quotes.map(({ sector, quote }) => ({
			symbol: sector.symbol,
			name: sector.name,
			price: quote?.c ?? NaN,
			change: quote?.d ?? NaN,
			changePercent: quote?.dp ?? NaN
		}));
	} catch (error) {
		logger.error('Markets API', 'Error fetching sectors:', error);
		return createEmptySectors();
	}
}

// Finnhub commodity ETF proxies (free tier doesn't support direct commodities)
const COMMODITY_SYMBOL_MAP: Record<string, string> = {
	'^VIX': 'VIXY', // VIX -> ProShares VIX Short-Term Futures ETF
	'GC=F': 'GLD', // Gold -> SPDR Gold Shares
	'CL=F': 'USO', // Crude Oil -> United States Oil Fund
	'NG=F': 'UNG', // Natural Gas -> United States Natural Gas Fund
	'SI=F': 'SLV', // Silver -> iShares Silver Trust
	'HG=F': 'CPER' // Copper -> United States Copper Index Fund
};

/**
 * Fetch commodities from Finnhub
 */
export async function fetchCommodities(): Promise<MarketItem[]> {
	const createEmptyCommodities = () =>
		COMMODITIES.map((c) => createEmptyMarketItem(c.symbol, c.name, 'commodity'));

	if (!hasFinnhubApiKey()) {
		logger.warn('Markets API', 'Finnhub API key not configured');
		return createEmptyCommodities();
	}

	try {
		logger.log('Markets API', 'Fetching commodities from Finnhub');

		const quotes = await Promise.all(
			COMMODITIES.map(async (commodity) => {
				const finnhubSymbol = COMMODITY_SYMBOL_MAP[commodity.symbol] || commodity.symbol;
				const quote = await fetchFinnhubQuote(finnhubSymbol);
				return { commodity, quote };
			})
		);

		return quotes.map(({ commodity, quote }) => ({
			symbol: commodity.symbol,
			name: commodity.name,
			price: quote?.c ?? NaN,
			change: quote?.d ?? NaN,
			changePercent: quote?.dp ?? NaN,
			type: 'commodity' as const
		}));
	} catch (error) {
		logger.error('Markets API', 'Error fetching commodities:', error);
		return createEmptyCommodities();
	}
}

interface AllMarketsData {
	crypto: CryptoItem[];
	indices: MarketItem[];
	sectors: SectorPerformance[];
	commodities: MarketItem[];
}

/**
 * Fetch all market data
 */
export async function fetchAllMarkets(): Promise<AllMarketsData> {
	const [crypto, indices, sectors, commodities] = await Promise.all([
		fetchCryptoPrices(),
		fetchIndices(),
		fetchSectorPerformance(),
		fetchCommodities()
	]);

	return { crypto, indices, sectors, commodities };
}



================================================
FILE: src/lib/api/misc.ts
================================================
/**
 * Miscellaneous API functions for specialized panels
 * Note: Some of these use mock data as the original APIs require authentication
 */

export interface Prediction {
	id: string;
	question: string;
	yes: number;
	volume: string;
}

export interface WhaleTransaction {
	coin: string;
	amount: number;
	usd: number;
	hash: string;
}

export interface Contract {
	agency: string;
	description: string;
	vendor: string;
	amount: number;
}

export interface Layoff {
	company: string;
	count: number;
	title: string;
	date: string;
}

/**
 * Fetch Polymarket predictions
 * Note: Polymarket API requires authentication - returns curated prediction data
 */
export async function fetchPolymarket(): Promise<Prediction[]> {
	// These represent active prediction markets on major events
	return [
		{
			id: 'pm-1',
			question: 'Will there be a US-China military incident in 2026?',
			yes: 18,
			volume: '2.4M'
		},
		{ id: 'pm-2', question: 'Will Bitcoin reach $150K by end of 2026?', yes: 35, volume: '8.1M' },
		{ id: 'pm-3', question: 'Will Fed cut rates in Q1 2026?', yes: 42, volume: '5.2M' },
		{ id: 'pm-4', question: 'Will AI cause major job losses in 2026?', yes: 28, volume: '1.8M' },
		{ id: 'pm-5', question: 'Will Ukraine conflict end in 2026?', yes: 22, volume: '3.5M' },
		{ id: 'pm-6', question: 'Will oil prices exceed $100/barrel?', yes: 31, volume: '2.1M' },
		{
			id: 'pm-7',
			question: 'Will there be a major cyberattack on US infrastructure?',
			yes: 45,
			volume: '1.5M'
		}
	];
}

/**
 * Fetch whale transactions
 * Note: Would use Whale Alert API - returning sample data
 */
export async function fetchWhaleTransactions(): Promise<WhaleTransaction[]> {
	// Sample whale transaction data
	return [
		{ coin: 'BTC', amount: 1500, usd: 150000000, hash: '0x1a2b...3c4d' },
		{ coin: 'ETH', amount: 25000, usd: 85000000, hash: '0x5e6f...7g8h' },
		{ coin: 'BTC', amount: 850, usd: 85000000, hash: '0x9i0j...1k2l' },
		{ coin: 'SOL', amount: 500000, usd: 75000000, hash: '0x3m4n...5o6p' },
		{ coin: 'ETH', amount: 15000, usd: 51000000, hash: '0x7q8r...9s0t' }
	];
}

/**
 * Fetch government contracts
 * Note: Would use USASpending.gov API - returning sample data
 */
export async function fetchGovContracts(): Promise<Contract[]> {
	// Sample government contract data
	return [
		{
			agency: 'DOD',
			description: 'Advanced radar systems development and integration',
			vendor: 'Raytheon',
			amount: 2500000000
		},
		{
			agency: 'NASA',
			description: 'Artemis program lunar lander support services',
			vendor: 'SpaceX',
			amount: 1800000000
		},
		{
			agency: 'DHS',
			description: 'Border security technology modernization',
			vendor: 'Palantir',
			amount: 450000000
		},
		{
			agency: 'VA',
			description: 'Electronic health records system upgrade',
			vendor: 'Oracle Cerner',
			amount: 320000000
		},
		{
			agency: 'DOE',
			description: 'Clean energy grid infrastructure',
			vendor: 'General Electric',
			amount: 275000000
		}
	];
}

/**
 * Fetch layoffs data
 * Note: Would use layoffs.fyi API or similar - returning sample data
 */
export async function fetchLayoffs(): Promise<Layoff[]> {
	const now = new Date();
	const formatDate = (daysAgo: number) => {
		const d = new Date(now);
		d.setDate(d.getDate() - daysAgo);
		return d.toISOString();
	};

	return [
		{ company: 'Meta', count: 1200, title: 'Restructuring engineering teams', date: formatDate(2) },
		{ company: 'Amazon', count: 850, title: 'AWS division optimization', date: formatDate(5) },
		{
			company: 'Salesforce',
			count: 700,
			title: 'Post-acquisition consolidation',
			date: formatDate(8)
		},
		{
			company: 'Intel',
			count: 1500,
			title: 'Manufacturing pivot restructure',
			date: formatDate(12)
		},
		{ company: 'Snap', count: 500, title: 'Cost reduction initiative', date: formatDate(15) }
	];
}



================================================
FILE: src/lib/api/news.ts
================================================
/**
 * News API - Fetch news from GDELT and other sources
 */

import { FEEDS } from '$lib/config/feeds';
import type { NewsItem, NewsCategory } from '$lib/types';
import { containsAlertKeyword, detectRegion, detectTopics } from '$lib/config/keywords';
import { fetchWithProxy, API_DELAYS, logger } from '$lib/config/api';

/**
 * Simple hash function to generate unique IDs from URLs
 */
function hashCode(str: string): string {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		const char = str.charCodeAt(i);
		hash = (hash << 5) - hash + char;
		hash = hash & hash; // Convert to 32bit integer
	}
	return Math.abs(hash).toString(36);
}

/**
 * Delay helper
 */
function delay(ms: number): Promise<void> {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Parse GDELT date format (20251202T224500Z) to valid Date
 */
function parseGdeltDate(dateStr: string): Date {
	if (!dateStr) return new Date();
	// Convert 20251202T224500Z to 2025-12-02T22:45:00Z
	const match = dateStr.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z$/);
	if (match) {
		const [, year, month, day, hour, min, sec] = match;
		return new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`);
	}
	// Fallback to standard parsing
	return new Date(dateStr);
}

interface GdeltArticle {
	title: string;
	url: string;
	seendate: string;
	domain: string;
	socialimage?: string;
}

interface GdeltResponse {
	articles?: GdeltArticle[];
}

/**
 * Transform GDELT article to NewsItem
 */
function transformGdeltArticle(
	article: GdeltArticle,
	category: NewsCategory,
	source: string,
	index: number
): NewsItem {
	const title = article.title || '';
	const alert = containsAlertKeyword(title);
	// Generate unique ID using category, URL hash, and index
	const urlHash = article.url ? hashCode(article.url) : Math.random().toString(36).slice(2);
	const uniqueId = `gdelt-${category}-${urlHash}-${index}`;

	const parsedDate = parseGdeltDate(article.seendate);

	return {
		id: uniqueId,
		title,
		link: article.url,
		pubDate: article.seendate,
		timestamp: parsedDate.getTime(),
		source: source || article.domain || 'Unknown',
		category,
		isAlert: !!alert,
		alertKeyword: alert?.keyword || undefined,
		region: detectRegion(title) ?? undefined,
		topics: detectTopics(title)
	};
}

/**
 * Fetch news for a specific category using GDELT via proxy
 */
export async function fetchCategoryNews(category: NewsCategory): Promise<NewsItem[]> {
	// Build query from category keywords (GDELT requires OR queries in parentheses)
	const categoryQueries: Record<NewsCategory, string> = {
		politics: '(politics OR government OR election OR congress)',
		tech: '(technology OR software OR startup OR "silicon valley")',
		finance: '(finance OR "stock market" OR economy OR banking)',
		gov: '("federal government" OR "white house" OR congress OR regulation)',
		ai: '("artificial intelligence" OR "machine learning" OR AI OR ChatGPT)',
		intel: '(intelligence OR security OR military OR defense)'
	};

	try {
		// Add English language filter and timespan for fresh results
		const baseQuery = categoryQueries[category];
		const fullQuery = `${baseQuery} sourcelang:english`;
		// Build the raw GDELT URL with timespan=7d to get recent articles
		const gdeltUrl = `https://api.gdeltproject.org/api/v2/doc/doc?query=${fullQuery}&timespan=7d&mode=artlist&maxrecords=20&format=json&sort=date`;

		logger.log('News API', `Fetching ${category} from GDELT`);

		const response = await fetchWithProxy(gdeltUrl);
		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		// Check content type before parsing as JSON
		const contentType = response.headers.get('content-type');
		if (!contentType?.includes('application/json')) {
			logger.warn('News API', `Non-JSON response for ${category}:`, contentType);
			return [];
		}

		const text = await response.text();
		let data: GdeltResponse;
		try {
			data = JSON.parse(text);
		} catch {
			logger.warn('News API', `Invalid JSON for ${category}:`, text.slice(0, 100));
			return [];
		}

		if (!data?.articles) return [];

		// Get source names for this category
		const categoryFeeds = FEEDS[category] || [];
		const defaultSource = categoryFeeds[0]?.name || 'News';

		return data.articles.map((article, index) =>
			transformGdeltArticle(article, category, article.domain || defaultSource, index)
		);
	} catch (error) {
		logger.error('News API', `Error fetching ${category}:`, error);
		return [];
	}
}

/** All news categories in fetch order */
const NEWS_CATEGORIES: NewsCategory[] = ['politics', 'tech', 'finance', 'gov', 'ai', 'intel'];

/** Create an empty news result object */
function createEmptyNewsResult(): Record<NewsCategory, NewsItem[]> {
	return { politics: [], tech: [], finance: [], gov: [], ai: [], intel: [] };
}

/**
 * Fetch all news - sequential with delays to avoid rate limiting
 */
export async function fetchAllNews(): Promise<Record<NewsCategory, NewsItem[]>> {
	const result = createEmptyNewsResult();

	for (let i = 0; i < NEWS_CATEGORIES.length; i++) {
		const category = NEWS_CATEGORIES[i];

		if (i > 0) {
			await delay(API_DELAYS.betweenCategories);
		}

		result[category] = await fetchCategoryNews(category);
	}

	return result;
}



================================================
FILE: src/lib/components/index.ts
================================================
/**
 * Components barrel file
 */

// Common components
export {
	Panel,
	NewsItem,
	MarketItem,
	HeatmapCell,
	LoadingSpinner,
	ErrorMessage,
	Badge
} from './common';

// Layout components
export { Header, Dashboard } from './layout';

// Modal components
export { Modal, SettingsModal, MonitorFormModal } from './modals';



================================================
FILE: src/lib/components/common/Badge.svelte
================================================
<script lang="ts">
	interface Props {
		text: string;
		variant?: 'default' | 'success' | 'warning' | 'danger' | 'info';
		size?: 'sm' | 'md';
	}

	let { text, variant = 'default', size = 'sm' }: Props = $props();
</script>

<span class="badge {variant} {size}">{text}</span>

<style>
	.badge {
		display: inline-flex;
		align-items: center;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.03em;
		border-radius: 3px;
	}

	.sm {
		font-size: 0.5rem;
		padding: 0.1rem 0.3rem;
	}

	.md {
		font-size: 0.6rem;
		padding: 0.15rem 0.4rem;
	}

	.default {
		background: rgba(255, 255, 255, 0.1);
		color: var(--text-secondary);
	}

	.success {
		background: rgba(68, 255, 136, 0.15);
		color: var(--success);
	}

	.warning {
		background: rgba(255, 165, 0, 0.15);
		color: #ffa500;
	}

	.danger {
		background: rgba(255, 68, 68, 0.15);
		color: var(--danger);
	}

	.info {
		background: rgba(var(--accent-rgb), 0.15);
		color: var(--accent);
	}
</style>



================================================
FILE: src/lib/components/common/ErrorMessage.svelte
================================================
<script lang="ts">
	interface Props {
		message: string;
		retry?: () => void;
	}

	let { message, retry }: Props = $props();
</script>

<div class="error-container">
	<div class="error-icon">⚠</div>
	<div class="error-message">{message}</div>
	{#if retry}
		<button class="retry-btn" onclick={retry}>Retry</button>
	{/if}
</div>

<style>
	.error-container {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 1rem;
		gap: 0.5rem;
		text-align: center;
	}

	.error-icon {
		font-size: 1.5rem;
		opacity: 0.6;
	}

	.error-message {
		font-size: 0.7rem;
		color: var(--danger);
	}

	.retry-btn {
		font-size: 0.6rem;
		padding: 0.3rem 0.6rem;
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-secondary);
		cursor: pointer;
		transition: all 0.15s ease;
	}

	.retry-btn:hover {
		background: var(--border);
		color: var(--text-primary);
	}
</style>



================================================
FILE: src/lib/components/common/HeatmapCell.svelte
================================================
<script lang="ts">
	import type { SectorPerformance } from '$lib/types';
	import { formatPercentChange } from '$lib/utils';

	interface Props {
		sector: SectorPerformance;
		showSymbol?: boolean;
	}

	let { sector, showSymbol = false }: Props = $props();

	const colorClass = $derived(getColorClass(sector.changePercent));

	function getColorClass(change: number): string {
		if (change >= 2) return 'up-3';
		if (change >= 1) return 'up-2';
		if (change >= 0.5) return 'up-1';
		if (change >= 0) return 'up-0';
		if (change >= -0.5) return 'down-0';
		if (change >= -1) return 'down-1';
		if (change >= -2) return 'down-2';
		return 'down-3';
	}

	const changeText = $derived(formatPercentChange(sector.changePercent));
</script>

<div class="heatmap-cell {colorClass}">
	<div class="sector-name">{sector.name}</div>
	{#if showSymbol}
		<div class="sector-symbol">{sector.symbol}</div>
	{/if}
	<div class="sector-change">{changeText}</div>
</div>

<style>
	.heatmap-cell {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 0.5rem;
		border-radius: 4px;
		text-align: center;
		min-height: 3rem;
		transition: transform 0.15s ease;
	}

	.heatmap-cell:hover {
		transform: scale(1.02);
	}

	.sector-name {
		font-size: 0.6rem;
		font-weight: 600;
		color: white;
		text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
	}

	.sector-symbol {
		font-size: 0.5rem;
		color: rgba(255, 255, 255, 0.7);
		margin-top: 0.1rem;
	}

	.sector-change {
		font-size: 0.55rem;
		font-weight: 500;
		color: white;
		text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
		margin-top: 0.2rem;
	}

	/* Color classes */
	.up-3 {
		background: #00aa00;
	}
	.up-2 {
		background: #22bb22;
	}
	.up-1 {
		background: #55cc55;
	}
	.up-0 {
		background: #88dd88;
	}
	.down-0 {
		background: #dd8888;
	}
	.down-1 {
		background: #cc5555;
	}
	.down-2 {
		background: #bb2222;
	}
	.down-3 {
		background: #aa0000;
	}
</style>



================================================
FILE: src/lib/components/common/index.ts
================================================
/**
 * Common components barrel file
 */

export { default as Panel } from './Panel.svelte';
export { default as NewsItem } from './NewsItem.svelte';
export { default as MarketItem } from './MarketItem.svelte';
export { default as HeatmapCell } from './HeatmapCell.svelte';
export { default as LoadingSpinner } from './LoadingSpinner.svelte';
export { default as ErrorMessage } from './ErrorMessage.svelte';
export { default as Badge } from './Badge.svelte';



================================================
FILE: src/lib/components/common/LoadingSpinner.svelte
================================================
<script lang="ts">
	interface Props {
		size?: 'sm' | 'md' | 'lg';
		message?: string;
	}

	let { size = 'md', message = '' }: Props = $props();
</script>

<div class="loading-container {size}">
	<div class="spinner"></div>
	{#if message}
		<div class="message">{message}</div>
	{/if}
</div>

<style>
	.loading-container {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 1rem;
		gap: 0.5rem;
	}

	.spinner {
		border: 2px solid var(--border);
		border-top-color: var(--accent);
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	.sm .spinner {
		width: 16px;
		height: 16px;
	}

	.md .spinner {
		width: 24px;
		height: 24px;
	}

	.lg .spinner {
		width: 32px;
		height: 32px;
		border-width: 3px;
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}

	.message {
		font-size: 0.7rem;
		color: var(--text-secondary);
	}

	.sm .message {
		font-size: 0.6rem;
	}

	.lg .message {
		font-size: 0.8rem;
	}
</style>



================================================
FILE: src/lib/components/common/MarketItem.svelte
================================================
<script lang="ts">
	import type { MarketItem as MarketItemType } from '$lib/types';
	import { formatPercentChange, getChangeClass } from '$lib/utils';

	interface Props {
		item: MarketItemType;
		showSymbol?: boolean;
		showPrice?: boolean;
		compact?: boolean;
		currencySymbol?: string;
	}

	let {
		item,
		showSymbol = true,
		showPrice = true,
		compact = false,
		currencySymbol = '$'
	}: Props = $props();

	const isDataAvailable = $derived(!isNaN(item.price) && item.price !== null);
	const changeClass = $derived(isDataAvailable ? getChangeClass(item.changePercent) : '');
	const priceDisplay = $derived(
		!isDataAvailable
			? '—'
			: item.price > 100
				? item.price.toLocaleString('en-US', { maximumFractionDigits: 0 })
				: item.price.toFixed(2)
	);
	const changeText = $derived(isDataAvailable ? formatPercentChange(item.changePercent) : '—');
</script>

<div class="market-item" class:compact>
	<div class="market-info">
		<div class="market-name">{item.name}</div>
		{#if showSymbol}
			<div class="market-symbol">{item.symbol}</div>
		{/if}
	</div>

	<div class="market-data">
		{#if showPrice}
			<div class="market-price" class:unavailable={!isDataAvailable}>
				{isDataAvailable ? `${currencySymbol}${priceDisplay}` : priceDisplay}
			</div>
		{/if}
		<div class="market-change {changeClass}" class:unavailable={!isDataAvailable}>{changeText}</div>
	</div>
</div>

<style>
	.market-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.market-item:last-child {
		border-bottom: none;
	}

	.market-item.compact {
		padding: 0.35rem 0;
	}

	.market-info {
		display: flex;
		flex-direction: column;
		gap: 0.1rem;
	}

	.market-name {
		font-size: 0.7rem;
		font-weight: 500;
		color: var(--text-primary);
	}

	.compact .market-name {
		font-size: 0.65rem;
	}

	.market-symbol {
		font-size: 0.55rem;
		color: var(--text-muted);
		text-transform: uppercase;
	}

	.market-data {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
		gap: 0.1rem;
	}

	.market-price {
		font-size: 0.7rem;
		font-weight: 500;
		color: var(--text-primary);
		font-variant-numeric: tabular-nums;
	}

	.compact .market-price {
		font-size: 0.65rem;
	}

	.market-change {
		font-size: 0.6rem;
		font-weight: 500;
		font-variant-numeric: tabular-nums;
	}

	.market-change.up {
		color: var(--success);
	}

	.market-change.down {
		color: var(--danger);
	}

	.unavailable {
		color: var(--text-muted);
		opacity: 0.5;
	}
</style>



================================================
FILE: src/lib/components/common/NewsItem.svelte
================================================
<script lang="ts">
	import type { NewsItem } from '$lib/types';
	import { timeAgo } from '$lib/utils';

	interface Props {
		item: NewsItem;
		showSource?: boolean;
		showAlert?: boolean;
		showDescription?: boolean;
		compact?: boolean;
	}

	let {
		item,
		showSource = true,
		showAlert = true,
		showDescription = false,
		compact = false
	}: Props = $props();
</script>

<div class="news-item" class:alert={showAlert && item.isAlert} class:compact>
	{#if showSource}
		<div class="item-source">
			{item.source}
			{#if showAlert && item.isAlert}
				<span class="alert-tag">ALERT</span>
			{/if}
		</div>
	{/if}

	<a class="item-title" href={item.link} target="_blank" rel="noopener noreferrer">
		{item.title}
	</a>

	{#if showDescription && item.description}
		<p class="item-description">{item.description}</p>
	{/if}

	<div class="item-meta">
		<span class="item-time">{timeAgo(item.timestamp)}</span>
		{#if item.region}
			<span class="item-region">{item.region}</span>
		{/if}
	</div>
</div>

<style>
	.news-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.news-item:last-child {
		border-bottom: none;
	}

	.news-item.compact {
		padding: 0.35rem 0;
	}

	.news-item.alert {
		background: rgba(255, 68, 68, 0.08);
		margin: 0 -0.5rem;
		padding: 0.5rem;
		border-radius: 4px;
		border: 1px solid rgba(255, 68, 68, 0.2);
		border-bottom: 1px solid rgba(255, 68, 68, 0.2);
	}

	.item-source {
		font-size: 0.55rem;
		color: var(--text-secondary);
		text-transform: uppercase;
		letter-spacing: 0.03em;
		margin-bottom: 0.2rem;
		display: flex;
		align-items: center;
		gap: 0.4rem;
	}

	.alert-tag {
		background: var(--danger);
		color: white;
		font-size: 0.5rem;
		padding: 0.1rem 0.3rem;
		border-radius: 2px;
		font-weight: 600;
	}

	.item-title {
		display: block;
		font-size: 0.7rem;
		line-height: 1.35;
		color: var(--text-primary);
		text-decoration: none;
	}

	.item-title:hover {
		color: var(--accent);
	}

	.compact .item-title {
		font-size: 0.65rem;
		line-height: 1.3;
	}

	.item-description {
		font-size: 0.6rem;
		color: var(--text-secondary);
		margin: 0.3rem 0 0;
		line-height: 1.4;
	}

	.item-meta {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		margin-top: 0.25rem;
	}

	.item-time {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.item-region {
		font-size: 0.5rem;
		color: var(--accent);
		background: rgba(var(--accent-rgb), 0.1);
		padding: 0.1rem 0.3rem;
		border-radius: 2px;
		text-transform: uppercase;
	}
</style>



================================================
FILE: src/lib/components/common/Panel.svelte
================================================
<script lang="ts">
	import type { Snippet } from 'svelte';
	import type { PanelId } from '$lib/config';

	interface Props {
		id: PanelId;
		title: string;
		count?: number | string | null;
		status?: string;
		statusClass?: string;
		loading?: boolean;
		error?: string | null;
		draggable?: boolean;
		collapsible?: boolean;
		collapsed?: boolean;
		onCollapse?: () => void;
		header?: Snippet;
		actions?: Snippet;
		children: Snippet;
	}

	let {
		id,
		title,
		count = null,
		status = '',
		statusClass = '',
		loading = false,
		error = null,
		draggable = true,
		collapsible = false,
		collapsed = false,
		onCollapse,
		header,
		actions,
		children
	}: Props = $props();

	function handleCollapse() {
		if (collapsible && onCollapse) {
			onCollapse();
		}
	}
</script>

<div class="panel" class:draggable class:collapsed data-panel-id={id}>
	<div class="panel-header">
		<div class="panel-title-row">
			<h3 class="panel-title">{title}</h3>
			{#if count !== null}
				<span class="panel-count">{count}</span>
			{/if}
			{#if status}
				<span class="panel-status {statusClass}">{status}</span>
			{/if}
			{#if loading}
				<span class="panel-loading"></span>
			{/if}
		</div>

		{#if header}
			{@render header()}
		{/if}

		<div class="panel-actions">
			{#if actions}
				{@render actions()}
			{/if}
			{#if collapsible}
				<button class="panel-collapse-btn" onclick={handleCollapse} aria-label="Toggle panel">
					{collapsed ? '▼' : '▲'}
				</button>
			{/if}
		</div>
	</div>

	<div class="panel-content" class:hidden={collapsed}>
		{#if error}
			<div class="error-msg">{error}</div>
		{:else if loading}
			<div class="loading-msg">Loading...</div>
		{:else}
			{@render children()}
		{/if}
	</div>
</div>

<style>
	.panel {
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: 4px;
		overflow: hidden;
		display: flex;
		flex-direction: column;
	}

	.panel.draggable {
		cursor: grab;
	}

	.panel.draggable:active {
		cursor: grabbing;
	}

	.panel-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 0.5rem 0.75rem;
		background: var(--surface);
		border-bottom: 1px solid var(--border);
		min-height: 2rem;
	}

	.panel-title-row {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.panel-title {
		font-size: 0.65rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		color: var(--text-secondary);
		margin: 0;
	}

	.panel-count {
		font-size: 0.65rem;
		font-weight: 500;
		color: var(--accent);
		background: rgba(var(--accent-rgb), 0.1);
		padding: 0.1rem 0.4rem;
		border-radius: 3px;
	}

	.panel-status {
		font-size: 0.6rem;
		font-weight: 600;
		padding: 0.1rem 0.4rem;
		border-radius: 3px;
		text-transform: uppercase;
	}

	.panel-status.monitoring {
		color: var(--text-secondary);
		background: rgba(255, 255, 255, 0.05);
	}

	.panel-status.elevated {
		color: #ffa500;
		background: rgba(255, 165, 0, 0.15);
	}

	.panel-status.critical {
		color: #ff4444;
		background: rgba(255, 68, 68, 0.15);
	}

	.panel-loading {
		width: 12px;
		height: 12px;
		border: 2px solid var(--border);
		border-top-color: var(--accent);
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}

	.panel-actions {
		display: flex;
		align-items: center;
		gap: 0.25rem;
	}

	.panel-collapse-btn {
		background: none;
		border: none;
		color: var(--text-secondary);
		cursor: pointer;
		padding: 0.25rem;
		font-size: 0.5rem;
		line-height: 1;
	}

	.panel-collapse-btn:hover {
		color: var(--text-primary);
	}

	.panel-content {
		flex: 1;
		overflow-y: auto;
		padding: 0.5rem;
	}

	.panel-content.hidden {
		display: none;
	}

	.error-msg {
		color: var(--danger);
		text-align: center;
		padding: 1rem;
		font-size: 0.7rem;
	}

	.loading-msg {
		color: var(--text-secondary);
		text-align: center;
		padding: 1rem;
		font-size: 0.7rem;
	}
</style>



================================================
FILE: src/lib/components/layout/Dashboard.svelte
================================================
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		children: Snippet;
	}

	let { children }: Props = $props();

	// Drag-drop state and handlers will be added in Phase 4
	// when panels are fully implemented
</script>

<main class="dashboard">
	<div class="dashboard-grid">
		{@render children()}
	</div>
</main>

<style>
	.dashboard {
		flex: 1;
		padding: 0.5rem;
		overflow-y: auto;
	}

	.dashboard-grid {
		column-count: 1;
		column-gap: 0.5rem;
		max-width: 2000px;
		margin: 0 auto;
	}

	.dashboard-grid > :global(*) {
		break-inside: avoid;
		margin-bottom: 0.5rem;
	}

	@media (min-width: 600px) {
		.dashboard-grid {
			column-count: 2;
		}
	}

	@media (min-width: 900px) {
		.dashboard-grid {
			column-count: 3;
		}
	}

	@media (min-width: 1200px) {
		.dashboard-grid {
			column-count: 4;
		}
	}

	@media (min-width: 1600px) {
		.dashboard-grid {
			column-count: 5;
		}
	}

	@media (min-width: 2000px) {
		.dashboard-grid {
			column-count: 6;
		}
	}
</style>



================================================
FILE: src/lib/components/layout/Header.svelte
================================================
<script lang="ts">
	import { isRefreshing, lastRefresh } from '$lib/stores';

	interface Props {
		onSettingsClick?: () => void;
	}

	let { onSettingsClick }: Props = $props();

	const lastRefreshText = $derived(
		$lastRefresh
			? `Last updated: ${new Date($lastRefresh).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`
			: 'Never refreshed'
	);
</script>

<header class="header">
	<div class="header-left">
		<h1 class="logo">SITUATION MONITOR</h1>
	</div>

	<div class="header-center">
		<div class="refresh-status">
			{#if $isRefreshing}
				<span class="status-text loading">Refreshing...</span>
			{:else}
				<span class="status-text">{lastRefreshText}</span>
			{/if}
		</div>
	</div>

	<div class="header-right">
		<button class="header-btn settings-btn" onclick={onSettingsClick} title="Settings">
			<span class="btn-icon">⚙</span>
			<span class="btn-label">Settings</span>
		</button>
	</div>
</header>

<style>
	.header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 0.5rem 1rem;
		background: var(--surface);
		border-bottom: 1px solid var(--border);
		position: sticky;
		top: 0;
		z-index: 100;
		gap: 1rem;
	}

	.header-left {
		display: flex;
		align-items: baseline;
		flex-shrink: 0;
	}

	.logo {
		font-size: 0.9rem;
		font-weight: 700;
		letter-spacing: 0.1em;
		color: var(--text-primary);
		margin: 0;
		display: flex;
		align-items: baseline;
		gap: 0.5rem;
	}

	.header-center {
		display: flex;
		align-items: center;
		flex: 1;
		justify-content: center;
		min-width: 0;
	}

	.refresh-status {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.status-text {
		font-size: 0.6rem;
		color: var(--text-muted);
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.status-text.loading {
		color: var(--accent);
	}

	.header-right {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		flex-shrink: 0;
	}

	.header-btn {
		display: flex;
		align-items: center;
		gap: 0.3rem;
		min-height: 2.75rem;
		padding: 0.4rem 0.75rem;
		background: transparent;
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-secondary);
		cursor: pointer;
		transition: all 0.15s ease;
		font-size: 0.65rem;
	}

	.header-btn:hover {
		background: var(--border);
		color: var(--text-primary);
	}

	.btn-icon {
		font-size: 0.8rem;
	}

	.btn-label {
		display: none;
	}

	@media (min-width: 768px) {
		.btn-label {
			display: inline;
		}
	}
</style>



================================================
FILE: src/lib/components/layout/index.ts
================================================
/**
 * Layout components barrel file
 */

export { default as Header } from './Header.svelte';
export { default as Dashboard } from './Dashboard.svelte';



================================================
FILE: src/lib/components/modals/index.ts
================================================
/**
 * Modal components barrel file
 */

export { default as Modal } from './Modal.svelte';
export { default as SettingsModal } from './SettingsModal.svelte';
export { default as MonitorFormModal } from './MonitorFormModal.svelte';
export { default as OnboardingModal } from './OnboardingModal.svelte';



================================================
FILE: src/lib/components/modals/Modal.svelte
================================================
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		open: boolean;
		title: string;
		onClose: () => void;
		header?: Snippet;
		footer?: Snippet;
		children: Snippet;
	}

	let { open = false, title, onClose, header, footer, children }: Props = $props();

	function handleBackdropClick(e: MouseEvent) {
		if (e.target === e.currentTarget) {
			onClose();
		}
	}

	function handleKeydown(e: KeyboardEvent) {
		if (e.key === 'Escape') {
			onClose();
		}
	}
</script>

<svelte:window onkeydown={handleKeydown} />

{#if open}
	<!-- svelte-ignore a11y_click_events_have_key_events -->
	<!-- svelte-ignore a11y_no_static_element_interactions -->
	<div class="modal-backdrop" onclick={handleBackdropClick}>
		<div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
			<div class="modal-header">
				<h2 id="modal-title" class="modal-title">{title}</h2>
				{#if header}
					{@render header()}
				{/if}
				<button class="modal-close" onclick={onClose} aria-label="Close">×</button>
			</div>

			<div class="modal-content">
				{@render children()}
			</div>

			{#if footer}
				<div class="modal-footer">
					{@render footer()}
				</div>
			{/if}
		</div>
	</div>
{/if}

<style>
	.modal-backdrop {
		position: fixed;
		inset: 0;
		background: rgba(0, 0, 0, 0.7);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 1000;
		padding: 1rem;
	}

	.modal {
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: 8px;
		width: 100%;
		max-width: 500px;
		max-height: 90vh;
		display: flex;
		flex-direction: column;
		overflow: hidden;
	}

	.modal-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 1rem;
		border-bottom: 1px solid var(--border);
	}

	.modal-title {
		font-size: 0.9rem;
		font-weight: 600;
		margin: 0;
		color: var(--text-primary);
	}

	.modal-close {
		background: none;
		border: none;
		color: var(--text-secondary);
		font-size: 1.5rem;
		cursor: pointer;
		padding: 0;
		line-height: 1;
		width: 2rem;
		height: 2rem;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 4px;
	}

	.modal-close:hover {
		background: var(--border);
		color: var(--text-primary);
	}

	.modal-content {
		flex: 1;
		overflow-y: auto;
		padding: 1rem;
	}

	.modal-footer {
		padding: 1rem;
		border-top: 1px solid var(--border);
		display: flex;
		justify-content: flex-end;
		gap: 0.5rem;
	}
</style>



================================================
FILE: src/lib/components/modals/MonitorFormModal.svelte
================================================
<script lang="ts">
	import Modal from './Modal.svelte';
	import { monitors } from '$lib/stores';
	import type { CustomMonitor } from '$lib/types';

	interface Props {
		open: boolean;
		onClose: () => void;
		editMonitor?: CustomMonitor | null;
	}

	let { open = false, onClose, editMonitor = null }: Props = $props();

	let name = $state('');
	let keywords = $state('');
	let enabled = $state(true);
	let error = $state('');

	// Reset form when modal opens
	$effect(() => {
		if (open) {
			if (editMonitor) {
				name = editMonitor.name;
				keywords = editMonitor.keywords.join(', ');
				enabled = editMonitor.enabled;
			} else {
				name = '';
				keywords = '';
				enabled = true;
			}
			error = '';
		}
	});

	function handleSubmit(e: Event) {
		e.preventDefault();

		const trimmedName = name.trim();
		const keywordList = keywords
			.split(',')
			.map((k) => k.trim().toLowerCase())
			.filter((k) => k.length > 0);

		if (!trimmedName) {
			error = 'Name is required';
			return;
		}

		if (keywordList.length === 0) {
			error = 'At least one keyword is required';
			return;
		}

		if (editMonitor) {
			// Update existing monitor
			monitors.updateMonitor(editMonitor.id, {
				name: trimmedName,
				keywords: keywordList,
				enabled
			});
		} else {
			// Create new monitor
			const result = monitors.addMonitor({
				name: trimmedName,
				keywords: keywordList,
				enabled
			});

			if (!result) {
				error = 'Maximum number of monitors reached (20)';
				return;
			}
		}

		onClose();
	}

	function handleDelete() {
		if (editMonitor) {
			monitors.deleteMonitor(editMonitor.id);
			onClose();
		}
	}
</script>

<Modal {open} title={editMonitor ? 'Edit Monitor' : 'Create Monitor'} {onClose}>
	<form class="monitor-form" onsubmit={handleSubmit}>
		{#if error}
			<div class="form-error">{error}</div>
		{/if}

		<div class="form-group">
			<label for="monitor-name">Name</label>
			<input
				id="monitor-name"
				type="text"
				bind:value={name}
				placeholder="e.g., Ukraine Crisis"
				maxlength="50"
			/>
		</div>

		<div class="form-group">
			<label for="monitor-keywords">Keywords (comma separated)</label>
			<input
				id="monitor-keywords"
				type="text"
				bind:value={keywords}
				placeholder="e.g., ukraine, zelensky, kyiv"
			/>
			<p class="form-hint">News matching any of these keywords will appear in your monitor</p>
		</div>

		<div class="form-group">
			<label class="checkbox-label">
				<input type="checkbox" bind:checked={enabled} />
				<span>Enabled</span>
			</label>
		</div>

		<div class="form-actions">
			{#if editMonitor}
				<button type="button" class="delete-btn" onclick={handleDelete}> Delete </button>
			{/if}
			<button type="button" class="cancel-btn" onclick={onClose}> Cancel </button>
			<button type="submit" class="submit-btn">
				{editMonitor ? 'Save Changes' : 'Create Monitor'}
			</button>
		</div>
	</form>
</Modal>

<style>
	.monitor-form {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.form-error {
		background: rgba(255, 68, 68, 0.1);
		border: 1px solid rgba(255, 68, 68, 0.3);
		border-radius: 4px;
		padding: 0.5rem;
		color: var(--danger);
		font-size: 0.7rem;
	}

	.form-group {
		display: flex;
		flex-direction: column;
		gap: 0.3rem;
	}

	.form-group label {
		font-size: 0.7rem;
		font-weight: 500;
		color: var(--text-secondary);
	}

	.form-group input[type='text'] {
		padding: 0.5rem;
		background: var(--bg);
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-primary);
		font-size: 0.75rem;
	}

	.form-group input[type='text']:focus {
		outline: none;
		border-color: var(--accent);
	}

	.form-hint {
		font-size: 0.6rem;
		color: var(--text-muted);
		margin: 0;
	}

	.checkbox-label {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		font-size: 0.7rem;
		color: var(--text-primary);
	}

	.checkbox-label input {
		accent-color: var(--accent);
	}

	.form-actions {
		display: flex;
		justify-content: flex-end;
		gap: 0.5rem;
		margin-top: 0.5rem;
	}

	.cancel-btn,
	.submit-btn,
	.delete-btn {
		padding: 0.5rem 1rem;
		border-radius: 4px;
		font-size: 0.7rem;
		cursor: pointer;
		transition: all 0.15s ease;
	}

	.cancel-btn {
		background: transparent;
		border: 1px solid var(--border);
		color: var(--text-secondary);
	}

	.cancel-btn:hover {
		background: var(--border);
		color: var(--text-primary);
	}

	.submit-btn {
		background: var(--accent);
		border: 1px solid var(--accent);
		color: white;
	}

	.submit-btn:hover {
		filter: brightness(1.1);
	}

	.delete-btn {
		background: transparent;
		border: 1px solid rgba(255, 68, 68, 0.3);
		color: var(--danger);
		margin-right: auto;
	}

	.delete-btn:hover {
		background: rgba(255, 68, 68, 0.1);
	}
</style>



================================================
FILE: src/lib/components/modals/OnboardingModal.svelte
================================================
<script lang="ts">
	import { PRESETS, PRESET_ORDER } from '$lib/config';

	interface Props {
		open: boolean;
		onSelectPreset: (presetId: string) => void;
		onSkip?: () => void;
	}

	let { open, onSelectPreset, onSkip }: Props = $props();

	function handleSelectPreset(presetId: string) {
		onSelectPreset(presetId);
	}

	function handleSkip() {
		// Select the 'everything' preset (show all panels) when skipping
		onSelectPreset('everything');
	}

	function handleClose() {
		if (onSkip) {
			onSkip();
		} else {
			handleSkip();
		}
	}
</script>

{#if open}
	<div class="modal-overlay">
		<div class="modal onboarding-modal">
			<div class="modal-header">
				<button class="close-btn" onclick={handleClose} aria-label="Skip onboarding">
					&times;
				</button>
				<h2>Welcome to Situation Monitor</h2>
				<p class="subtitle">Choose a dashboard configuration to get started</p>
			</div>

			<div class="preset-grid">
				{#each PRESET_ORDER as presetId}
					{@const preset = PRESETS[presetId]}
					<button class="preset-card" onclick={() => handleSelectPreset(presetId)}>
						<div class="preset-icon">{preset.icon}</div>
						<div class="preset-name">{preset.name}</div>
						<div class="preset-description">{preset.description}</div>
						<div class="preset-panel-count">{preset.panels.length} panels</div>
					</button>
				{/each}
			</div>

			<div class="modal-footer">
				<p class="hint">You can change this later in Settings</p>
			</div>
		</div>
	</div>
{/if}

<style>
	.modal-overlay {
		position: fixed;
		inset: 0;
		background: rgba(0, 0, 0, 0.85);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 2000;
		padding: 1rem;
	}

	.onboarding-modal {
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: 8px;
		max-width: 900px;
		width: 100%;
		max-height: 90vh;
		overflow-y: auto;
	}

	.modal-header {
		position: relative;
		padding: 1.5rem;
		text-align: center;
		border-bottom: 1px solid var(--border);
	}

	.close-btn {
		position: absolute;
		top: 0.75rem;
		right: 0.75rem;
		width: 2rem;
		height: 2rem;
		display: flex;
		align-items: center;
		justify-content: center;
		background: transparent;
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-secondary);
		font-size: 1.25rem;
		cursor: pointer;
		transition: all 0.2s ease;
	}

	.close-btn:hover {
		background: var(--bg);
		color: var(--text-primary);
		border-color: var(--text-secondary);
	}

	.modal-header h2 {
		color: var(--text-primary);
		font-size: 1.25rem;
		font-weight: 600;
		margin: 0 0 0.5rem;
	}

	.subtitle {
		color: var(--text-secondary);
		font-size: 0.8rem;
		margin: 0;
	}

	.preset-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
		gap: 1rem;
		padding: 1.5rem;
	}

	.preset-card {
		background: var(--bg);
		border: 1px solid var(--border);
		border-radius: 6px;
		padding: 1.25rem;
		cursor: pointer;
		transition: all 0.2s ease;
		text-align: left;
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.preset-card:hover {
		border-color: var(--accent);
		background: rgba(0, 255, 136, 0.05);
	}

	.preset-icon {
		font-size: 2rem;
		margin-bottom: 0.25rem;
	}

	.preset-name {
		font-size: 0.9rem;
		font-weight: 600;
		color: var(--text-primary);
	}

	.preset-description {
		font-size: 0.7rem;
		color: var(--text-secondary);
		line-height: 1.4;
		flex: 1;
	}

	.preset-panel-count {
		font-size: 0.65rem;
		color: var(--accent);
		font-weight: 500;
	}

	.modal-footer {
		padding: 1rem 1.5rem;
		border-top: 1px solid var(--border);
		text-align: center;
	}

	.hint {
		color: var(--text-muted);
		font-size: 0.7rem;
		margin: 0;
	}

	@media (max-width: 768px) {
		.preset-grid {
			grid-template-columns: 1fr;
		}

		.modal-header h2 {
			font-size: 1.1rem;
		}
	}
</style>



================================================
FILE: src/lib/components/modals/SettingsModal.svelte
================================================
<script lang="ts">
	import Modal from './Modal.svelte';
	import { settings } from '$lib/stores';
	import { PANELS, type PanelId } from '$lib/config';

	interface Props {
		open: boolean;
		onClose: () => void;
		onReconfigure?: () => void;
	}

	let { open = false, onClose, onReconfigure }: Props = $props();

	function handleTogglePanel(panelId: PanelId) {
		settings.togglePanel(panelId);
	}

	function handleResetPanels() {
		settings.reset();
	}
</script>

<Modal {open} title="Settings" {onClose}>
	<div class="settings-sections">
		<section class="settings-section">
			<h3 class="section-title">Enabled Panels</h3>
			<p class="section-desc">Toggle panels on/off to customize your dashboard</p>

			<div class="panels-grid">
				{#each Object.entries(PANELS) as [id, config]}
					{@const panelId = id as PanelId}
					{@const isEnabled = $settings.enabled[panelId]}
					<label class="panel-toggle" class:enabled={isEnabled}>
						<input
							type="checkbox"
							checked={isEnabled}
							onchange={() => handleTogglePanel(panelId)}
						/>
						<span class="panel-name">{config.name}</span>
						<span class="panel-priority">P{config.priority}</span>
					</label>
				{/each}
			</div>
		</section>

		<section class="settings-section">
			<h3 class="section-title">Dashboard</h3>
			{#if onReconfigure}
				<button class="reconfigure-btn" onclick={onReconfigure}> Reconfigure Dashboard </button>
				<p class="btn-hint">Choose a preset profile for your panels</p>
			{/if}
			<button class="reset-btn" onclick={handleResetPanels}> Reset All Settings </button>
		</section>
	</div>
</Modal>

<style>
	.settings-sections {
		display: flex;
		flex-direction: column;
		gap: 1.5rem;
	}

	.settings-section {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.section-title {
		font-size: 0.75rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		color: var(--text-secondary);
		margin: 0;
	}

	.section-desc {
		font-size: 0.65rem;
		color: var(--text-muted);
		margin: 0;
	}

	.panels-grid {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
	}

	.panel-toggle {
		display: flex;
		align-items: center;
		gap: 0.4rem;
		padding: 0.4rem 0.6rem;
		background: rgba(255, 255, 255, 0.02);
		border: 1px solid var(--border);
		border-radius: 4px;
		cursor: pointer;
		transition: all 0.15s ease;
	}

	.panel-toggle:hover {
		background: rgba(255, 255, 255, 0.05);
	}

	.panel-toggle.enabled {
		border-color: var(--accent);
		background: rgba(var(--accent-rgb), 0.1);
	}

	.panel-toggle input {
		accent-color: var(--accent);
	}

	.panel-name {
		flex: 1;
		font-size: 0.65rem;
		color: var(--text-primary);
	}

	.panel-priority {
		font-size: 0.5rem;
		color: var(--text-muted);
		background: rgba(255, 255, 255, 0.05);
		padding: 0.1rem 0.25rem;
		border-radius: 2px;
	}

	.reconfigure-btn {
		padding: 0.5rem 1rem;
		background: rgba(0, 255, 136, 0.1);
		border: 1px solid rgba(0, 255, 136, 0.3);
		border-radius: 4px;
		color: var(--accent);
		font-size: 0.7rem;
		cursor: pointer;
		transition: all 0.15s ease;
		margin-bottom: 0.25rem;
	}

	.reconfigure-btn:hover {
		background: rgba(0, 255, 136, 0.2);
	}

	.btn-hint {
		font-size: 0.6rem;
		color: var(--text-muted);
		margin: 0 0 0.75rem;
	}

	.reset-btn {
		padding: 0.5rem 1rem;
		background: rgba(255, 68, 68, 0.1);
		border: 1px solid rgba(255, 68, 68, 0.3);
		border-radius: 4px;
		color: var(--danger);
		font-size: 0.7rem;
		cursor: pointer;
		transition: all 0.15s ease;
	}

	.reset-btn:hover {
		background: rgba(255, 68, 68, 0.2);
	}
</style>



================================================
FILE: src/lib/components/panels/CommoditiesPanel.svelte
================================================
<script lang="ts">
	import { Panel, MarketItem } from '$lib/components/common';
	import { commodities, vix } from '$lib/stores';

	const items = $derived($commodities.items);
	const loading = $derived($commodities.loading);
	const error = $derived($commodities.error);

	// VIX status for panel header
	const vixStatus = $derived(getVixStatus($vix?.price));
	const vixClass = $derived(getVixClass($vix?.price));

	function getVixStatus(level: number | undefined): string {
		if (level === undefined) return '';
		if (level >= 30) return 'HIGH FEAR';
		if (level >= 20) return 'ELEVATED';
		return 'LOW';
	}

	function getVixClass(level: number | undefined): string {
		if (level === undefined) return '';
		if (level >= 30) return 'critical';
		if (level >= 20) return 'elevated';
		return 'monitoring';
	}
</script>

<Panel
	id="commodities"
	title="Commodities / VIX"
	status={vixStatus}
	statusClass={vixClass}
	{loading}
	{error}
>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No commodity data available</div>
	{:else}
		<div class="commodities-list">
			{#each items as item (item.symbol)}
				<MarketItem {item} currencySymbol={item.symbol === '^VIX' ? '' : '$'} />
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.commodities-list {
		display: flex;
		flex-direction: column;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/ContractsPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';

	interface Contract {
		agency: string;
		description: string;
		vendor: string;
		amount: number;
	}

	interface Props {
		contracts?: Contract[];
		loading?: boolean;
		error?: string | null;
	}

	let { contracts = [], loading = false, error = null }: Props = $props();

	const count = $derived(contracts.length);

	function formatValue(v: number): string {
		if (v >= 1e9) return '$' + (v / 1e9).toFixed(1) + 'B';
		if (v >= 1e6) return '$' + (v / 1e6).toFixed(1) + 'M';
		if (v >= 1e3) return '$' + (v / 1e3).toFixed(0) + 'K';
		return '$' + v.toFixed(0);
	}
</script>

<Panel id="contracts" title="Gov Contracts" {count} {loading} {error}>
	{#if contracts.length === 0 && !loading && !error}
		<div class="empty-state">No contracts available</div>
	{:else}
		<div class="contracts-list">
			{#each contracts as contract, i (contract.vendor + i)}
				<div class="contract-item">
					<div class="contract-agency">{contract.agency}</div>
					<div class="contract-desc">
						{contract.description.length > 100
							? contract.description.substring(0, 100) + '...'
							: contract.description}
					</div>
					<div class="contract-meta">
						<span class="contract-vendor">{contract.vendor}</span>
						<span class="contract-value">{formatValue(contract.amount)}</span>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.contracts-list {
		display: flex;
		flex-direction: column;
	}

	.contract-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.contract-item:last-child {
		border-bottom: none;
	}

	.contract-agency {
		font-size: 0.55rem;
		font-weight: 600;
		color: var(--accent);
		text-transform: uppercase;
		letter-spacing: 0.03em;
		margin-bottom: 0.2rem;
	}

	.contract-desc {
		font-size: 0.65rem;
		color: var(--text-primary);
		line-height: 1.3;
		margin-bottom: 0.3rem;
	}

	.contract-meta {
		display: flex;
		justify-content: space-between;
		align-items: center;
	}

	.contract-vendor {
		font-size: 0.55rem;
		color: var(--text-secondary);
	}

	.contract-value {
		font-size: 0.65rem;
		font-weight: 600;
		color: var(--success);
		font-variant-numeric: tabular-nums;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/CorrelationPanel.svelte
================================================
<script lang="ts">
	import { Panel, Badge } from '$lib/components/common';
	import { analyzeCorrelations } from '$lib/analysis/correlation';
	import type { NewsItem } from '$lib/types';

	interface Props {
		news?: NewsItem[];
		loading?: boolean;
		error?: string | null;
	}

	let { news = [], loading = false, error = null }: Props = $props();

	const analysis = $derived(analyzeCorrelations(news));

	function getLevelVariant(level: string): 'default' | 'warning' | 'danger' | 'success' | 'info' {
		switch (level) {
			case 'high':
				return 'danger';
			case 'elevated':
				return 'warning';
			case 'surging':
				return 'danger';
			case 'rising':
				return 'warning';
			default:
				return 'default';
		}
	}

	function getMomentumClass(momentum: string): string {
		switch (momentum) {
			case 'surging':
				return 'signal-strong';
			case 'rising':
				return 'signal-medium';
			default:
				return 'signal-weak';
		}
	}

	function getDirectionArrow(delta: number): string {
		if (delta > 0) return '↑';
		if (delta < 0) return '↓';
		return '→';
	}
</script>

<Panel id="correlation" title="Pattern Analysis" {loading} {error}>
	{#if news.length === 0 && !loading && !error}
		<div class="empty-state">Insufficient data for analysis</div>
	{:else if analysis}
		<div class="correlation-content">
			{#if analysis.emergingPatterns.length > 0}
				<div class="section">
					<div class="section-title">Emerging Patterns</div>
					{#each analysis.emergingPatterns.slice(0, 3) as pattern}
						<div class="pattern-item">
							<div class="pattern-header">
								<span class="pattern-topic">{pattern.name}</span>
								<Badge
									text={pattern.level.toUpperCase()}
									variant={getLevelVariant(pattern.level)}
								/>
							</div>
							<div class="pattern-sources">
								{pattern.sources.slice(0, 3).join(' · ')} ({pattern.count} items)
							</div>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.momentumSignals.length > 0}
				<div class="section">
					<div class="section-title">Momentum Signals</div>
					{#each analysis.momentumSignals.slice(0, 3) as signal}
						<div class="signal-item {getMomentumClass(signal.momentum)}">
							<span class="signal-topic">{signal.name}</span>
							<span
								class="signal-direction"
								class:up={signal.delta > 0}
								class:down={signal.delta < 0}
							>
								{getDirectionArrow(signal.delta)}
								{signal.current}
							</span>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.crossSourceCorrelations.length > 0}
				<div class="section">
					<div class="section-title">Cross-Source Links</div>
					{#each analysis.crossSourceCorrelations.slice(0, 3) as corr}
						<div class="correlation-item">
							<div class="correlation-sources">
								{corr.sources.slice(0, 2).join(' ↔ ')}
							</div>
							<div class="correlation-topic">{corr.name} ({corr.sourceCount} sources)</div>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.predictiveSignals.length > 0}
				<div class="section">
					<div class="section-title">Predictive Signals</div>
					{#each analysis.predictiveSignals.slice(0, 2) as signal}
						<div class="predictive-item">
							<div class="predictive-pattern">{signal.prediction}</div>
							<div class="predictive-confidence">
								Confidence: {Math.round(signal.confidence * 100)}%
							</div>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.emergingPatterns.length === 0 && analysis.momentumSignals.length === 0}
				<div class="empty-state">No significant patterns detected</div>
			{/if}
		</div>
	{:else}
		<div class="empty-state">No significant patterns detected</div>
	{/if}
</Panel>

<style>
	.correlation-content {
		display: flex;
		flex-direction: column;
		gap: 0.75rem;
	}

	.section {
		padding-bottom: 0.5rem;
		border-bottom: 1px solid var(--border);
	}

	.section:last-child {
		border-bottom: none;
		padding-bottom: 0;
	}

	.section-title {
		font-size: 0.6rem;
		font-weight: 600;
		color: var(--accent);
		text-transform: uppercase;
		letter-spacing: 0.05em;
		margin-bottom: 0.4rem;
	}

	.pattern-item {
		padding: 0.3rem 0;
	}

	.pattern-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.2rem;
	}

	.pattern-topic {
		font-size: 0.65rem;
		font-weight: 500;
		color: var(--text-primary);
	}

	.pattern-sources {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.signal-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.25rem 0.4rem;
		margin: 0.2rem 0;
		border-radius: 4px;
		background: rgba(255, 255, 255, 0.02);
	}

	.signal-item.signal-strong {
		background: rgba(255, 165, 0, 0.1);
		border-left: 2px solid var(--warning);
	}

	.signal-item.signal-medium {
		background: rgba(68, 255, 136, 0.05);
		border-left: 2px solid var(--success);
	}

	.signal-topic {
		font-size: 0.6rem;
		color: var(--text-primary);
	}

	.signal-direction {
		font-size: 0.6rem;
		font-weight: 600;
	}

	.signal-direction.up {
		color: var(--success);
	}

	.signal-direction.down {
		color: var(--danger);
	}

	.correlation-item {
		padding: 0.25rem 0;
	}

	.correlation-sources {
		font-size: 0.6rem;
		color: var(--text-secondary);
	}

	.correlation-topic {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.predictive-item {
		padding: 0.3rem 0;
	}

	.predictive-pattern {
		font-size: 0.6rem;
		color: var(--text-primary);
	}

	.predictive-confidence {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/CryptoPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';
	import { crypto } from '$lib/stores';
	import { formatCurrency, formatPercentChange, getChangeClass } from '$lib/utils';

	const items = $derived($crypto.items);
	const loading = $derived($crypto.loading);
	const error = $derived($crypto.error);
	const count = $derived(items.length);
</script>

<Panel id="whales" title="Crypto" {count} {loading} {error}>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No crypto data available</div>
	{:else}
		<div class="crypto-list">
			{#each items as coin (coin.id)}
				{@const changeClass = getChangeClass(coin.price_change_percentage_24h)}
				<div class="crypto-item">
					<div class="crypto-info">
						<div class="crypto-name">{coin.name}</div>
						<div class="crypto-symbol">{coin.symbol.toUpperCase()}</div>
					</div>
					<div class="crypto-data">
						<div class="crypto-price">{formatCurrency(coin.current_price)}</div>
						<div class="crypto-change {changeClass}">
							{formatPercentChange(coin.price_change_percentage_24h)}
						</div>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.crypto-list {
		display: flex;
		flex-direction: column;
	}

	.crypto-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.crypto-item:last-child {
		border-bottom: none;
	}

	.crypto-info {
		display: flex;
		flex-direction: column;
		gap: 0.1rem;
	}

	.crypto-name {
		font-size: 0.7rem;
		font-weight: 500;
		color: var(--text-primary);
	}

	.crypto-symbol {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.crypto-data {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
		gap: 0.1rem;
	}

	.crypto-price {
		font-size: 0.7rem;
		font-weight: 500;
		color: var(--text-primary);
		font-variant-numeric: tabular-nums;
	}

	.crypto-change {
		font-size: 0.6rem;
		font-weight: 500;
		font-variant-numeric: tabular-nums;
	}

	.crypto-change.up {
		color: var(--success);
	}

	.crypto-change.down {
		color: var(--danger);
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/FedPanel.svelte
================================================
<script lang="ts">
	import { Panel, Badge } from '$lib/components/common';
	import { getRelativeTime } from '$lib/utils';
	import { fedNews, fedIndicators, fedVideos } from '$lib/stores';
	import { isFredConfigured } from '$lib/api/fred';
	import type { EconomicIndicator } from '$lib/api/fred';

	// Store state
	const newsState = $derived($fedNews);
	const indicatorsState = $derived($fedIndicators);
	const videoItems = $derived($fedVideos);

	const loading = $derived(newsState.loading || indicatorsState.loading);
	const error = $derived(newsState.error || indicatorsState.error);
	const hasApiKey = isFredConfigured();

	const indicatorList = $derived(
		indicatorsState.data
			? [
					indicatorsState.data.fedFundsRate,
					indicatorsState.data.cpi,
					indicatorsState.data.treasury10Y
				]
			: []
	);

	type BadgeVariant = 'default' | 'success' | 'warning' | 'danger' | 'info';

	const TYPE_VARIANTS: Record<string, BadgeVariant> = {
		powell: 'warning',
		monetary: 'danger',
		speech: 'info',
		testimony: 'success',
		announcement: 'default'
	};

	function formatValue(indicator: EconomicIndicator): string {
		if (indicator.value === null) return '--';
		return `${indicator.value.toFixed(2)}${indicator.unit}`;
	}

	function formatChange(indicator: EconomicIndicator): string {
		if (indicator.change === null) return '';
		const sign = indicator.change >= 0 ? '+' : '';
		return `${sign}${indicator.change.toFixed(2)}`;
	}

	function getChangeClass(change: number | null): string {
		if (change === null) return '';
		if (change > 0) return 'up';
		if (change < 0) return 'down';
		return '';
	}

	function getTypeVariant(type: string): BadgeVariant {
		return TYPE_VARIANTS[type] || 'default';
	}
</script>

<Panel id="fed" title="Federal Reserve" count={newsState.items.length} {loading} {error}>
	<!-- Economic Indicators -->
	{#if hasApiKey && indicatorList.length > 0}
		<div class="indicators-section">
			<div class="indicator-cards">
				{#each indicatorList as indicator (indicator.seriesId)}
					<div class="indicator-card">
						<div class="indicator-label">{indicator.name}</div>
						<div class="indicator-value">{formatValue(indicator)}</div>
						<div class="indicator-change {getChangeClass(indicator.change)}">
							{formatChange(indicator)}
						</div>
					</div>
				{/each}
			</div>
		</div>
	{:else if !hasApiKey && !loading}
		<div class="no-api-key">
			<span class="no-api-key-text">Add VITE_FRED_API_KEY for economic indicators</span>
		</div>
	{/if}

	<!-- Video/Speeches Section -->
	{#if videoItems.length > 0}
		<div class="video-section">
			<div class="section-header">
				<span class="section-title">Speeches & Video</span>
				<a
					href="https://www.federalreserve.gov/live-broadcast.htm"
					target="_blank"
					rel="noopener noreferrer"
					class="live-link"
				>
					Live Broadcast
				</a>
			</div>
			<div class="video-list">
				{#each videoItems.slice(0, 3) as item (item.id)}
					<a href={item.link} target="_blank" rel="noopener noreferrer" class="video-item">
						<div class="video-icon">&#9658;</div>
						<div class="video-content">
							<div class="video-title">{item.title}</div>
							<div class="video-meta">
								{#if item.isPowellRelated}
									<Badge text="POWELL" variant="warning" />
								{/if}
								<span>{getRelativeTime(item.pubDate)}</span>
							</div>
						</div>
					</a>
				{/each}
			</div>
		</div>
	{/if}

	<!-- News Feed -->
	<div class="news-section">
		{#if newsState.items.length === 0 && !loading && !error}
			<div class="empty-state">No Fed news available</div>
		{:else}
			<div class="fed-news-list">
				{#each newsState.items as item (item.id)}
					<div class="fed-news-item" class:powell={item.isPowellRelated}>
						<div class="fed-news-header">
							<div class="fed-news-badges">
								<Badge text={item.typeLabel} variant={getTypeVariant(item.type)} />
								{#if item.isPowellRelated && item.type !== 'powell'}
									<Badge text="POWELL" variant="warning" />
								{/if}
								{#if item.hasVideo}
									<Badge text="VIDEO" variant="info" />
								{/if}
							</div>
							{#if item.pubDate}
								<span class="fed-news-time">{getRelativeTime(item.pubDate)}</span>
							{/if}
						</div>
						<a href={item.link} target="_blank" rel="noopener noreferrer" class="fed-news-title">
							{item.title}
						</a>
						{#if item.description}
							<div class="fed-news-desc">
								{item.description.slice(0, 120)}{item.description.length > 120 ? '...' : ''}
							</div>
						{/if}
					</div>
				{/each}
			</div>
		{/if}
	</div>
</Panel>

<style>
	/* Indicators Section */
	.indicators-section {
		padding-bottom: 0.5rem;
		margin-bottom: 0.5rem;
		border-bottom: 1px solid var(--border);
	}

	.indicator-cards {
		display: grid;
		grid-template-columns: repeat(3, 1fr);
		gap: 0.5rem;
	}

	.indicator-card {
		text-align: center;
		padding: 0.4rem;
		background: var(--bg-secondary);
		border-radius: 4px;
	}

	.indicator-label {
		font-size: 0.5rem;
		color: var(--text-muted);
		text-transform: uppercase;
		letter-spacing: 0.03em;
		margin-bottom: 0.2rem;
	}

	.indicator-value {
		font-size: 0.85rem;
		font-weight: 700;
		color: var(--text-primary);
		font-variant-numeric: tabular-nums;
	}

	.indicator-change {
		font-size: 0.55rem;
		font-weight: 500;
	}

	.indicator-change.up {
		color: var(--success);
	}

	.indicator-change.down {
		color: var(--danger);
	}

	.no-api-key {
		padding: 0.5rem;
		margin-bottom: 0.5rem;
		background: var(--bg-secondary);
		border-radius: 4px;
		text-align: center;
	}

	.no-api-key-text {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	/* Video Section */
	.video-section {
		padding-bottom: 0.5rem;
		margin-bottom: 0.5rem;
		border-bottom: 1px solid var(--border);
	}

	.section-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.4rem;
	}

	.section-title {
		font-size: 0.55rem;
		font-weight: 600;
		color: var(--text-secondary);
		text-transform: uppercase;
		letter-spacing: 0.03em;
	}

	.live-link {
		font-size: 0.5rem;
		color: var(--danger);
		text-decoration: none;
		display: flex;
		align-items: center;
		gap: 0.25rem;
	}

	.live-link::before {
		content: '';
		width: 6px;
		height: 6px;
		background: var(--danger);
		border-radius: 50%;
		animation: pulse 1.5s ease-in-out infinite;
	}

	.live-link:hover {
		text-decoration: underline;
	}

	@keyframes pulse {
		0%,
		100% {
			opacity: 1;
		}
		50% {
			opacity: 0.4;
		}
	}

	.video-list {
		display: flex;
		flex-direction: column;
		gap: 0.4rem;
	}

	.video-item {
		display: flex;
		gap: 0.5rem;
		padding: 0.4rem;
		background: var(--bg-secondary);
		border-radius: 4px;
		text-decoration: none;
		transition: background 0.15s;
	}

	.video-item:hover {
		background: var(--bg-tertiary, var(--border));
	}

	.video-icon {
		color: var(--danger);
		font-size: 0.7rem;
		flex-shrink: 0;
		width: 1.2rem;
		height: 1.2rem;
		display: flex;
		align-items: center;
		justify-content: center;
		background: rgba(239, 68, 68, 0.1);
		border-radius: 4px;
	}

	.video-content {
		flex: 1;
		min-width: 0;
	}

	.video-title {
		font-size: 0.6rem;
		color: var(--text-primary);
		line-height: 1.3;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}

	.video-meta {
		display: flex;
		align-items: center;
		gap: 0.4rem;
		margin-top: 0.2rem;
		font-size: 0.5rem;
		color: var(--text-muted);
	}

	/* News Section */
	.news-section {
		flex: 1;
	}

	.fed-news-list {
		display: flex;
		flex-direction: column;
	}

	.fed-news-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.fed-news-item:last-child {
		border-bottom: none;
	}

	.fed-news-item.powell {
		background: rgba(255, 165, 0, 0.08);
		margin: 0 -0.5rem;
		padding: 0.5rem;
		border-radius: 4px;
		border: 1px solid rgba(255, 165, 0, 0.2);
	}

	.fed-news-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.3rem;
		gap: 0.5rem;
	}

	.fed-news-badges {
		display: flex;
		gap: 0.25rem;
		flex-wrap: wrap;
	}

	.fed-news-time {
		font-size: 0.5rem;
		color: var(--text-muted);
		flex-shrink: 0;
	}

	.fed-news-title {
		display: block;
		font-size: 0.65rem;
		color: var(--text-primary);
		text-decoration: none;
		line-height: 1.35;
	}

	.fed-news-title:hover {
		color: var(--accent);
	}

	.fed-news-desc {
		margin-top: 0.25rem;
		font-size: 0.55rem;
		color: var(--text-muted);
		line-height: 1.4;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/HeatmapPanel.svelte
================================================
<script lang="ts">
	import { Panel, HeatmapCell } from '$lib/components/common';
	import { sectors } from '$lib/stores';

	const items = $derived($sectors.items);
	const loading = $derived($sectors.loading);
	const error = $derived($sectors.error);
</script>

<Panel id="heatmap" title="Sector Heatmap" {loading} {error}>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No sector data available</div>
	{:else}
		<div class="heatmap-grid">
			{#each items as sector (sector.symbol)}
				<HeatmapCell {sector} />
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.heatmap-grid {
		display: grid;
		grid-template-columns: repeat(4, 1fr);
		gap: 0.25rem;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}

	@media (max-width: 400px) {
		.heatmap-grid {
			grid-template-columns: repeat(3, 1fr);
		}
	}
</style>



================================================
FILE: src/lib/components/panels/index.ts
================================================
// Panel components barrel export
export { default as NewsPanel } from './NewsPanel.svelte';
export { default as MarketsPanel } from './MarketsPanel.svelte';
export { default as HeatmapPanel } from './HeatmapPanel.svelte';
export { default as CommoditiesPanel } from './CommoditiesPanel.svelte';
export { default as CryptoPanel } from './CryptoPanel.svelte';
export { default as MainCharPanel } from './MainCharPanel.svelte';
export { default as PrinterPanel } from './PrinterPanel.svelte';
export { default as PolymarketPanel } from './PolymarketPanel.svelte';
export { default as WhalePanel } from './WhalePanel.svelte';
export { default as ContractsPanel } from './ContractsPanel.svelte';
export { default as LayoffsPanel } from './LayoffsPanel.svelte';
export { default as IntelPanel } from './IntelPanel.svelte';
export { default as SituationPanel } from './SituationPanel.svelte';
export { default as CorrelationPanel } from './CorrelationPanel.svelte';
export { default as NarrativePanel } from './NarrativePanel.svelte';
export { default as MonitorsPanel } from './MonitorsPanel.svelte';
export { default as MapPanel } from './MapPanel.svelte';
export { default as WorldLeadersPanel } from './WorldLeadersPanel.svelte';
export { default as FedPanel } from './FedPanel.svelte';



================================================
FILE: src/lib/components/panels/IntelPanel.svelte
================================================
<script lang="ts">
	import { Panel, Badge } from '$lib/components/common';
	import { getRelativeTime } from '$lib/utils';
	import { intelNews } from '$lib/stores';
	import type { NewsItem } from '$lib/types';

	type SourceType = 'osint' | 'govt' | 'think-tank' | 'defense' | 'regional' | 'cyber';

	interface IntelItem {
		id: string;
		title: string;
		link: string;
		source: string;
		sourceType: SourceType;
		regions: string[];
		topics: string[];
		pubDate?: string;
		isPriority?: boolean;
	}

	// Destructure store state for cleaner access
	const { items: storeItems, loading, error } = $derived($intelNews);

	// Infer source type from source name
	function inferSourceType(source: string): SourceType {
		const s = source.toLowerCase();
		if (s.includes('cisa') || s.includes('krebs') || s.includes('cyber')) return 'cyber';
		if (s.includes('bellingcat')) return 'osint';
		if (s.includes('defense') || s.includes('war') || s.includes('military')) return 'defense';
		if (s.includes('diplomat') || s.includes('monitor')) return 'regional';
		if (s.includes('white house') || s.includes('fed') || s.includes('sec') || s.includes('dod')) return 'govt';
		return 'think-tank';
	}

	// Transform NewsItem to IntelItem
	function transformToIntelItem(item: NewsItem): IntelItem {
		return {
			id: item.id,
			title: item.title,
			link: item.link,
			source: item.source,
			sourceType: inferSourceType(item.source),
			regions: item.region ? [item.region] : [],
			topics: item.topics || [],
			pubDate: item.pubDate,
			isPriority: item.isAlert
		};
	}

	const items = $derived(storeItems.map(transformToIntelItem));
	const count = $derived(items.length);

	type BadgeVariant = 'default' | 'success' | 'warning' | 'danger' | 'info';

	const SOURCE_BADGE_VARIANTS: Record<string, BadgeVariant> = {
		osint: 'info',
		govt: 'warning',
		cyber: 'danger'
	};

	function getSourceBadgeVariant(type: string): BadgeVariant {
		return SOURCE_BADGE_VARIANTS[type] ?? 'default';
	}
</script>

<Panel id="intel" title="Intel Feed" {count} {loading} {error}>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No intel available</div>
	{:else}
		<div class="intel-list">
			{#each items as item (item.id)}
				<div class="intel-item" class:priority={item.isPriority}>
					<div class="intel-header">
						<span class="intel-source">{item.source}</span>
						<div class="intel-tags">
							<Badge
								text={item.sourceType.toUpperCase()}
								variant={getSourceBadgeVariant(item.sourceType)}
							/>
							{#each item.regions.slice(0, 2) as region}
								<Badge text={region} variant="info" />
							{/each}
							{#each item.topics.slice(0, 2) as topic}
								<Badge text={topic} />
							{/each}
						</div>
					</div>
					<a href={item.link} target="_blank" rel="noopener noreferrer" class="intel-title">
						{item.title}
					</a>
					{#if item.pubDate}
						<div class="intel-meta">
							<span>{getRelativeTime(item.pubDate)}</span>
						</div>
					{/if}
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.intel-list {
		display: flex;
		flex-direction: column;
	}

	.intel-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.intel-item:last-child {
		border-bottom: none;
	}

	.intel-item.priority {
		background: rgba(255, 165, 0, 0.08);
		margin: 0 -0.5rem;
		padding: 0.5rem;
		border-radius: 4px;
		border: 1px solid rgba(255, 165, 0, 0.2);
	}

	.intel-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.3rem;
		gap: 0.5rem;
	}

	.intel-source {
		font-size: 0.55rem;
		font-weight: 600;
		color: var(--text-secondary);
		text-transform: uppercase;
		letter-spacing: 0.03em;
	}

	.intel-tags {
		display: flex;
		flex-wrap: wrap;
		gap: 0.2rem;
	}

	.intel-title {
		display: block;
		font-size: 0.65rem;
		color: var(--text-primary);
		text-decoration: none;
		line-height: 1.35;
	}

	.intel-title:hover {
		color: var(--accent);
	}

	.intel-meta {
		margin-top: 0.25rem;
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/LayoffsPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';
	import { timeAgo } from '$lib/utils';

	interface Layoff {
		company: string;
		count?: string | number;
		title: string;
		date: string;
	}

	interface Props {
		layoffs?: Layoff[];
		loading?: boolean;
		error?: string | null;
	}

	let { layoffs = [], loading = false, error = null }: Props = $props();

	const count = $derived(layoffs.length);
</script>

<Panel id="layoffs" title="Layoffs Tracker" {count} {loading} {error}>
	{#if layoffs.length === 0 && !loading && !error}
		<div class="empty-state">No recent layoffs data</div>
	{:else}
		<div class="layoffs-list">
			{#each layoffs as layoff, i (layoff.company + i)}
				<div class="layoff-item">
					<div class="layoff-company">{layoff.company}</div>
					{#if layoff.count}
						<div class="layoff-count">
							{typeof layoff.count === 'string'
								? parseInt(layoff.count).toLocaleString()
								: layoff.count.toLocaleString()} jobs
						</div>
					{/if}
					<div class="layoff-meta">
						<span class="headline">{layoff.title}</span>
						<span class="time">{timeAgo(layoff.date)}</span>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.layoffs-list {
		display: flex;
		flex-direction: column;
	}

	.layoff-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.layoff-item:last-child {
		border-bottom: none;
	}

	.layoff-company {
		font-size: 0.7rem;
		font-weight: 600;
		color: var(--text-primary);
		margin-bottom: 0.15rem;
	}

	.layoff-count {
		font-size: 0.65rem;
		font-weight: 500;
		color: var(--danger);
		margin-bottom: 0.2rem;
	}

	.layoff-meta {
		display: flex;
		justify-content: space-between;
		align-items: flex-start;
		gap: 0.5rem;
	}

	.headline {
		font-size: 0.6rem;
		color: var(--text-secondary);
		line-height: 1.3;
		flex: 1;
	}

	.time {
		font-size: 0.55rem;
		color: var(--text-muted);
		white-space: nowrap;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/MainCharPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';
	import { allNewsItems } from '$lib/stores';
	import { calculateMainCharacter, type MainCharacterResults } from '$lib/analysis';

	// Calculate main character from all news (reactive via derived store)
	const results: MainCharacterResults = $derived(calculateMainCharacter($allNewsItems));
	const topChar = $derived(results.topCharacter);
	const rankings = $derived(results.characters);
</script>

<Panel id="mainchar" title="Main Character">
	{#if !topChar}
		<div class="empty-state">No data yet</div>
	{:else}
		<div class="main-char-display">
			<div class="main-char-label">Today's Main Character</div>
			<div class="main-char-name">{topChar.name}</div>
			<div class="main-char-count">{topChar.count} mentions in headlines</div>

			{#if rankings.length > 1}
				<div class="main-char-list">
					{#each rankings.slice(1, 8) as char, i (char.name)}
						<div class="char-row">
							<span class="rank">{i + 2}.</span>
							<span class="name">{char.name}</span>
							<span class="mentions">{char.count}</span>
						</div>
					{/each}
				</div>
			{/if}
		</div>
	{/if}
</Panel>

<style>
	.main-char-display {
		text-align: center;
		padding: 0.5rem;
	}

	.main-char-label {
		font-size: 0.55rem;
		color: var(--text-muted);
		text-transform: uppercase;
		letter-spacing: 0.1em;
		margin-bottom: 0.5rem;
	}

	.main-char-name {
		font-size: 1.2rem;
		font-weight: 700;
		color: var(--accent);
		margin-bottom: 0.25rem;
	}

	.main-char-count {
		font-size: 0.65rem;
		color: var(--text-secondary);
		margin-bottom: 1rem;
	}

	.main-char-list {
		border-top: 1px solid var(--border);
		padding-top: 0.75rem;
	}

	.char-row {
		display: flex;
		align-items: center;
		padding: 0.25rem 0;
		font-size: 0.65rem;
	}

	.rank {
		width: 1.5rem;
		color: var(--text-muted);
	}

	.name {
		flex: 1;
		color: var(--text-primary);
	}

	.mentions {
		color: var(--text-secondary);
		font-variant-numeric: tabular-nums;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/MapPanel.svelte
================================================
<script lang="ts">
	import { onMount } from 'svelte';
	import { Panel } from '$lib/components/common';
	import {
		HOTSPOTS,
		CONFLICT_ZONES,
		CHOKEPOINTS,
		CABLE_LANDINGS,
		NUCLEAR_SITES,
		MILITARY_BASES,
		OCEANS,
		SANCTIONED_COUNTRY_IDS,
		THREAT_COLORS,
		WEATHER_CODES
	} from '$lib/config/map';
	import { CACHE_TTLS } from '$lib/config/api';
	import type { CustomMonitor } from '$lib/types';

	interface Props {
		monitors?: CustomMonitor[];
		loading?: boolean;
		error?: string | null;
	}

	let { monitors = [], loading = false, error = null }: Props = $props();

	let mapContainer: HTMLDivElement;
	// D3 objects - initialized in initMap, null before initialization
	// Using 'any' for D3 objects as they're dynamically imported and have complex generic types
	/* eslint-disable @typescript-eslint/no-explicit-any */
	let d3Module: typeof import('d3') | null = null;
	let svg: any = null;
	let mapGroup: any = null;
	let projection: any = null;
	let path: any = null;
	let zoom: any = null;
	/* eslint-enable @typescript-eslint/no-explicit-any */

	const WIDTH = 800;
	const HEIGHT = 400;

	// Tooltip state
	let tooltipContent = $state<{
		title: string;
		color: string;
		lines: string[];
	} | null>(null);
	let tooltipPosition = $state({ left: 0, top: 0 });
	let tooltipVisible = $state(false);

	// Data cache for tooltips with TTL support
	interface CacheEntry<T> {
		data: T;
		timestamp: number;
	}
	const dataCache: Record<string, CacheEntry<unknown>> = {};

	function getCachedData<T>(key: string): T | null {
		const entry = dataCache[key] as CacheEntry<T> | undefined;
		if (!entry) return null;
		// Check if cache entry has expired
		if (Date.now() - entry.timestamp > CACHE_TTLS.weather) {
			delete dataCache[key];
			return null;
		}
		return entry.data;
	}

	function setCachedData<T>(key: string, data: T): void {
		dataCache[key] = { data, timestamp: Date.now() };
	}

	// Get local time at longitude
	function getLocalTime(lon: number): string {
		const now = new Date();
		const utcHours = now.getUTCHours();
		const utcMinutes = now.getUTCMinutes();
		const offsetHours = Math.round(lon / 15);
		let localHours = (utcHours + offsetHours + 24) % 24;
		const ampm = localHours >= 12 ? 'PM' : 'AM';
		localHours = localHours % 12 || 12;
		return `${localHours}:${utcMinutes.toString().padStart(2, '0')} ${ampm}`;
	}

	// Weather result type
	interface WeatherResult {
		temp: number | null;
		wind: number | null;
		condition: string;
	}

	// Fetch weather from Open-Meteo with TTL-based caching
	async function getWeather(lat: number, lon: number): Promise<WeatherResult | null> {
		const key = `weather_${lat}_${lon}`;
		const cached = getCachedData<WeatherResult>(key);
		if (cached) return cached;

		try {
			const res = await fetch(
				`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code,wind_speed_10m`
			);
			const data = await res.json();
			const temp = data.current?.temperature_2m;
			const tempF = temp ? Math.round((temp * 9) / 5 + 32) : null;
			const wind = data.current?.wind_speed_10m;
			const code = data.current?.weather_code;
			const result: WeatherResult = {
				temp: tempF,
				wind: wind ? Math.round(wind) : null,
				condition: WEATHER_CODES[code] || '—'
			};
			setCachedData(key, result);
			return result;
		} catch {
			return null;
		}
	}

	// Enable zoom/pan behavior on the map
	function enableZoom(): void {
		if (!svg || !zoom) return;
		svg.call(zoom);
	}

	// Calculate day/night terminator points
	function calculateTerminator(): [number, number][] {
		const now = new Date();
		const dayOfYear = Math.floor(
			(now.getTime() - new Date(now.getFullYear(), 0, 0).getTime()) / 86400000
		);
		const declination = -23.45 * Math.cos(((360 / 365) * (dayOfYear + 10) * Math.PI) / 180);
		const hourAngle = (now.getUTCHours() + now.getUTCMinutes() / 60) * 15 - 180;

		const terminatorPoints: [number, number][] = [];
		for (let lat = -90; lat <= 90; lat += 2) {
			const tanDec = Math.tan((declination * Math.PI) / 180);
			const tanLat = Math.tan((lat * Math.PI) / 180);
			let lon = -hourAngle + (Math.acos(-tanDec * tanLat) * 180) / Math.PI;
			if (isNaN(lon)) lon = lat * declination > 0 ? -hourAngle + 180 : -hourAngle;
			terminatorPoints.push([lon, lat]);
		}
		for (let lat = 90; lat >= -90; lat -= 2) {
			const tanDec = Math.tan((declination * Math.PI) / 180);
			const tanLat = Math.tan((lat * Math.PI) / 180);
			let lon = -hourAngle - (Math.acos(-tanDec * tanLat) * 180) / Math.PI;
			if (isNaN(lon)) lon = lat * declination > 0 ? -hourAngle - 180 : -hourAngle;
			terminatorPoints.push([lon, lat]);
		}
		return terminatorPoints;
	}

	// Show tooltip using state (safe rendering)
	function showTooltip(
		event: MouseEvent,
		title: string,
		color: string,
		lines: string[] = []
	): void {
		if (!mapContainer) return;
		const rect = mapContainer.getBoundingClientRect();
		tooltipContent = { title, color, lines };
		tooltipPosition = {
			left: event.clientX - rect.left + 15,
			top: event.clientY - rect.top - 10
		};
		tooltipVisible = true;
	}

	// Move tooltip
	function moveTooltip(event: MouseEvent): void {
		if (!mapContainer) return;
		const rect = mapContainer.getBoundingClientRect();
		tooltipPosition = {
			left: event.clientX - rect.left + 15,
			top: event.clientY - rect.top - 10
		};
	}

	// Hide tooltip
	function hideTooltip(): void {
		tooltipVisible = false;
		tooltipContent = null;
	}

	// Build enhanced tooltip with weather
	async function showEnhancedTooltip(
		event: MouseEvent,
		_name: string,
		lat: number,
		lon: number,
		desc: string,
		color: string
	): Promise<void> {
		const localTime = getLocalTime(lon);
		const lines = [`🕐 Local: ${localTime}`];
		showTooltip(event, desc, color, lines);

		// Fetch weather asynchronously
		const weather = await getWeather(lat, lon);
		if (weather && tooltipVisible) {
			tooltipContent = {
				title: desc,
				color,
				lines: [
					`🕐 Local: ${localTime}`,
					`${weather.condition} ${weather.temp}°F, ${weather.wind}mph`
				]
			};
		}
	}

	// Initialize map
	async function initMap(): Promise<void> {
		const d3 = await import('d3');
		d3Module = d3;
		const topojson = await import('topojson-client');

		const svgEl = mapContainer.querySelector('svg');
		if (!svgEl) return;

		svg = d3.select(svgEl);
		svg.attr('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

		mapGroup = svg.append('g').attr('id', 'mapGroup');

		// Setup zoom - disable scroll wheel, allow touch pinch and buttons
		zoom = d3
			.zoom<SVGSVGElement, unknown>()
			.scaleExtent([1, 6])
			.filter((event) => {
				// Block scroll wheel zoom (wheel events)
				if (event.type === 'wheel') return false;
				// Allow touch events (pinch zoom on mobile)
				if (event.type.startsWith('touch')) return true;
				// Allow mouse drag for panning
				if (event.type === 'mousedown' || event.type === 'mousemove') return true;
				// Block double-click zoom
				if (event.type === 'dblclick') return false;
				// Allow other events (programmatic zoom from buttons)
				return true;
			})
			.on('zoom', (event) => {
				mapGroup.attr('transform', event.transform.toString());
			});

		enableZoom();

		// Setup projection
		projection = d3
			.geoEquirectangular()
			.scale(130)
			.center([0, 20])
			.translate([WIDTH / 2, HEIGHT / 2 - 30]);

		path = d3.geoPath().projection(projection);

		// Load world data
		try {
			const response = await fetch(
				'https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json'
			);
			const world = await response.json();
			const countries = topojson.feature(
				world,
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				world.objects.countries as any
			) as unknown as GeoJSON.FeatureCollection;

			// Draw countries
			mapGroup
				.selectAll('path.country')
				.data(countries.features)
				.enter()
				.append('path')
				.attr('class', 'country')
				.attr('d', path as unknown as string)
				.attr('fill', (d: GeoJSON.Feature) =>
					SANCTIONED_COUNTRY_IDS.includes(+(d.id || 0)) ? '#2a1a1a' : '#0f3028'
				)
				.attr('stroke', (d: GeoJSON.Feature) =>
					SANCTIONED_COUNTRY_IDS.includes(+(d.id || 0)) ? '#4a2020' : '#1a5040'
				)
				.attr('stroke-width', 0.5);

			// Draw graticule
			const graticule = d3.geoGraticule().step([30, 30]);
			mapGroup
				.append('path')
				.datum(graticule)
				.attr('d', path as unknown as string)
				.attr('fill', 'none')
				.attr('stroke', '#1a3830')
				.attr('stroke-width', 0.3)
				.attr('stroke-dasharray', '2,2');

			// Draw ocean labels
			OCEANS.forEach((o) => {
				const [x, y] = projection([o.lon, o.lat]) || [0, 0];
				if (x && y) {
					mapGroup
						.append('text')
						.attr('x', x)
						.attr('y', y)
						.attr('fill', '#1a4a40')
						.attr('font-size', '10px')
						.attr('font-family', 'monospace')
						.attr('text-anchor', 'middle')
						.attr('opacity', 0.6)
						.text(o.name);
				}
			});

			// Draw day/night terminator
			const terminatorPoints = calculateTerminator();
			mapGroup
				.append('path')
				.datum({ type: 'Polygon', coordinates: [terminatorPoints] } as GeoJSON.Polygon)
				.attr('d', path as unknown as string)
				.attr('fill', 'rgba(0,0,0,0.3)')
				.attr('stroke', 'none');

			// Draw conflict zones
			CONFLICT_ZONES.forEach((zone) => {
				mapGroup
					.append('path')
					.datum({ type: 'Polygon', coordinates: [zone.coords] } as GeoJSON.Polygon)
					.attr('d', path as unknown as string)
					.attr('fill', zone.color)
					.attr('fill-opacity', 0.15)
					.attr('stroke', zone.color)
					.attr('stroke-width', 0.5)
					.attr('stroke-opacity', 0.4);
			});

			// Draw chokepoints
			CHOKEPOINTS.forEach((cp) => {
				const [x, y] = projection([cp.lon, cp.lat]) || [0, 0];
				if (x && y) {
					mapGroup
						.append('rect')
						.attr('x', x - 4)
						.attr('y', y - 4)
						.attr('width', 8)
						.attr('height', 8)
						.attr('fill', '#00aaff')
						.attr('opacity', 0.8)
						.attr('transform', `rotate(45,${x},${y})`);
					mapGroup
						.append('text')
						.attr('x', x + 8)
						.attr('y', y + 3)
						.attr('fill', '#00aaff')
						.attr('font-size', '7px')
						.attr('font-family', 'monospace')
						.text(cp.name);
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 10)
						.attr('fill', 'transparent')
						.attr('class', 'hotspot-hit')
						.on('mouseenter', (event: MouseEvent) => showTooltip(event, `⬥ ${cp.desc}`, '#00aaff'))
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});

			// Draw cable landings
			CABLE_LANDINGS.forEach((cl) => {
				const [x, y] = projection([cl.lon, cl.lat]) || [0, 0];
				if (x && y) {
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 3)
						.attr('fill', 'none')
						.attr('stroke', '#aa44ff')
						.attr('stroke-width', 1.5);
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 10)
						.attr('fill', 'transparent')
						.attr('class', 'hotspot-hit')
						.on('mouseenter', (event: MouseEvent) => showTooltip(event, `◎ ${cl.desc}`, '#aa44ff'))
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});

			// Draw nuclear sites
			NUCLEAR_SITES.forEach((ns) => {
				const [x, y] = projection([ns.lon, ns.lat]) || [0, 0];
				if (x && y) {
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 2)
						.attr('fill', '#ffff00');
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 5)
						.attr('fill', 'none')
						.attr('stroke', '#ffff00')
						.attr('stroke-width', 1)
						.attr('stroke-dasharray', '3,3');
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 10)
						.attr('fill', 'transparent')
						.attr('class', 'hotspot-hit')
						.on('mouseenter', (event: MouseEvent) => showTooltip(event, `☢ ${ns.desc}`, '#ffff00'))
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});

			// Draw military bases
			MILITARY_BASES.forEach((mb) => {
				const [x, y] = projection([mb.lon, mb.lat]) || [0, 0];
				if (x && y) {
					const starPath = `M${x},${y - 5} L${x + 1.5},${y - 1.5} L${x + 5},${y - 1.5} L${x + 2.5},${y + 1} L${x + 3.5},${y + 5} L${x},${y + 2.5} L${x - 3.5},${y + 5} L${x - 2.5},${y + 1} L${x - 5},${y - 1.5} L${x - 1.5},${y - 1.5} Z`;
					mapGroup.append('path').attr('d', starPath).attr('fill', '#ff00ff').attr('opacity', 0.8);
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 10)
						.attr('fill', 'transparent')
						.attr('class', 'hotspot-hit')
						.on('mouseenter', (event: MouseEvent) => showTooltip(event, `★ ${mb.desc}`, '#ff00ff'))
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});

			// Draw hotspots
			HOTSPOTS.forEach((h) => {
				const [x, y] = projection([h.lon, h.lat]) || [0, 0];
				if (x && y) {
					const color = THREAT_COLORS[h.level];
					// Pulsing circle
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 6)
						.attr('fill', color)
						.attr('fill-opacity', 0.3)
						.attr('class', 'pulse');
					// Inner dot
					mapGroup.append('circle').attr('cx', x).attr('cy', y).attr('r', 3).attr('fill', color);
					// Label
					mapGroup
						.append('text')
						.attr('x', x + 8)
						.attr('y', y + 3)
						.attr('fill', color)
						.attr('font-size', '8px')
						.attr('font-family', 'monospace')
						.text(h.name);
					// Hit area
					mapGroup
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 12)
						.attr('fill', 'transparent')
						.attr('class', 'hotspot-hit')
						.on('mouseenter', (event: MouseEvent) =>
							showEnhancedTooltip(event, h.name, h.lat, h.lon, h.desc, color)
						)
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});

			// Draw custom monitors with locations
			drawMonitors();
		} catch (err) {
			console.error('Failed to load map data:', err);
		}
	}

	// Draw custom monitor locations
	function drawMonitors(): void {
		if (!mapGroup || !projection) return;

		// Remove existing monitor markers
		mapGroup.selectAll('.monitor-marker').remove();

		monitors
			.filter((m) => m.enabled && m.location)
			.forEach((m) => {
				if (!m.location) return;
				const [x, y] = projection([m.location.lon, m.location.lat]) || [0, 0];
				if (x && y) {
					const color = m.color || '#00ffff';
					mapGroup
						.append('circle')
						.attr('class', 'monitor-marker')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 5)
						.attr('fill', color)
						.attr('fill-opacity', 0.6)
						.attr('stroke', color)
						.attr('stroke-width', 2);
					mapGroup
						.append('text')
						.attr('class', 'monitor-marker')
						.attr('x', x + 8)
						.attr('y', y + 3)
						.attr('fill', color)
						.attr('font-size', '8px')
						.attr('font-family', 'monospace')
						.text(m.name);
					mapGroup
						.append('circle')
						.attr('class', 'monitor-marker')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', 10)
						.attr('fill', 'transparent')
						.on('mouseenter', (event: MouseEvent) =>
							showTooltip(event, `📡 ${m.name}`, color, [
								m.location?.name || '',
								m.keywords.join(', ')
							])
						)
						.on('mousemove', moveTooltip)
						.on('mouseleave', hideTooltip);
				}
			});
	}

	// Zoom controls
	function zoomIn(): void {
		if (!svg || !zoom) return;
		svg.transition().duration(300).call(zoom.scaleBy, 1.5);
	}

	function zoomOut(): void {
		if (!svg || !zoom) return;
		svg
			.transition()
			.duration(300)
			.call(zoom.scaleBy, 1 / 1.5);
	}

	function resetZoom(): void {
		if (!svg || !zoom || !d3Module) return;
		svg.transition().duration(300).call(zoom.transform, d3Module.zoomIdentity);
	}

	// Reactively update monitors when they change
	$effect(() => {
		// Track monitors changes
		const _monitorsRef = monitors;
		if (_monitorsRef && mapGroup && projection) {
			drawMonitors();
		}
	});

	onMount(() => {
		initMap();
	});
</script>

<Panel id="map" title="Global Situation" {loading} {error}>
	<div class="map-container" bind:this={mapContainer}>
		<svg class="map-svg"></svg>
		{#if tooltipVisible && tooltipContent}
			<div
				class="map-tooltip"
				style="left: {tooltipPosition.left}px; top: {tooltipPosition.top}px;"
			>
				<strong style="color: {tooltipContent.color}">{tooltipContent.title}</strong>
				{#each tooltipContent.lines as line}
					<br /><span class="tooltip-line">{line}</span>
				{/each}
			</div>
		{/if}
		<div class="zoom-controls">
			<button class="zoom-btn" onclick={zoomIn} title="Zoom in">+</button>
			<button class="zoom-btn" onclick={zoomOut} title="Zoom out">−</button>
			<button class="zoom-btn" onclick={resetZoom} title="Reset">⟲</button>
		</div>
		<div class="map-legend">
			<div class="legend-item">
				<span class="legend-dot high"></span> High
			</div>
			<div class="legend-item">
				<span class="legend-dot elevated"></span> Elevated
			</div>
			<div class="legend-item">
				<span class="legend-dot low"></span> Low
			</div>
		</div>
	</div>
</Panel>

<style>
	.map-container {
		position: relative;
		width: 100%;
		aspect-ratio: 2 / 1;
		background: #0a0f0d;
		border-radius: 4px;
		overflow: hidden;
	}

	.map-svg {
		width: 100%;
		height: 100%;
	}

	.map-tooltip {
		position: absolute;
		background: rgba(10, 10, 10, 0.95);
		border: 1px solid #333;
		border-radius: 4px;
		padding: 0.5rem;
		font-size: 0.65rem;
		color: #ddd;
		max-width: 250px;
		pointer-events: none;
		z-index: 100;
	}

	.tooltip-line {
		opacity: 0.7;
	}

	.zoom-controls {
		position: absolute;
		bottom: 0.5rem;
		right: 0.5rem;
		display: flex;
		flex-direction: column;
		gap: 0.25rem;
	}

	.zoom-btn {
		width: 2.75rem;
		height: 2.75rem;
		display: flex;
		align-items: center;
		justify-content: center;
		background: rgba(20, 20, 20, 0.9);
		border: 1px solid #333;
		border-radius: 4px;
		color: #aaa;
		font-size: 1rem;
		cursor: pointer;
	}

	.zoom-btn:hover {
		background: rgba(40, 40, 40, 0.9);
		color: #fff;
	}

	.map-legend {
		position: absolute;
		top: 0.5rem;
		right: 0.5rem;
		display: flex;
		flex-direction: column;
		gap: 0.2rem;
		background: rgba(10, 10, 10, 0.8);
		padding: 0.3rem 0.5rem;
		border-radius: 4px;
		font-size: 0.55rem;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.3rem;
		color: #888;
	}

	.legend-dot {
		width: 8px;
		height: 8px;
		border-radius: 50%;
	}

	.legend-dot.high {
		background: #ff4444;
	}

	.legend-dot.elevated {
		background: #ffcc00;
	}

	.legend-dot.low {
		background: #00ff88;
	}

	/* Pulse animation for hotspots */
	:global(.pulse) {
		animation: pulse 2s ease-in-out infinite;
	}

	@keyframes pulse {
		0%,
		100% {
			r: 6;
			opacity: 0.3;
		}
		50% {
			r: 10;
			opacity: 0.1;
		}
	}

	:global(.hotspot-hit) {
		cursor: pointer;
	}

	/* Hide zoom controls on mobile where touch zoom is available */
	@media (max-width: 768px) {
		.zoom-controls {
			display: flex;
		}
	}
</style>



================================================
FILE: src/lib/components/panels/MarketsPanel.svelte
================================================
<script lang="ts">
	import { Panel, MarketItem } from '$lib/components/common';
	import { indices } from '$lib/stores';

	const items = $derived($indices.items);
	const loading = $derived($indices.loading);
	const error = $derived($indices.error);
	const count = $derived(items.length);
</script>

<Panel id="markets" title="Markets" {count} {loading} {error}>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No market data available</div>
	{:else}
		<div class="markets-list">
			{#each items as item (item.symbol)}
				<MarketItem {item} />
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.markets-list {
		display: flex;
		flex-direction: column;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/MonitorsPanel.svelte
================================================
<script lang="ts">
	import { Panel, Badge } from '$lib/components/common';
	import { timeAgo } from '$lib/utils';
	import type { CustomMonitor } from '$lib/types';
	import type { MonitorMatch } from '$lib/stores/monitors';

	interface Props {
		monitors?: CustomMonitor[];
		matches?: MonitorMatch[];
		loading?: boolean;
		error?: string | null;
		onCreateMonitor?: () => void;
		onEditMonitor?: (monitor: CustomMonitor) => void;
		onDeleteMonitor?: (id: string) => void;
		onToggleMonitor?: (id: string) => void;
	}

	let {
		monitors = [],
		matches = [],
		loading = false,
		error = null,
		onCreateMonitor,
		onEditMonitor,
		onDeleteMonitor,
		onToggleMonitor
	}: Props = $props();

	const activeMonitors = $derived(monitors.filter((m) => m.enabled));
	const count = $derived(matches.length);

	function getMatchesForMonitor(monitorId: string): MonitorMatch[] {
		return matches.filter((m) => m.monitor.id === monitorId).slice(0, 3);
	}
</script>

<Panel id="monitors" title="Custom Monitors" {count} {loading} {error}>
	<div class="monitors-content">
		{#if monitors.length === 0 && !loading && !error}
			<div class="empty-state">
				<p>No monitors configured</p>
				{#if onCreateMonitor}
					<button class="create-btn" onclick={onCreateMonitor}> + Create Monitor </button>
				{/if}
			</div>
		{:else}
			<div class="monitors-header">
				<span class="active-count">{activeMonitors.length} active</span>
				{#if onCreateMonitor}
					<button class="add-btn" onclick={onCreateMonitor}>+</button>
				{/if}
			</div>

			<div class="monitors-list">
				{#each monitors as monitor (monitor.id)}
					<div class="monitor-item" class:disabled={!monitor.enabled}>
						<div class="monitor-header">
							<div class="monitor-info">
								{#if monitor.color}
									<span class="monitor-color" style="background: {monitor.color}"></span>
								{/if}
								<span class="monitor-name">{monitor.name}</span>
								{#if monitor.matchCount > 0}
									<Badge text={String(monitor.matchCount)} variant="info" />
								{/if}
							</div>
							<div class="monitor-actions">
								{#if onToggleMonitor}
									<button
										class="action-btn"
										class:active={monitor.enabled}
										onclick={() => onToggleMonitor?.(monitor.id)}
										title={monitor.enabled ? 'Disable' : 'Enable'}
									>
										{monitor.enabled ? '●' : '○'}
									</button>
								{/if}
								{#if onEditMonitor}
									<button class="action-btn" onclick={() => onEditMonitor?.(monitor)} title="Edit">
										✎
									</button>
								{/if}
								{#if onDeleteMonitor}
									<button
										class="action-btn delete"
										onclick={() => onDeleteMonitor?.(monitor.id)}
										title="Delete"
									>
										×
									</button>
								{/if}
							</div>
						</div>

						<div class="monitor-keywords">
							{#each monitor.keywords.slice(0, 5) as keyword}
								<span class="keyword">{keyword}</span>
							{/each}
							{#if monitor.keywords.length > 5}
								<span class="keyword more">+{monitor.keywords.length - 5}</span>
							{/if}
						</div>

						{#if monitor.location}
							<div class="monitor-location">
								📍 {monitor.location.name}
							</div>
						{/if}

						{#if getMatchesForMonitor(monitor.id).length > 0}
							<div class="monitor-matches">
								{#each getMatchesForMonitor(monitor.id) as match}
									<div class="match-item">
										<a
											href={match.item.link}
											target="_blank"
											rel="noopener noreferrer"
											class="match-title"
										>
											{match.item.title.length > 80
												? match.item.title.substring(0, 80) + '...'
												: match.item.title}
										</a>
										<div class="match-meta">
											<span class="match-keyword">"{match.matchedKeywords.join(', ')}"</span>
											<span class="match-time">{timeAgo(match.item.timestamp)}</span>
										</div>
									</div>
								{/each}
							</div>
						{/if}
					</div>
				{/each}
			</div>
		{/if}
	</div>
</Panel>

<style>
	.monitors-content {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.monitors-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding-bottom: 0.4rem;
		border-bottom: 1px solid var(--border);
	}

	.active-count {
		font-size: 0.55rem;
		color: var(--text-secondary);
	}

	.add-btn {
		width: 1.2rem;
		height: 1.2rem;
		display: flex;
		align-items: center;
		justify-content: center;
		background: rgba(255, 255, 255, 0.05);
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-secondary);
		font-size: 0.8rem;
		cursor: pointer;
		transition: all 0.15s ease;
	}

	.add-btn:hover {
		background: rgba(255, 255, 255, 0.1);
		color: var(--accent);
	}

	.monitors-list {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.monitor-item {
		padding: 0.5rem;
		background: rgba(255, 255, 255, 0.02);
		border: 1px solid var(--border);
		border-radius: 4px;
	}

	.monitor-item.disabled {
		opacity: 0.5;
	}

	.monitor-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.3rem;
	}

	.monitor-info {
		display: flex;
		align-items: center;
		gap: 0.3rem;
	}

	.monitor-color {
		width: 8px;
		height: 8px;
		border-radius: 50%;
	}

	.monitor-name {
		font-size: 0.65rem;
		font-weight: 600;
		color: var(--text-primary);
	}

	.monitor-actions {
		display: flex;
		gap: 0.2rem;
	}

	.action-btn {
		width: 1rem;
		height: 1rem;
		display: flex;
		align-items: center;
		justify-content: center;
		background: transparent;
		border: none;
		color: var(--text-muted);
		font-size: 0.65rem;
		cursor: pointer;
		border-radius: 2px;
	}

	.action-btn:hover {
		background: rgba(255, 255, 255, 0.1);
		color: var(--text-primary);
	}

	.action-btn.active {
		color: var(--success);
	}

	.action-btn.delete:hover {
		color: var(--danger);
	}

	.monitor-keywords {
		display: flex;
		flex-wrap: wrap;
		gap: 0.2rem;
		margin-bottom: 0.3rem;
	}

	.keyword {
		font-size: 0.5rem;
		padding: 0.1rem 0.3rem;
		background: rgba(255, 255, 255, 0.05);
		border-radius: 2px;
		color: var(--text-secondary);
	}

	.keyword.more {
		color: var(--text-muted);
	}

	.monitor-location {
		font-size: 0.5rem;
		color: var(--text-muted);
		margin-bottom: 0.3rem;
	}

	.monitor-matches {
		border-top: 1px solid var(--border);
		padding-top: 0.3rem;
		margin-top: 0.2rem;
	}

	.match-item {
		padding: 0.2rem 0;
	}

	.match-title {
		display: block;
		font-size: 0.55rem;
		color: var(--text-primary);
		text-decoration: none;
		line-height: 1.3;
	}

	.match-title:hover {
		color: var(--accent);
	}

	.match-meta {
		display: flex;
		justify-content: space-between;
		margin-top: 0.1rem;
	}

	.match-keyword {
		font-size: 0.5rem;
		color: var(--warning);
	}

	.match-time {
		font-size: 0.5rem;
		color: var(--text-muted);
	}

	.empty-state {
		text-align: center;
		padding: 1rem;
	}

	.empty-state p {
		color: var(--text-secondary);
		font-size: 0.7rem;
		margin-bottom: 0.5rem;
	}

	.create-btn {
		padding: 0.4rem 0.8rem;
		background: rgba(255, 255, 255, 0.05);
		border: 1px solid var(--border);
		border-radius: 4px;
		color: var(--text-primary);
		font-size: 0.6rem;
		cursor: pointer;
	}

	.create-btn:hover {
		background: rgba(255, 255, 255, 0.1);
		border-color: var(--accent);
	}
</style>



================================================
FILE: src/lib/components/panels/NarrativePanel.svelte
================================================
<script lang="ts">
	import { Panel, Badge } from '$lib/components/common';
	import { analyzeNarratives } from '$lib/analysis/narrative';
	import type { NewsItem } from '$lib/types';

	interface Props {
		news?: NewsItem[];
		loading?: boolean;
		error?: string | null;
	}

	let { news = [], loading = false, error = null }: Props = $props();

	const analysis = $derived(analyzeNarratives(news));

	function getStatusVariant(status: string): 'default' | 'warning' | 'danger' | 'success' | 'info' {
		switch (status) {
			case 'viral':
				return 'danger';
			case 'spreading':
				return 'warning';
			case 'emerging':
				return 'info';
			case 'crossing':
				return 'warning';
			default:
				return 'default';
		}
	}

	function getSeverityVariant(
		severity: string
	): 'default' | 'warning' | 'danger' | 'success' | 'info' {
		switch (severity) {
			case 'high':
				return 'danger';
			case 'medium':
				return 'warning';
			default:
				return 'default';
		}
	}
</script>

<Panel id="narrative" title="Narrative Tracker" {loading} {error}>
	{#if news.length === 0 && !loading && !error}
		<div class="empty-state">Insufficient data for narrative analysis</div>
	{:else if analysis}
		<div class="narrative-content">
			{#if analysis.emergingFringe.length > 0}
				<div class="section">
					<div class="section-title">Emerging Fringe</div>
					{#each analysis.emergingFringe.slice(0, 4) as narrative}
						<div class="narrative-item">
							<div class="narrative-header">
								<span class="narrative-name">{narrative.name}</span>
								<Badge
									text={narrative.status.toUpperCase()}
									variant={getStatusVariant(narrative.status)}
								/>
							</div>
							<div class="narrative-meta">
								<span class="mention-count">{narrative.count} mentions</span>
							</div>
							{#if narrative.sources.length > 0}
								<div class="narrative-sources">
									{narrative.sources.slice(0, 3).join(' · ')}
								</div>
							{/if}
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.fringeToMainstream.length > 0}
				<div class="section">
					<div class="section-title">Fringe → Mainstream Crossovers</div>
					{#each analysis.fringeToMainstream.slice(0, 3) as crossover}
						<div class="crossover-item">
							<div class="crossover-narrative">{crossover.name}</div>
							<div class="crossover-path">
								<span class="from">Fringe ({crossover.fringeCount})</span>
								<span class="arrow">→</span>
								<span class="to">Mainstream ({crossover.mainstreamCount})</span>
							</div>
							<div class="crossover-level">
								Crossover level: {Math.round(crossover.crossoverLevel * 100)}%
							</div>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.narrativeWatch.length > 0}
				<div class="section">
					<div class="section-title">Narrative Watch</div>
					<div class="themes-grid">
						{#each analysis.narrativeWatch.slice(0, 6) as narrative}
							<div class="theme-tag">
								{narrative.name}
								<span class="theme-count">{narrative.count}</span>
							</div>
						{/each}
					</div>
				</div>
			{/if}

			{#if analysis.disinfoSignals.length > 0}
				<div class="section">
					<div class="section-title">Disinfo Signals</div>
					{#each analysis.disinfoSignals.slice(0, 3) as signal}
						<div class="disinfo-item">
							<div class="disinfo-header">
								<span class="disinfo-name">{signal.name}</span>
								<Badge
									text={signal.severity.toUpperCase()}
									variant={getSeverityVariant(signal.severity)}
								/>
							</div>
							<div class="disinfo-meta">{signal.count} mentions</div>
						</div>
					{/each}
				</div>
			{/if}

			{#if analysis.emergingFringe.length === 0 && analysis.fringeToMainstream.length === 0}
				<div class="empty-state">No significant narratives detected</div>
			{/if}
		</div>
	{:else}
		<div class="empty-state">No significant narratives detected</div>
	{/if}
</Panel>

<style>
	.narrative-content {
		display: flex;
		flex-direction: column;
		gap: 0.75rem;
	}

	.section {
		padding-bottom: 0.5rem;
		border-bottom: 1px solid var(--border);
	}

	.section:last-child {
		border-bottom: none;
		padding-bottom: 0;
	}

	.section-title {
		font-size: 0.6rem;
		font-weight: 600;
		color: var(--accent);
		text-transform: uppercase;
		letter-spacing: 0.05em;
		margin-bottom: 0.4rem;
	}

	.narrative-item {
		padding: 0.4rem 0;
		border-bottom: 1px solid var(--border);
	}

	.narrative-item:last-child {
		border-bottom: none;
	}

	.narrative-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.2rem;
	}

	.narrative-name {
		font-size: 0.65rem;
		font-weight: 500;
		color: var(--text-primary);
	}

	.narrative-meta {
		display: flex;
		gap: 0.5rem;
		align-items: center;
		margin-bottom: 0.15rem;
	}

	.mention-count {
		font-size: 0.55rem;
		color: var(--text-secondary);
	}

	.narrative-sources {
		font-size: 0.5rem;
		color: var(--text-muted);
	}

	.crossover-item {
		padding: 0.35rem 0;
		border-left: 2px solid var(--warning);
		padding-left: 0.5rem;
		margin: 0.25rem 0;
	}

	.crossover-narrative {
		font-size: 0.6rem;
		font-weight: 500;
		color: var(--text-primary);
	}

	.crossover-path {
		display: flex;
		align-items: center;
		gap: 0.3rem;
		font-size: 0.55rem;
		margin: 0.15rem 0;
	}

	.crossover-path .from {
		color: var(--text-secondary);
	}

	.crossover-path .arrow {
		color: var(--warning);
	}

	.crossover-path .to {
		color: var(--success);
	}

	.crossover-level {
		font-size: 0.5rem;
		color: var(--text-muted);
	}

	.themes-grid {
		display: flex;
		flex-wrap: wrap;
		gap: 0.3rem;
	}

	.theme-tag {
		display: inline-flex;
		align-items: center;
		gap: 0.25rem;
		padding: 0.2rem 0.4rem;
		background: rgba(255, 255, 255, 0.05);
		border-radius: 4px;
		font-size: 0.55rem;
		color: var(--text-secondary);
	}

	.theme-count {
		font-size: 0.5rem;
		color: var(--text-muted);
		background: rgba(255, 255, 255, 0.1);
		padding: 0.1rem 0.2rem;
		border-radius: 2px;
	}

	.disinfo-item {
		padding: 0.3rem 0;
	}

	.disinfo-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
	}

	.disinfo-name {
		font-size: 0.6rem;
		color: var(--text-primary);
	}

	.disinfo-meta {
		font-size: 0.5rem;
		color: var(--text-muted);
		margin-top: 0.1rem;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/NewsPanel.svelte
================================================
<script lang="ts">
	import { Panel, NewsItem } from '$lib/components/common';
	import type { NewsCategory } from '$lib/types';
	import type { PanelId } from '$lib/config';
	import { politicsNews, techNews, financeNews, govNews, aiNews, intelNews } from '$lib/stores';

	interface Props {
		category: NewsCategory;
		panelId: PanelId;
		title: string;
	}

	let { category, panelId, title }: Props = $props();

	// Get the appropriate derived store based on category
	const categoryStores = {
		politics: politicsNews,
		tech: techNews,
		finance: financeNews,
		gov: govNews,
		ai: aiNews,
		intel: intelNews
	};

	const categoryStore = $derived(categoryStores[category]);
	const items = $derived($categoryStore.items);
	const loading = $derived($categoryStore.loading);
	const error = $derived($categoryStore.error);
	const count = $derived(items.length);
</script>

<Panel id={panelId} {title} {count} {loading} {error}>
	{#if items.length === 0 && !loading && !error}
		<div class="empty-state">No news available</div>
	{:else}
		<div class="news-list">
			{#each items.slice(0, 15) as item (item.id)}
				<NewsItem {item} />
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.news-list {
		display: flex;
		flex-direction: column;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/PolymarketPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';

	interface Prediction {
		id: string;
		question: string;
		yes: number;
		volume: number | string;
		url?: string;
	}

	interface Props {
		predictions?: Prediction[];
		loading?: boolean;
		error?: string | null;
	}

	let { predictions = [], loading = false, error = null }: Props = $props();

	const count = $derived(predictions.length);

	function formatVolume(v: number | string): string {
		if (typeof v === 'string') return '$' + v;
		if (!v) return '$0';
		if (v >= 1e6) return '$' + (v / 1e6).toFixed(1) + 'M';
		if (v >= 1e3) return '$' + (v / 1e3).toFixed(0) + 'K';
		return '$' + v.toFixed(0);
	}
</script>

<Panel id="polymarket" title="Polymarket" {count} {loading} {error}>
	{#if predictions.length === 0 && !loading && !error}
		<div class="empty-state">No predictions available</div>
	{:else}
		<div class="predictions-list">
			{#each predictions as pred (pred.id)}
				<div class="prediction-item">
					<div class="prediction-info">
						<div class="prediction-question">{pred.question}</div>
						<div class="prediction-volume">Vol: {formatVolume(pred.volume)}</div>
					</div>
					<div class="prediction-odds">
						<span class="prediction-yes">{pred.yes}%</span>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.predictions-list {
		display: flex;
		flex-direction: column;
	}

	.prediction-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.prediction-item:last-child {
		border-bottom: none;
	}

	.prediction-info {
		flex: 1;
		min-width: 0;
	}

	.prediction-question {
		font-size: 0.65rem;
		color: var(--text-primary);
		line-height: 1.3;
		margin-bottom: 0.2rem;
	}

	.prediction-volume {
		font-size: 0.55rem;
		color: var(--text-muted);
	}

	.prediction-odds {
		margin-left: 0.5rem;
	}

	.prediction-yes {
		font-size: 0.8rem;
		font-weight: 700;
		color: var(--success);
		font-variant-numeric: tabular-nums;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/PrinterPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';

	interface Props {
		data?: {
			value: number;
			change: number;
			changePercent: number;
			percentOfMax: number;
		} | null;
		loading?: boolean;
		error?: string | null;
	}

	let { data = null, loading = false, error = null }: Props = $props();

	const isExpanding = $derived(data && data.change > 0);
	const status = $derived(isExpanding ? 'PRINTER ON' : 'PRINTER OFF');
	const statusClass = $derived(isExpanding ? 'critical' : 'monitoring');
</script>

<Panel id="printer" title="Money Printer" {status} {statusClass} {loading} {error}>
	{#if !data && !loading && !error}
		<div class="empty-state">No Fed data available</div>
	{:else if data}
		<div class="printer-gauge">
			<div class="printer-label">Federal Reserve Balance Sheet</div>
			<div class="printer-value">
				{data.value.toFixed(2)}<span class="printer-unit">T USD</span>
			</div>
			<div class="printer-change" class:up={isExpanding} class:down={!isExpanding}>
				{data.change >= 0 ? '+' : ''}{(data.change * 1000).toFixed(0)}B ({data.changePercent >= 0
					? '+'
					: ''}{data.changePercent.toFixed(2)}%) WoW
			</div>
			<div class="printer-bar">
				<div class="printer-fill" style="width: {Math.min(data.percentOfMax, 100)}%"></div>
			</div>
			<div class="printer-status">
				<span class="printer-indicator" class:on={isExpanding} class:off={!isExpanding}></span>
				{status}
			</div>
		</div>
	{/if}
</Panel>

<style>
	.printer-gauge {
		text-align: center;
		padding: 0.5rem;
	}

	.printer-label {
		font-size: 0.55rem;
		color: var(--text-muted);
		text-transform: uppercase;
		letter-spacing: 0.05em;
		margin-bottom: 0.5rem;
	}

	.printer-value {
		font-size: 1.5rem;
		font-weight: 700;
		color: var(--text-primary);
		font-variant-numeric: tabular-nums;
	}

	.printer-unit {
		font-size: 0.7rem;
		font-weight: 400;
		color: var(--text-secondary);
		margin-left: 0.25rem;
	}

	.printer-change {
		font-size: 0.65rem;
		font-weight: 500;
		margin: 0.25rem 0 0.75rem;
	}

	.printer-change.up {
		color: var(--success);
	}

	.printer-change.down {
		color: var(--danger);
	}

	.printer-bar {
		height: 8px;
		background: var(--border);
		border-radius: 4px;
		overflow: hidden;
		margin-bottom: 0.75rem;
	}

	.printer-fill {
		height: 100%;
		background: linear-gradient(90deg, var(--success), var(--accent));
		border-radius: 4px;
		transition: width 0.3s ease;
	}

	.printer-status {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 0.5rem;
		font-size: 0.7rem;
		font-weight: 600;
		color: var(--text-secondary);
	}

	.printer-indicator {
		width: 8px;
		height: 8px;
		border-radius: 50%;
	}

	.printer-indicator.on {
		background: var(--success);
		box-shadow: 0 0 8px var(--success);
		animation: pulse 1.5s ease-in-out infinite;
	}

	.printer-indicator.off {
		background: var(--danger);
	}

	@keyframes pulse {
		0%,
		100% {
			opacity: 1;
		}
		50% {
			opacity: 0.5;
		}
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/SituationPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';
	import { timeAgo } from '$lib/utils';
	import type { PanelId } from '$lib/config';
	import type { NewsItem } from '$lib/types';

	interface SituationConfig {
		title: string;
		subtitle: string;
		criticalKeywords?: string[];
	}

	interface Props {
		panelId: PanelId;
		config: SituationConfig;
		news?: NewsItem[];
		loading?: boolean;
		error?: string | null;
	}

	let { panelId, config, news = [], loading = false, error = null }: Props = $props();

	// Calculate threat level based on news
	const threatLevel = $derived(calculateThreatLevel(news, config.criticalKeywords));

	function calculateThreatLevel(
		newsItems: NewsItem[],
		criticalKeywords: string[] = []
	): { level: string; text: string } {
		if (newsItems.length === 0) {
			return { level: 'monitoring', text: 'MONITORING' };
		}

		const now = Date.now();
		const recentNews = newsItems.filter((n) => {
			const hoursSince = (now - n.timestamp) / (1000 * 60 * 60);
			return hoursSince < 24;
		});

		const hasCritical = newsItems.some((n) =>
			criticalKeywords.some((k) => n.title.toLowerCase().includes(k))
		);

		if (hasCritical || recentNews.length >= 3) {
			return { level: 'critical', text: 'CRITICAL' };
		}
		if (recentNews.length >= 1) {
			return { level: 'elevated', text: 'ELEVATED' };
		}
		return { level: 'monitoring', text: 'MONITORING' };
	}
</script>

<Panel
	id={panelId}
	title={config.title}
	status={threatLevel.text}
	statusClass={threatLevel.level}
	{loading}
	{error}
>
	<div class="situation-content">
		<div class="situation-header">
			<div class="situation-title">{config.title}</div>
			<div class="situation-subtitle">{config.subtitle}</div>
		</div>

		{#if news.length === 0 && !loading && !error}
			<div class="empty-state">No recent news</div>
		{:else}
			<div class="situation-news">
				{#each news.slice(0, 8) as item (item.id)}
					<div class="situation-item">
						<a href={item.link} target="_blank" rel="noopener noreferrer" class="headline">
							{item.title}
						</a>
						<div class="meta">{item.source} · {timeAgo(item.timestamp)}</div>
					</div>
				{/each}
			</div>
		{/if}
	</div>
</Panel>

<style>
	.situation-content {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.situation-header {
		text-align: center;
		padding-bottom: 0.5rem;
		border-bottom: 1px solid var(--border);
	}

	.situation-title {
		font-size: 0.8rem;
		font-weight: 600;
		color: var(--text-primary);
	}

	.situation-subtitle {
		font-size: 0.6rem;
		color: var(--text-secondary);
		margin-top: 0.1rem;
	}

	.situation-news {
		display: flex;
		flex-direction: column;
	}

	.situation-item {
		padding: 0.4rem 0;
		border-bottom: 1px solid var(--border);
	}

	.situation-item:last-child {
		border-bottom: none;
	}

	.headline {
		display: block;
		font-size: 0.65rem;
		color: var(--text-primary);
		text-decoration: none;
		line-height: 1.35;
	}

	.headline:hover {
		color: var(--accent);
	}

	.meta {
		font-size: 0.55rem;
		color: var(--text-muted);
		margin-top: 0.2rem;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/WhalePanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';

	interface WhaleTransaction {
		coin: string;
		amount: number;
		usd: number;
		hash: string;
	}

	interface Props {
		whales?: WhaleTransaction[];
		loading?: boolean;
		error?: string | null;
	}

	let { whales = [], loading = false, error = null }: Props = $props();

	const count = $derived(whales.length);

	function formatAmount(amt: number): string {
		return amt >= 1000 ? (amt / 1000).toFixed(1) + 'K' : amt.toFixed(2);
	}

	function formatUSD(usd: number): string {
		if (usd >= 1e9) return '$' + (usd / 1e9).toFixed(1) + 'B';
		if (usd >= 1e6) return '$' + (usd / 1e6).toFixed(1) + 'M';
		return '$' + (usd / 1e3).toFixed(0) + 'K';
	}
</script>

<Panel id="whales" title="Whale Watch" {count} {loading} {error}>
	{#if whales.length === 0 && !loading && !error}
		<div class="empty-state">No whale transactions detected</div>
	{:else}
		<div class="whale-list">
			{#each whales as whale, i (whale.hash + i)}
				<div class="whale-item">
					<div class="whale-header">
						<span class="whale-coin">{whale.coin}</span>
						<span class="whale-amount">{formatAmount(whale.amount)} {whale.coin}</span>
					</div>
					<div class="whale-flow">
						<span class="whale-usd">{formatUSD(whale.usd)}</span>
						<span class="arrow">→</span>
						<span class="whale-hash">{whale.hash}</span>
					</div>
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.whale-list {
		display: flex;
		flex-direction: column;
	}

	.whale-item {
		padding: 0.5rem 0;
		border-bottom: 1px solid var(--border);
	}

	.whale-item:last-child {
		border-bottom: none;
	}

	.whale-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0.25rem;
	}

	.whale-coin {
		font-size: 0.7rem;
		font-weight: 600;
		color: var(--accent);
	}

	.whale-amount {
		font-size: 0.65rem;
		color: var(--text-primary);
		font-variant-numeric: tabular-nums;
	}

	.whale-flow {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.6rem;
	}

	.whale-usd {
		color: var(--success);
		font-weight: 500;
	}

	.arrow {
		color: var(--text-muted);
	}

	.whale-hash {
		color: var(--text-secondary);
		font-family: monospace;
		font-size: 0.55rem;
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/components/panels/WorldLeadersPanel.svelte
================================================
<script lang="ts">
	import { Panel } from '$lib/components/common';
	import type { WorldLeader } from '$lib/types';

	interface Props {
		leaders?: WorldLeader[];
		loading?: boolean;
		error?: string | null;
	}

	let { leaders = [], loading = false, error = null }: Props = $props();

	const count = $derived(leaders.length);

	function getActivityClass(newsCount: number): string {
		if (newsCount >= 3) return 'high-activity';
		if (newsCount >= 1) return 'active';
		return '';
	}
</script>

<Panel id="leaders" title="World Leaders" {count} {loading} {error}>
	{#if leaders.length === 0 && !loading && !error}
		<div class="empty-state">No leaders data available</div>
	{:else}
		<div class="leaders-grid">
			{#each leaders as leader (leader.id)}
				{@const newsCount = leader.news?.length || 0}
				{@const activityClass = getActivityClass(newsCount)}
				{@const latestNews = leader.news?.slice(0, 2) || []}
				<div class="leader-card {activityClass}">
					<div class="leader-header">
						<span class="leader-flag">{leader.flag}</span>
						<div class="leader-info">
							<div class="leader-name">{leader.name}</div>
							<div class="leader-title">{leader.title}</div>
							<div class="leader-country">{leader.country}</div>
						</div>
						{#if newsCount > 0}
							<div class="leader-activity-badge">{newsCount}</div>
						{/if}
					</div>
					<div class="leader-meta">
						<span class="leader-since">Since {leader.since}</span>
						<span class="leader-party">{leader.party}</span>
					</div>
					{#if leader.focus && leader.focus.length > 0}
						<div class="leader-focus-topics">
							{#each leader.focus.slice(0, 3) as topic}
								<span class="leader-focus">{topic}</span>
							{/each}
						</div>
					{/if}
					{#if latestNews.length > 0}
						<div class="leader-news">
							{#each latestNews as news}
								<a href={news.link} target="_blank" class="leader-news-item" title={news.title}>
									{news.title.length > 60 ? news.title.substring(0, 60) + '...' : news.title}
								</a>
							{/each}
						</div>
					{/if}
				</div>
			{/each}
		</div>
	{/if}
</Panel>

<style>
	.leaders-grid {
		display: grid;
		grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
		gap: 0.75rem;
	}

	.leader-card {
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: 6px;
		padding: 0.75rem;
		transition: all 0.2s;
	}

	.leader-card:hover {
		border-color: var(--border-light);
		background: var(--surface-hover);
	}

	.leader-card.active {
		border-color: var(--info);
	}

	.leader-card.high-activity {
		border-color: var(--warning);
		box-shadow: 0 0 8px rgba(255, 170, 0, 0.2);
	}

	.leader-header {
		display: flex;
		align-items: flex-start;
		gap: 0.5rem;
		margin-bottom: 0.5rem;
	}

	.leader-flag {
		font-size: 1.5rem;
		line-height: 1;
	}

	.leader-info {
		flex: 1;
		min-width: 0;
	}

	.leader-name {
		font-size: 0.8rem;
		font-weight: 600;
		color: var(--text-primary);
		line-height: 1.2;
	}

	.leader-title {
		font-size: 0.65rem;
		color: var(--text-dim);
		margin-top: 0.1rem;
	}

	.leader-country {
		font-size: 0.6rem;
		color: var(--text-muted);
		margin-top: 0.15rem;
	}

	.leader-activity-badge {
		background: var(--info);
		color: #000;
		font-size: 0.55rem;
		font-weight: bold;
		padding: 0.15rem 0.35rem;
		border-radius: 3px;
		min-width: 18px;
		text-align: center;
	}

	.leader-card.high-activity .leader-activity-badge {
		background: var(--warning);
	}

	.leader-meta {
		display: flex;
		gap: 0.5rem;
		font-size: 0.55rem;
		color: var(--text-muted);
		margin-bottom: 0.5rem;
	}

	.leader-since {
		color: var(--text-dim);
	}

	.leader-party {
		color: var(--text-muted);
		opacity: 0.8;
	}

	.leader-focus-topics {
		display: flex;
		flex-wrap: wrap;
		gap: 0.25rem;
		margin-bottom: 0.5rem;
	}

	.leader-focus {
		font-size: 0.5rem;
		background: rgba(68, 136, 255, 0.15);
		color: var(--info);
		padding: 0.1rem 0.35rem;
		border-radius: 3px;
		text-transform: lowercase;
	}

	.leader-news {
		border-top: 1px solid var(--border);
		padding-top: 0.5rem;
		margin-top: 0.25rem;
	}

	.leader-news-item {
		display: block;
		font-size: 0.6rem;
		color: var(--text-dim);
		text-decoration: none;
		padding: 0.25rem 0;
		line-height: 1.3;
		border-bottom: 1px solid var(--border);
	}

	.leader-news-item:last-child {
		border-bottom: none;
	}

	.leader-news-item:hover {
		color: var(--text-primary);
	}

	.empty-state {
		text-align: center;
		color: var(--text-secondary);
		font-size: 0.7rem;
		padding: 1rem;
	}
</style>



================================================
FILE: src/lib/config/analysis.ts
================================================
/**
 * Analysis configuration - correlation topics, narrative patterns, source classification
 */

export interface CorrelationTopic {
	id: string;
	patterns: RegExp[];
	category: string;
}

export interface NarrativePattern {
	id: string;
	keywords: string[];
	category: string;
	severity: 'watch' | 'emerging' | 'spreading' | 'disinfo';
}

export interface SourceTypes {
	fringe: string[];
	alternative: string[];
	mainstream: string[];
}

export const CORRELATION_TOPICS: CorrelationTopic[] = [
	{
		id: 'tariffs',
		patterns: [/tariff/i, /trade war/i, /import tax/i, /customs duty/i],
		category: 'Economy'
	},
	{
		id: 'fed-rates',
		patterns: [/federal reserve/i, /interest rate/i, /rate cut/i, /rate hike/i, /powell/i, /fomc/i],
		category: 'Economy'
	},
	{
		id: 'inflation',
		patterns: [/inflation/i, /cpi/i, /consumer price/i, /cost of living/i],
		category: 'Economy'
	},
	{
		id: 'ai-regulation',
		patterns: [/ai regulation/i, /artificial intelligence.*law/i, /ai safety/i, /ai governance/i],
		category: 'Tech'
	},
	{
		id: 'china-tensions',
		patterns: [/china.*taiwan/i, /south china sea/i, /us.*china/i, /beijing.*washington/i],
		category: 'Geopolitics'
	},
	{
		id: 'russia-ukraine',
		patterns: [/ukraine/i, /zelensky/i, /putin.*war/i, /crimea/i, /donbas/i],
		category: 'Conflict'
	},
	{
		id: 'israel-gaza',
		patterns: [/gaza/i, /hamas/i, /netanyahu/i, /israel.*attack/i, /hostage/i],
		category: 'Conflict'
	},
	{
		id: 'iran',
		patterns: [/iran.*nuclear/i, /tehran/i, /ayatollah/i, /iranian.*strike/i],
		category: 'Geopolitics'
	},
	{
		id: 'crypto',
		patterns: [/bitcoin/i, /crypto.*regulation/i, /ethereum/i, /sec.*crypto/i],
		category: 'Finance'
	},
	{
		id: 'housing',
		patterns: [/housing market/i, /mortgage rate/i, /home price/i, /real estate.*crash/i],
		category: 'Economy'
	},
	{
		id: 'layoffs',
		patterns: [/layoff/i, /job cut/i, /workforce reduction/i, /downsizing/i],
		category: 'Business'
	},
	{
		id: 'bank-crisis',
		patterns: [/bank.*fail/i, /banking crisis/i, /fdic/i, /bank run/i],
		category: 'Finance'
	},
	{
		id: 'election',
		patterns: [/election/i, /polling/i, /campaign/i, /ballot/i, /voter/i],
		category: 'Politics'
	},
	{
		id: 'immigration',
		patterns: [/immigration/i, /border.*crisis/i, /migrant/i, /deportation/i, /asylum/i],
		category: 'Politics'
	},
	{
		id: 'climate',
		patterns: [/climate change/i, /wildfire/i, /hurricane/i, /extreme weather/i, /flood/i],
		category: 'Environment'
	},
	{
		id: 'pandemic',
		patterns: [/pandemic/i, /outbreak/i, /virus.*spread/i, /who.*emergency/i, /bird flu/i],
		category: 'Health'
	},
	{
		id: 'nuclear',
		patterns: [/nuclear.*threat/i, /nuclear weapon/i, /atomic/i, /icbm/i],
		category: 'Security'
	},
	{
		id: 'supply-chain',
		patterns: [/supply chain/i, /shipping.*delay/i, /port.*congestion/i, /logistics.*crisis/i],
		category: 'Economy'
	},
	{
		id: 'big-tech',
		patterns: [/antitrust.*tech/i, /google.*monopoly/i, /meta.*lawsuit/i, /apple.*doj/i],
		category: 'Tech'
	},
	{
		id: 'deepfake',
		patterns: [/deepfake/i, /ai.*misinformation/i, /synthetic media/i],
		category: 'Tech'
	}
];

export const NARRATIVE_PATTERNS: NarrativePattern[] = [
	{
		id: 'deep-state',
		keywords: ['deep state', 'shadow government', 'permanent state'],
		category: 'Political',
		severity: 'watch'
	},
	{
		id: 'cbdc-control',
		keywords: ['cbdc control', 'digital currency surveillance', 'social credit'],
		category: 'Finance',
		severity: 'watch'
	},
	{
		id: 'wef-agenda',
		keywords: ['great reset', 'wef agenda', 'world economic forum plot'],
		category: 'Political',
		severity: 'watch'
	},
	{
		id: 'bio-weapon',
		keywords: ['lab leak', 'bioweapon', 'gain of function'],
		category: 'Health',
		severity: 'emerging'
	},
	{
		id: 'election-fraud',
		keywords: ['election fraud', 'rigged election', 'stolen election', 'mail ballot fraud'],
		category: 'Political',
		severity: 'watch'
	},
	{
		id: 'ai-doom',
		keywords: ['ai doom', 'ai extinction', 'superintelligence risk', 'agi danger'],
		category: 'Tech',
		severity: 'emerging'
	},
	{
		id: 'ai-consciousness',
		keywords: ['ai sentient', 'ai conscious', 'ai feelings', 'ai alive'],
		category: 'Tech',
		severity: 'emerging'
	},
	{
		id: 'robot-replacement',
		keywords: ['robots replacing', 'automation unemployment', 'job automation'],
		category: 'Economy',
		severity: 'spreading'
	},
	{
		id: 'china-invasion',
		keywords: ['china taiwan invasion', 'china war', 'south china sea conflict'],
		category: 'Geopolitical',
		severity: 'watch'
	},
	{
		id: 'nato-expansion',
		keywords: ['nato provocation', 'nato aggression', 'nato encirclement'],
		category: 'Geopolitical',
		severity: 'watch'
	},
	{
		id: 'dollar-collapse',
		keywords: ['dollar collapse', 'dedollarization', 'brics currency', 'petrodollar death'],
		category: 'Finance',
		severity: 'spreading'
	},
	{
		id: 'vaccine-injury',
		keywords: ['vaccine injury', 'vaccine side effect', 'vaccine death', 'turbo cancer'],
		category: 'Health',
		severity: 'watch'
	},
	{
		id: 'next-pandemic',
		keywords: ['next pandemic', 'disease x', 'bird flu pandemic'],
		category: 'Health',
		severity: 'emerging'
	},
	{
		id: 'depopulation',
		keywords: ['depopulation agenda', 'fertility crisis', 'population control'],
		category: 'Society',
		severity: 'disinfo'
	},
	{
		id: 'food-crisis',
		keywords: ['food shortage', 'engineered famine', 'food supply attack'],
		category: 'Economy',
		severity: 'emerging'
	},
	{
		id: 'energy-war',
		keywords: ['energy crisis manufactured', 'green agenda', 'energy shortage'],
		category: 'Economy',
		severity: 'spreading'
	}
];

export const SOURCE_TYPES: SourceTypes = {
	fringe: [
		'zerohedge',
		'infowars',
		'naturalnews',
		'gateway',
		'breitbart',
		'epoch',
		'revolver',
		'dailycaller'
	],
	alternative: ['substack', 'rumble', 'bitchute', 'telegram', 'gab', 'gettr', 'truth social'],
	mainstream: [
		'reuters',
		'ap news',
		'bbc',
		'cnn',
		'nytimes',
		'wsj',
		'wapo',
		'guardian',
		'abc',
		'nbc',
		'cbs',
		'fox'
	]
};

// Main character patterns for tracking prominent figures
export interface PersonPattern {
	pattern: RegExp;
	name: string;
}

export const PERSON_PATTERNS: PersonPattern[] = [
	{ pattern: /\btrump\b/gi, name: 'Trump' },
	{ pattern: /\bbiden\b/gi, name: 'Biden' },
	{ pattern: /\belon\b|\bmusk\b/gi, name: 'Elon Musk' },
	{ pattern: /\bputin\b/gi, name: 'Putin' },
	{ pattern: /\bzelensky\b/gi, name: 'Zelensky' },
	{ pattern: /\bxi\s*jinping\b|\bxi\b/gi, name: 'Xi Jinping' },
	{ pattern: /\bnetanyahu\b/gi, name: 'Netanyahu' },
	{ pattern: /\bsam\s*altman\b/gi, name: 'Sam Altman' },
	{ pattern: /\bmark\s*zuckerberg\b|\bzuckerberg\b/gi, name: 'Zuckerberg' },
	{ pattern: /\bjeff\s*bezos\b|\bbezos\b/gi, name: 'Bezos' },
	{ pattern: /\btim\s*cook\b/gi, name: 'Tim Cook' },
	{ pattern: /\bsatya\s*nadella\b|\bnadella\b/gi, name: 'Satya Nadella' },
	{ pattern: /\bsundar\s*pichai\b|\bpichai\b/gi, name: 'Sundar Pichai' },
	{ pattern: /\bwarren\s*buffett\b|\bbuffett\b/gi, name: 'Warren Buffett' },
	{ pattern: /\bjanet\s*yellen\b|\byellen\b/gi, name: 'Janet Yellen' },
	{ pattern: /\bjerome\s*powell\b|\bpowell\b/gi, name: 'Jerome Powell' },
	{ pattern: /\bkamala\s*harris\b|\bharris\b/gi, name: 'Kamala Harris' },
	{ pattern: /\bnancy\s*pelosi\b|\bpelosi\b/gi, name: 'Nancy Pelosi' },
	{ pattern: /\bjensen\s*huang\b|\bhuang\b/gi, name: 'Jensen Huang' },
	{ pattern: /\bdario\s*amodei\b|\bamodei\b/gi, name: 'Dario Amodei' }
];



================================================
FILE: src/lib/config/api.ts
================================================
/**
 * API Configuration
 */

import { browser } from '$app/environment';

/**
 * Finnhub API key
 * Get your free key at: https://finnhub.io/
 * Free tier: 60 calls/minute
 */
export const FINNHUB_API_KEY = browser
	? (import.meta.env?.VITE_FINNHUB_API_KEY ?? '')
	: (process.env.VITE_FINNHUB_API_KEY ?? '');

export const FINNHUB_BASE_URL = 'https://finnhub.io/api/v1';

/**
 * FRED API key (St. Louis Fed)
 * Get your free key at: https://fred.stlouisfed.org/docs/api/api_key.html
 * Free tier: Unlimited requests
 */
export const FRED_API_KEY = browser
	? (import.meta.env?.VITE_FRED_API_KEY ?? '')
	: (process.env.VITE_FRED_API_KEY ?? '');

export const FRED_BASE_URL = 'https://api.stlouisfed.org/fred';

/**
 * Check if we're in development mode
 * Uses import.meta.env which is available in both browser and test environments
 */
const isDev = browser ? (import.meta.env?.DEV ?? false) : false;

/**
 * CORS proxy URLs for external API requests
 * Primary: Custom Cloudflare Worker (faster, dedicated)
 * Fallback: corsproxy.io (public, may rate limit)
 */
export const CORS_PROXIES = {
	primary: 'https://situation-monitor-proxy.seanthielen-e.workers.dev/?url=',
	fallback: 'https://corsproxy.io/?url='
} as const;

// Default export for backward compatibility
export const CORS_PROXY_URL = CORS_PROXIES.fallback;

/**
 * Fetch with CORS proxy fallback
 * Tries primary proxy first, falls back to secondary on failure
 */
export async function fetchWithProxy(url: string): Promise<Response> {
	const encodedUrl = encodeURIComponent(url);

	// Try primary proxy first
	try {
		const response = await fetch(CORS_PROXIES.primary + encodedUrl);
		if (response.ok) {
			return response;
		}
		// If we get an error response, try fallback
		logger.warn('API', `Primary proxy failed (${response.status}), trying fallback`);
	} catch (error) {
		logger.warn('API', 'Primary proxy error, trying fallback:', error);
	}

	// Fallback to secondary proxy
	return fetch(CORS_PROXIES.fallback + encodedUrl);
}

/**
 * API request delays (ms) to avoid rate limiting
 */
export const API_DELAYS = {
	betweenCategories: 500,
	betweenRetries: 1000
} as const;

/**
 * Cache TTLs (ms)
 */
export const CACHE_TTLS = {
	weather: 10 * 60 * 1000, // 10 minutes
	news: 5 * 60 * 1000, // 5 minutes
	markets: 60 * 1000, // 1 minute
	default: 5 * 60 * 1000 // 5 minutes
} as const;

/**
 * Debug/logging configuration
 */
export const DEBUG = {
	enabled: isDev,
	logApiCalls: isDev,
	logCacheHits: false
} as const;

/**
 * Conditional logger - only logs in development
 */
export const logger = {
	log: (prefix: string, ...args: unknown[]) => {
		if (DEBUG.logApiCalls) {
			console.log(`[${prefix}]`, ...args);
		}
	},
	warn: (prefix: string, ...args: unknown[]) => {
		console.warn(`[${prefix}]`, ...args);
	},
	error: (prefix: string, ...args: unknown[]) => {
		console.error(`[${prefix}]`, ...args);
	}
};



================================================
FILE: src/lib/config/feeds.ts
================================================
/**
 * RSS feed and news source configuration
 */

import type { NewsCategory } from '$lib/types';

export interface FeedSource {
	name: string;
	url: string;
}

export interface IntelSource extends FeedSource {
	type: 'think-tank' | 'defense' | 'regional' | 'osint' | 'govt' | 'cyber';
	topics: string[];
	region?: string;
}

export const FEEDS: Record<NewsCategory, FeedSource[]> = {
	politics: [
		{ name: 'BBC World', url: 'https://feeds.bbci.co.uk/news/world/rss.xml' },
		{ name: 'NPR News', url: 'https://feeds.npr.org/1001/rss.xml' },
		{ name: 'Guardian World', url: 'https://www.theguardian.com/world/rss' },
		{ name: 'NYT World', url: 'https://rss.nytimes.com/services/xml/rss/nyt/World.xml' }
	],
	tech: [
		{ name: 'Hacker News', url: 'https://hnrss.org/frontpage' },
		{ name: 'Ars Technica', url: 'https://feeds.arstechnica.com/arstechnica/technology-lab' },
		{ name: 'The Verge', url: 'https://www.theverge.com/rss/index.xml' },
		{ name: 'MIT Tech Review', url: 'https://www.technologyreview.com/feed/' },
		{ name: 'ArXiv AI', url: 'https://rss.arxiv.org/rss/cs.AI' },
		{ name: 'OpenAI Blog', url: 'https://openai.com/news/rss.xml' }
	],
	finance: [
		{ name: 'CNBC', url: 'https://www.cnbc.com/id/100003114/device/rss/rss.html' },
		{ name: 'MarketWatch', url: 'https://feeds.marketwatch.com/marketwatch/topstories' },
		{ name: 'Yahoo Finance', url: 'https://finance.yahoo.com/news/rssindex' },
		{ name: 'BBC Business', url: 'https://feeds.bbci.co.uk/news/business/rss.xml' },
		{ name: 'FT', url: 'https://www.ft.com/rss/home' }
	],
	gov: [
		{ name: 'White House', url: 'https://www.whitehouse.gov/news/feed/' },
		{ name: 'Federal Reserve', url: 'https://www.federalreserve.gov/feeds/press_all.xml' },
		{ name: 'SEC Announcements', url: 'https://www.sec.gov/news/pressreleases.rss' },
		{
			name: 'DoD News',
			url: 'https://www.defense.gov/DesktopModules/ArticleCS/RSS.ashx?max=10&ContentType=1&Site=945'
		}
	],
	ai: [
		{ name: 'OpenAI Blog', url: 'https://openai.com/news/rss.xml' },
		{ name: 'ArXiv AI', url: 'https://rss.arxiv.org/rss/cs.AI' }
	],
	intel: [
		{ name: 'CSIS', url: 'https://www.csis.org/analysis/feed' },
		{ name: 'Brookings', url: 'https://www.brookings.edu/feed/' }
	]
};

export const INTEL_SOURCES: IntelSource[] = [
	{
		name: 'CSIS',
		url: 'https://www.csis.org/analysis/feed',
		type: 'think-tank',
		topics: ['defense', 'geopolitics']
	},
	{
		name: 'Brookings',
		url: 'https://www.brookings.edu/feed/',
		type: 'think-tank',
		topics: ['policy', 'geopolitics']
	},
	{
		name: 'CFR',
		url: 'https://www.cfr.org/rss.xml',
		type: 'think-tank',
		topics: ['foreign-policy']
	},
	{
		name: 'Defense One',
		url: 'https://www.defenseone.com/rss/all/',
		type: 'defense',
		topics: ['military', 'defense']
	},
	{
		name: 'War on Rocks',
		url: 'https://warontherocks.com/feed/',
		type: 'defense',
		topics: ['military', 'strategy']
	},
	{
		name: 'Breaking Defense',
		url: 'https://breakingdefense.com/feed/',
		type: 'defense',
		topics: ['military', 'defense']
	},
	{
		name: 'The Drive War Zone',
		url: 'https://www.thedrive.com/the-war-zone/feed',
		type: 'defense',
		topics: ['military']
	},
	{
		name: 'The Diplomat',
		url: 'https://thediplomat.com/feed/',
		type: 'regional',
		topics: ['asia-pacific'],
		region: 'APAC'
	},
	{
		name: 'Al-Monitor',
		url: 'https://www.al-monitor.com/rss',
		type: 'regional',
		topics: ['middle-east'],
		region: 'MENA'
	},
	{
		name: 'Bellingcat',
		url: 'https://www.bellingcat.com/feed/',
		type: 'osint',
		topics: ['investigation', 'osint']
	},
	{
		name: 'CISA Alerts',
		url: 'https://www.cisa.gov/uscert/ncas/alerts.xml',
		type: 'cyber',
		topics: ['cyber', 'security']
	},
	{
		name: 'Krebs Security',
		url: 'https://krebsonsecurity.com/feed/',
		type: 'cyber',
		topics: ['cyber', 'security']
	}
];



================================================
FILE: src/lib/config/index.ts
================================================
/**
 * Configuration exports
 */

// Panel configuration
export {
	PANELS,
	NON_DRAGGABLE_PANELS,
	MAP_ZOOM_MIN,
	MAP_ZOOM_MAX,
	MAP_ZOOM_STEP,
	type PanelConfig,
	type PanelId
} from './panels';

// Feed configuration
export { FEEDS, INTEL_SOURCES, type FeedSource, type IntelSource } from './feeds';

// Keyword configuration
export {
	ALERT_KEYWORDS,
	REGION_KEYWORDS,
	TOPIC_KEYWORDS,
	containsAlertKeyword,
	detectRegion,
	detectTopics,
	type AlertKeyword
} from './keywords';

// Market configuration
export {
	SECTORS,
	COMMODITIES,
	INDICES,
	CRYPTO,
	type SectorConfig,
	type CommodityConfig
} from './markets';

// Analysis configuration
export {
	CORRELATION_TOPICS,
	NARRATIVE_PATTERNS,
	SOURCE_TYPES,
	PERSON_PATTERNS,
	type CorrelationTopic,
	type NarrativePattern,
	type SourceTypes,
	type PersonPattern
} from './analysis';

// Map configuration
export {
	HOTSPOTS,
	CONFLICT_ZONES,
	CHOKEPOINTS,
	CABLE_LANDINGS,
	NUCLEAR_SITES,
	MILITARY_BASES,
	OCEANS,
	SANCTIONED_COUNTRY_IDS,
	THREAT_COLORS,
	WEATHER_CODES,
	type Hotspot,
	type ConflictZone,
	type Chokepoint,
	type CableLanding,
	type NuclearSite,
	type MilitaryBase,
	type Ocean
} from './map';

// Preset configuration
export {
	PRESETS,
	PRESET_ORDER,
	ONBOARDING_STORAGE_KEY,
	PRESET_STORAGE_KEY,
	type Preset
} from './presets';

// API configuration
export { CORS_PROXY_URL, API_DELAYS, CACHE_TTLS, DEBUG, logger, FINNHUB_API_KEY, FINNHUB_BASE_URL } from './api';

// World leaders configuration
export { WORLD_LEADERS } from './leaders';



================================================
FILE: src/lib/config/keywords.ts
================================================
/**
 * Keyword configuration for alerts and categorization
 */

export const ALERT_KEYWORDS = [
	'war',
	'invasion',
	'military',
	'nuclear',
	'sanctions',
	'missile',
	'attack',
	'troops',
	'conflict',
	'strike',
	'bomb',
	'casualties',
	'ceasefire',
	'treaty',
	'nato',
	'coup',
	'martial law',
	'emergency',
	'assassination',
	'terrorist',
	'hostage',
	'evacuation'
] as const;

export type AlertKeyword = (typeof ALERT_KEYWORDS)[number];

export const REGION_KEYWORDS: Record<string, string[]> = {
	EUROPE: [
		'nato',
		'eu',
		'european',
		'ukraine',
		'russia',
		'germany',
		'france',
		'uk',
		'britain',
		'poland'
	],
	MENA: [
		'iran',
		'israel',
		'saudi',
		'syria',
		'iraq',
		'gaza',
		'lebanon',
		'yemen',
		'houthi',
		'middle east'
	],
	APAC: [
		'china',
		'taiwan',
		'japan',
		'korea',
		'indo-pacific',
		'south china sea',
		'asean',
		'philippines'
	],
	AMERICAS: ['us', 'america', 'canada', 'mexico', 'brazil', 'venezuela', 'latin'],
	AFRICA: ['africa', 'sahel', 'niger', 'sudan', 'ethiopia', 'somalia']
};

export const TOPIC_KEYWORDS: Record<string, string[]> = {
	CYBER: ['cyber', 'hack', 'ransomware', 'malware', 'breach', 'apt', 'vulnerability'],
	NUCLEAR: ['nuclear', 'icbm', 'warhead', 'nonproliferation', 'uranium', 'plutonium'],
	CONFLICT: ['war', 'military', 'troops', 'invasion', 'strike', 'missile', 'combat', 'offensive'],
	INTEL: ['intelligence', 'espionage', 'spy', 'cia', 'mossad', 'fsb', 'covert'],
	DEFENSE: ['pentagon', 'dod', 'defense', 'military', 'army', 'navy', 'air force'],
	DIPLO: ['diplomat', 'embassy', 'treaty', 'sanctions', 'talks', 'summit', 'bilateral']
};

/**
 * Check if a headline contains alert keywords
 */
export function containsAlertKeyword(text: string): { isAlert: boolean; keyword?: string } {
	const lowerText = text.toLowerCase();
	for (const keyword of ALERT_KEYWORDS) {
		if (lowerText.includes(keyword)) {
			return { isAlert: true, keyword };
		}
	}
	return { isAlert: false };
}

/**
 * Detect region from text
 */
export function detectRegion(text: string): string | null {
	const lowerText = text.toLowerCase();
	for (const [region, keywords] of Object.entries(REGION_KEYWORDS)) {
		if (keywords.some((k) => lowerText.includes(k))) {
			return region;
		}
	}
	return null;
}

/**
 * Detect topics from text
 */
export function detectTopics(text: string): string[] {
	const lowerText = text.toLowerCase();
	const detected: string[] = [];
	for (const [topic, keywords] of Object.entries(TOPIC_KEYWORDS)) {
		if (keywords.some((k) => lowerText.includes(k))) {
			detected.push(topic);
		}
	}
	return detected;
}



================================================
FILE: src/lib/config/leaders.ts
================================================
/**
 * World Leaders configuration for tracking
 */

import type { WorldLeader } from '$lib/types';

export const WORLD_LEADERS: WorldLeader[] = [
	// United States
	{
		id: 'trump',
		name: 'Donald Trump',
		title: 'President',
		country: 'United States',
		flag: '🇺🇸',
		keywords: ['trump', 'potus', 'white house'],
		since: 'Jan 2025',
		party: 'Republican',
		focus: ['tariffs', 'immigration', 'deregulation']
	},
	{
		id: 'vance',
		name: 'JD Vance',
		title: 'Vice President',
		country: 'United States',
		flag: '🇺🇸',
		keywords: ['jd vance', 'vice president vance'],
		since: 'Jan 2025',
		party: 'Republican'
	},

	// China
	{
		id: 'xi',
		name: 'Xi Jinping',
		title: 'President',
		country: 'China',
		flag: '🇨🇳',
		keywords: ['xi jinping', 'xi', 'chinese president'],
		since: 'Mar 2013',
		party: 'CCP',
		focus: ['taiwan', 'belt and road', 'tech dominance']
	},

	// Russia
	{
		id: 'putin',
		name: 'Vladimir Putin',
		title: 'President',
		country: 'Russia',
		flag: '🇷🇺',
		keywords: ['putin', 'kremlin', 'russian president'],
		since: 'May 2012',
		party: 'United Russia',
		focus: ['ukraine war', 'nato expansion', 'energy']
	},

	// Europe
	{
		id: 'starmer',
		name: 'Keir Starmer',
		title: 'Prime Minister',
		country: 'United Kingdom',
		flag: '🇬🇧',
		keywords: ['starmer', 'uk pm', 'british prime minister'],
		since: 'Jul 2024',
		party: 'Labour'
	},
	{
		id: 'macron',
		name: 'Emmanuel Macron',
		title: 'President',
		country: 'France',
		flag: '🇫🇷',
		keywords: ['macron', 'french president', 'elysee'],
		since: 'May 2017',
		party: 'Renaissance'
	},
	{
		id: 'scholz',
		name: 'Olaf Scholz',
		title: 'Chancellor',
		country: 'Germany',
		flag: '🇩🇪',
		keywords: ['scholz', 'german chancellor', 'berlin'],
		since: 'Dec 2021',
		party: 'SPD'
	},
	{
		id: 'meloni',
		name: 'Giorgia Meloni',
		title: 'Prime Minister',
		country: 'Italy',
		flag: '🇮🇹',
		keywords: ['meloni', 'italian pm', 'italy prime minister'],
		since: 'Oct 2022',
		party: 'Brothers of Italy'
	},

	// Middle East
	{
		id: 'netanyahu',
		name: 'Benjamin Netanyahu',
		title: 'Prime Minister',
		country: 'Israel',
		flag: '🇮🇱',
		keywords: ['netanyahu', 'bibi', 'israeli pm'],
		since: 'Dec 2022',
		party: 'Likud',
		focus: ['gaza', 'iran', 'judicial reform']
	},
	{
		id: 'mbs',
		name: 'Mohammed bin Salman',
		title: 'Crown Prince',
		country: 'Saudi Arabia',
		flag: '🇸🇦',
		keywords: ['mbs', 'saudi crown prince', 'bin salman'],
		since: 'Jun 2017',
		party: 'Royal Family',
		focus: ['vision 2030', 'oil', 'regional influence']
	},
	{
		id: 'khamenei',
		name: 'Ali Khamenei',
		title: 'Supreme Leader',
		country: 'Iran',
		flag: '🇮🇷',
		keywords: ['khamenei', 'supreme leader', 'ayatollah'],
		since: 'Jun 1989',
		party: 'Islamic Republic',
		focus: ['nuclear program', 'proxies', 'sanctions']
	},

	// Asia-Pacific
	{
		id: 'modi',
		name: 'Narendra Modi',
		title: 'Prime Minister',
		country: 'India',
		flag: '🇮🇳',
		keywords: ['modi', 'indian pm', 'india prime minister'],
		since: 'May 2014',
		party: 'BJP',
		focus: ['economy', 'china border', 'technology']
	},
	{
		id: 'kim',
		name: 'Kim Jong Un',
		title: 'Supreme Leader',
		country: 'North Korea',
		flag: '🇰🇵',
		keywords: ['kim jong un', 'north korea', 'pyongyang'],
		since: 'Dec 2011',
		party: 'Workers Party',
		focus: ['nuclear', 'missiles', 'russia alliance']
	},
	{
		id: 'ishiba',
		name: 'Shigeru Ishiba',
		title: 'Prime Minister',
		country: 'Japan',
		flag: '🇯🇵',
		keywords: ['ishiba', 'japanese pm', 'japan prime minister'],
		since: 'Oct 2024',
		party: 'LDP',
		focus: ['defense', 'china', 'us alliance']
	},
	{
		id: 'lai',
		name: 'Lai Ching-te',
		title: 'President',
		country: 'Taiwan',
		flag: '🇹🇼',
		keywords: ['lai ching-te', 'taiwan president', 'taipei'],
		since: 'May 2024',
		party: 'DPP',
		focus: ['china relations', 'defense', 'semiconductors']
	},

	// Ukraine
	{
		id: 'zelensky',
		name: 'Volodymyr Zelensky',
		title: 'President',
		country: 'Ukraine',
		flag: '🇺🇦',
		keywords: ['zelensky', 'ukraine president', 'kyiv'],
		since: 'May 2019',
		party: 'Servant of the People',
		focus: ['war', 'western aid', 'nato membership']
	},

	// Latin America
	{
		id: 'milei',
		name: 'Javier Milei',
		title: 'President',
		country: 'Argentina',
		flag: '🇦🇷',
		keywords: ['milei', 'argentina president', 'buenos aires'],
		since: 'Dec 2023',
		party: 'La Libertad Avanza',
		focus: ['dollarization', 'spending cuts', 'deregulation']
	},
	{
		id: 'lula',
		name: 'Luiz Inácio Lula da Silva',
		title: 'President',
		country: 'Brazil',
		flag: '🇧🇷',
		keywords: ['lula', 'brazil president', 'brasilia'],
		since: 'Jan 2023',
		party: 'PT',
		focus: ['amazon', 'social programs', 'brics']
	},

	// Canada
	{
		id: 'carney',
		name: 'Mark Carney',
		title: 'Prime Minister',
		country: 'Canada',
		flag: '🇨🇦',
		keywords: ['carney', 'canadian pm', 'canada prime minister', 'ottawa'],
		since: 'Mar 2025',
		party: 'Liberal',
		focus: ['tariffs', 'us relations', 'economy']
	}
];



================================================
FILE: src/lib/config/map.ts
================================================
// Map configuration - hotspots, conflict zones, and strategic locations

export interface Hotspot {
	name: string;
	lat: number;
	lon: number;
	level: 'critical' | 'high' | 'elevated' | 'low';
	desc: string;
}

export interface ConflictZone {
	name: string;
	coords: [number, number][];
	color: string;
}

export interface Chokepoint {
	name: string;
	lat: number;
	lon: number;
	desc: string;
}

export interface CableLanding {
	name: string;
	lat: number;
	lon: number;
	desc: string;
}

export interface NuclearSite {
	name: string;
	lat: number;
	lon: number;
	desc: string;
}

export interface MilitaryBase {
	name: string;
	lat: number;
	lon: number;
	desc: string;
}

export interface Ocean {
	name: string;
	lat: number;
	lon: number;
}

export const THREAT_COLORS = {
	critical: '#ff0000',
	high: '#ff4444',
	elevated: '#ffcc00',
	low: '#00ff88'
} as const;

export const SANCTIONED_COUNTRY_IDS = [
	364, // Iran
	408, // North Korea
	760, // Syria
	862, // Venezuela
	112, // Belarus
	643, // Russia
	728, // South Sudan
	729 // Sudan
];

export const HOTSPOTS: Hotspot[] = [
	{
		name: 'DC',
		lat: 38.9,
		lon: -77.0,
		level: 'low',
		desc: 'Washington DC — US political center, White House, Pentagon, Capitol'
	},
	{
		name: 'Moscow',
		lat: 55.75,
		lon: 37.6,
		level: 'elevated',
		desc: 'Moscow — Kremlin, Russian military command, sanctions hub'
	},
	{
		name: 'Beijing',
		lat: 39.9,
		lon: 116.4,
		level: 'elevated',
		desc: 'Beijing — CCP headquarters, US-China tensions, tech rivalry'
	},
	{
		name: 'Kyiv',
		lat: 50.45,
		lon: 30.5,
		level: 'high',
		desc: 'Kyiv — Active conflict zone, Russian invasion ongoing'
	},
	{
		name: 'Taipei',
		lat: 25.03,
		lon: 121.5,
		level: 'elevated',
		desc: 'Taipei — Taiwan Strait tensions, TSMC, China threat'
	},
	{
		name: 'Tehran',
		lat: 35.7,
		lon: 51.4,
		level: 'critical',
		desc: 'Tehran — ACTIVE UPRISING: 200+ cities, 26 provinces. Revolution protests, regime instability, nuclear program'
	},
	{
		name: 'Tel Aviv',
		lat: 32.07,
		lon: 34.78,
		level: 'high',
		desc: 'Tel Aviv — Israel-Gaza conflict, active military operations'
	},
	{
		name: 'London',
		lat: 51.5,
		lon: -0.12,
		level: 'low',
		desc: 'London — Financial center, Five Eyes, NATO ally'
	},
	{
		name: 'Brussels',
		lat: 50.85,
		lon: 4.35,
		level: 'low',
		desc: 'Brussels — EU/NATO headquarters, European policy'
	},
	{
		name: 'Pyongyang',
		lat: 39.03,
		lon: 125.75,
		level: 'elevated',
		desc: 'Pyongyang — North Korea nuclear threat, missile tests'
	},
	{
		name: 'Riyadh',
		lat: 24.7,
		lon: 46.7,
		level: 'elevated',
		desc: 'Riyadh — Saudi oil, OPEC+, Yemen conflict, regional power'
	},
	{
		name: 'Delhi',
		lat: 28.6,
		lon: 77.2,
		level: 'low',
		desc: 'Delhi — India rising power, China border tensions'
	},
	{
		name: 'Singapore',
		lat: 1.35,
		lon: 103.82,
		level: 'low',
		desc: 'Singapore — Shipping chokepoint, Asian finance hub'
	},
	{
		name: 'Tokyo',
		lat: 35.68,
		lon: 139.76,
		level: 'low',
		desc: 'Tokyo — US ally, regional security, economic power'
	},
	{
		name: 'Caracas',
		lat: 10.5,
		lon: -66.9,
		level: 'high',
		desc: 'Caracas — Venezuela crisis, Maduro regime, US sanctions, humanitarian emergency'
	},
	{
		name: 'Nuuk',
		lat: 64.18,
		lon: -51.72,
		level: 'elevated',
		desc: 'Nuuk — Greenland, US acquisition interest, Arctic strategy, Denmark tensions'
	}
];

export const CONFLICT_ZONES: ConflictZone[] = [
	{
		name: 'Ukraine',
		coords: [
			[30, 52],
			[40, 52],
			[40, 45],
			[30, 45],
			[30, 52]
		],
		color: '#ff4444'
	},
	{
		name: 'Gaza',
		coords: [
			[34, 32],
			[35, 32],
			[35, 31],
			[34, 31],
			[34, 32]
		],
		color: '#ff4444'
	},
	{
		name: 'Taiwan Strait',
		coords: [
			[117, 28],
			[122, 28],
			[122, 22],
			[117, 22],
			[117, 28]
		],
		color: '#ffaa00'
	},
	{
		name: 'Yemen',
		coords: [
			[42, 19],
			[54, 19],
			[54, 12],
			[42, 12],
			[42, 19]
		],
		color: '#ff6644'
	},
	{
		name: 'Sudan',
		coords: [
			[22, 23],
			[38, 23],
			[38, 8],
			[22, 8],
			[22, 23]
		],
		color: '#ff6644'
	},
	{
		name: 'Myanmar',
		coords: [
			[92, 28],
			[101, 28],
			[101, 10],
			[92, 10],
			[92, 28]
		],
		color: '#ff8844'
	}
];

export const CHOKEPOINTS: Chokepoint[] = [
	{
		name: 'Suez',
		lat: 30.0,
		lon: 32.5,
		desc: 'Suez Canal — 12% of global trade, Europe-Asia route'
	},
	{
		name: 'Panama',
		lat: 9.1,
		lon: -79.7,
		desc: 'Panama Canal — Americas transit, Pacific-Atlantic link'
	},
	{
		name: 'Hormuz',
		lat: 26.5,
		lon: 56.5,
		desc: 'Strait of Hormuz — 21% of global oil, Persian Gulf exit'
	},
	{
		name: 'Malacca',
		lat: 2.5,
		lon: 101.0,
		desc: 'Strait of Malacca — 25% of global trade, China supply line'
	},
	{
		name: 'Bab el-M',
		lat: 12.5,
		lon: 43.3,
		desc: 'Bab el-Mandeb — Red Sea gateway, Houthi threat zone'
	},
	{ name: 'Gibraltar', lat: 36.0, lon: -5.5, desc: 'Strait of Gibraltar — Mediterranean access' },
	{
		name: 'Bosporus',
		lat: 41.1,
		lon: 29.0,
		desc: 'Bosporus Strait — Black Sea access, Russia exports'
	}
];

export const CABLE_LANDINGS: CableLanding[] = [
	{ name: 'NYC', lat: 40.7, lon: -74.0, desc: 'New York — Transatlantic hub, 10+ cables' },
	{ name: 'Cornwall', lat: 50.1, lon: -5.5, desc: 'Cornwall UK — Europe-Americas gateway' },
	{ name: 'Marseille', lat: 43.3, lon: 5.4, desc: 'Marseille — Mediterranean hub, SEA-ME-WE' },
	{ name: 'Mumbai', lat: 19.1, lon: 72.9, desc: 'Mumbai — India gateway, 10+ cables' },
	{ name: 'Singapore', lat: 1.3, lon: 103.8, desc: 'Singapore — Asia-Pacific nexus' },
	{ name: 'Hong Kong', lat: 22.3, lon: 114.2, desc: 'Hong Kong — China connectivity hub' },
	{ name: 'Tokyo', lat: 35.5, lon: 139.8, desc: 'Tokyo — Trans-Pacific terminus' },
	{ name: 'Sydney', lat: -33.9, lon: 151.2, desc: 'Sydney — Australia/Pacific hub' },
	{ name: 'LA', lat: 33.7, lon: -118.2, desc: 'Los Angeles — Pacific gateway' },
	{ name: 'Miami', lat: 25.8, lon: -80.2, desc: 'Miami — Americas/Caribbean hub' }
];

export const NUCLEAR_SITES: NuclearSite[] = [
	{ name: 'Natanz', lat: 33.7, lon: 51.7, desc: 'Natanz — Iran uranium enrichment' },
	{ name: 'Yongbyon', lat: 39.8, lon: 125.8, desc: 'Yongbyon — North Korea nuclear complex' },
	{ name: 'Dimona', lat: 31.0, lon: 35.1, desc: 'Dimona — Israel nuclear facility' },
	{ name: 'Bushehr', lat: 28.8, lon: 50.9, desc: 'Bushehr — Iran nuclear power plant' },
	{
		name: 'Zaporizhzhia',
		lat: 47.5,
		lon: 34.6,
		desc: 'Zaporizhzhia — Europe largest NPP, conflict zone'
	},
	{ name: 'Chernobyl', lat: 51.4, lon: 30.1, desc: 'Chernobyl — Exclusion zone, occupied 2022' },
	{ name: 'Fukushima', lat: 37.4, lon: 141.0, desc: 'Fukushima — Decommissioning site' }
];

export const MILITARY_BASES: MilitaryBase[] = [
	{ name: 'Ramstein', lat: 49.4, lon: 7.6, desc: 'Ramstein — US Air Force, NATO hub Germany' },
	{
		name: 'Diego Garcia',
		lat: -7.3,
		lon: 72.4,
		desc: 'Diego Garcia — US/UK Indian Ocean base'
	},
	{
		name: 'Okinawa',
		lat: 26.5,
		lon: 127.9,
		desc: 'Okinawa — US Forces Japan, Pacific presence'
	},
	{ name: 'Guam', lat: 13.5, lon: 144.8, desc: 'Guam — US Pacific Command, bomber base' },
	{
		name: 'Djibouti',
		lat: 11.5,
		lon: 43.1,
		desc: 'Djibouti — US/China/France bases, Horn of Africa'
	},
	{ name: 'Qatar', lat: 25.1, lon: 51.3, desc: 'Al Udeid — US CENTCOM forward HQ' },
	{
		name: 'Kaliningrad',
		lat: 54.7,
		lon: 20.5,
		desc: 'Kaliningrad — Russian Baltic exclave, missiles'
	},
	{ name: 'Sevastopol', lat: 44.6, lon: 33.5, desc: 'Sevastopol — Russian Black Sea Fleet' },
	{
		name: 'Hainan',
		lat: 18.2,
		lon: 109.5,
		desc: 'Hainan — Chinese submarine base, South China Sea'
	}
];

export const OCEANS: Ocean[] = [
	{ name: 'ATLANTIC', lat: 25, lon: -40 },
	{ name: 'PACIFIC', lat: 0, lon: -150 },
	{ name: 'INDIAN', lat: -20, lon: 75 },
	{ name: 'ARCTIC', lat: 75, lon: 0 },
	{ name: 'SOUTHERN', lat: -60, lon: 0 }
];

export const WEATHER_CODES: Record<number, string> = {
	0: '☀️ Clear',
	1: '🌤️ Mostly clear',
	2: '⛅ Partly cloudy',
	3: '☁️ Overcast',
	45: '🌫️ Fog',
	48: '🌫️ Fog',
	51: '🌧️ Drizzle',
	53: '🌧️ Drizzle',
	55: '🌧️ Drizzle',
	61: '🌧️ Rain',
	63: '🌧️ Rain',
	65: '🌧️ Heavy rain',
	71: '🌨️ Snow',
	73: '🌨️ Snow',
	75: '🌨️ Heavy snow',
	77: '🌨️ Snow',
	80: '🌧️ Showers',
	81: '🌧️ Showers',
	82: '⛈️ Heavy showers',
	85: '🌨️ Snow',
	86: '🌨️ Snow',
	95: '⛈️ Thunderstorm',
	96: '⛈️ Thunderstorm',
	99: '⛈️ Thunderstorm'
};



================================================
FILE: src/lib/config/markets.ts
================================================
/**
 * Market configuration - sectors, commodities, stocks
 */

export interface SectorConfig {
	symbol: string;
	name: string;
}

export interface CommodityConfig {
	symbol: string;
	name: string;
	display: string;
}

export const SECTORS: SectorConfig[] = [
	{ symbol: 'XLK', name: 'Tech' },
	{ symbol: 'XLF', name: 'Finance' },
	{ symbol: 'XLE', name: 'Energy' },
	{ symbol: 'XLV', name: 'Health' },
	{ symbol: 'XLY', name: 'Consumer' },
	{ symbol: 'XLI', name: 'Industrial' },
	{ symbol: 'XLP', name: 'Staples' },
	{ symbol: 'XLU', name: 'Utilities' },
	{ symbol: 'XLB', name: 'Materials' },
	{ symbol: 'XLRE', name: 'Real Est' },
	{ symbol: 'XLC', name: 'Comms' },
	{ symbol: 'SMH', name: 'Semis' }
];

export const COMMODITIES: CommodityConfig[] = [
	{ symbol: '^VIX', name: 'VIX', display: 'VIX' },
	{ symbol: 'GC=F', name: 'Gold', display: 'GOLD' },
	{ symbol: 'CL=F', name: 'Crude Oil', display: 'OIL' },
	{ symbol: 'NG=F', name: 'Natural Gas', display: 'NATGAS' },
	{ symbol: 'SI=F', name: 'Silver', display: 'SILVER' },
	{ symbol: 'HG=F', name: 'Copper', display: 'COPPER' }
];

// Major stock indices
export const INDICES = [
	{ symbol: '^DJI', name: 'Dow Jones', display: 'DOW' },
	{ symbol: '^GSPC', name: 'S&P 500', display: 'S&P' },
	{ symbol: '^IXIC', name: 'NASDAQ', display: 'NDQ' },
	{ symbol: '^RUT', name: 'Russell 2000', display: 'RUT' }
];

// Crypto assets tracked
export const CRYPTO = [
	{ id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin' },
	{ id: 'ethereum', symbol: 'ETH', name: 'Ethereum' },
	{ id: 'solana', symbol: 'SOL', name: 'Solana' }
];



================================================
FILE: src/lib/config/panels.ts
================================================
/**
 * Panel configuration
 */

export interface PanelConfig {
	name: string;
	priority: 1 | 2 | 3;
}

export type PanelId =
	| 'map'
	| 'politics'
	| 'tech'
	| 'finance'
	| 'gov'
	| 'heatmap'
	| 'markets'
	| 'monitors'
	| 'commodities'
	| 'crypto'
	| 'polymarket'
	| 'whales'
	| 'mainchar'
	| 'printer'
	| 'contracts'
	| 'ai'
	| 'layoffs'
	| 'venezuela'
	| 'greenland'
	| 'iran'
	| 'leaders'
	| 'intel'
	| 'correlation'
	| 'narrative'
	| 'fed';

export const PANELS: Record<PanelId, PanelConfig> = {
	map: { name: 'Global Map', priority: 1 },
	politics: { name: 'World / Geopolitical', priority: 1 },
	tech: { name: 'Technology / AI', priority: 1 },
	finance: { name: 'Financial', priority: 1 },
	gov: { name: 'Government / Policy', priority: 2 },
	heatmap: { name: 'Sector Heatmap', priority: 1 },
	markets: { name: 'Markets', priority: 1 },
	monitors: { name: 'My Monitors', priority: 1 },
	commodities: { name: 'Commodities / VIX', priority: 2 },
	crypto: { name: 'Crypto', priority: 2 },
	polymarket: { name: 'Polymarket', priority: 2 },
	whales: { name: 'Whale Watch', priority: 3 },
	mainchar: { name: 'Main Character', priority: 2 },
	printer: { name: 'Money Printer', priority: 2 },
	contracts: { name: 'Gov Contracts', priority: 3 },
	ai: { name: 'AI Arms Race', priority: 3 },
	layoffs: { name: 'Layoffs Tracker', priority: 3 },
	venezuela: { name: 'Venezuela Situation', priority: 2 },
	greenland: { name: 'Greenland Situation', priority: 2 },
	iran: { name: 'Iran Situation', priority: 2 },
	leaders: { name: 'World Leaders', priority: 1 },
	intel: { name: 'Intel Feed', priority: 2 },
	correlation: { name: 'Correlation Engine', priority: 1 },
	narrative: { name: 'Narrative Tracker', priority: 1 },
	fed: { name: 'Federal Reserve', priority: 1 }
};

export const NON_DRAGGABLE_PANELS: PanelId[] = ['map'];

export const MAP_ZOOM_MIN = 1;
export const MAP_ZOOM_MAX = 4;
export const MAP_ZOOM_STEP = 0.5;



================================================
FILE: src/lib/config/presets.ts
================================================
/**
 * Onboarding presets for first-time users
 */

import type { PanelId } from './panels';

export interface Preset {
	id: string;
	name: string;
	icon: string;
	description: string;
	panels: PanelId[];
}

export const PRESETS: Record<string, Preset> = {
	'news-junkie': {
		id: 'news-junkie',
		name: 'News Junkie',
		icon: '📰',
		description: 'Stay on top of breaking news across politics, tech, and finance',
		panels: ['politics', 'tech', 'finance', 'gov', 'ai', 'mainchar', 'map']
	},
	trader: {
		id: 'trader',
		name: 'Trader',
		icon: '📈',
		description: 'Market-focused dashboard with stocks, crypto, and commodities',
		panels: [
			'markets',
			'heatmap',
			'commodities',
			'crypto',
			'polymarket',
			'whales',
			'printer',
			'finance',
			'map'
		]
	},
	geopolitics: {
		id: 'geopolitics',
		name: 'Geopolitics Watcher',
		icon: '🌍',
		description: 'Global situation awareness and regional hotspots',
		panels: [
			'map',
			'intel',
			'leaders',
			'politics',
			'gov',
			'venezuela',
			'greenland',
			'iran',
			'correlation',
			'narrative'
		]
	},
	intel: {
		id: 'intel',
		name: 'Intelligence Analyst',
		icon: '🔍',
		description: 'Deep analysis, pattern detection, and narrative tracking',
		panels: ['map', 'intel', 'leaders', 'correlation', 'narrative', 'mainchar', 'politics']
	},
	minimal: {
		id: 'minimal',
		name: 'Minimal',
		icon: '⚡',
		description: 'Just the essentials - map, news, and markets',
		panels: ['map', 'politics', 'markets']
	},
	everything: {
		id: 'everything',
		name: 'Everything',
		icon: '🎛️',
		description: 'Kitchen sink - all panels enabled',
		panels: [
			'map',
			'politics',
			'tech',
			'finance',
			'gov',
			'heatmap',
			'markets',
			'monitors',
			'commodities',
			'crypto',
			'polymarket',
			'whales',
			'mainchar',
			'printer',
			'contracts',
			'ai',
			'layoffs',
			'venezuela',
			'greenland',
			'iran',
			'leaders',
			'intel',
			'correlation',
			'narrative'
		]
	}
};

export const PRESET_ORDER = [
	'news-junkie',
	'trader',
	'geopolitics',
	'intel',
	'minimal',
	'everything'
];

// Storage keys
export const ONBOARDING_STORAGE_KEY = 'onboardingComplete';
export const PRESET_STORAGE_KEY = 'selectedPreset';



================================================
FILE: src/lib/services/cache.test.ts
================================================
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { CacheManager } from './cache';

describe('CacheManager', () => {
	let cache: CacheManager;

	beforeEach(() => {
		cache = new CacheManager({ prefix: 'test_', maxMemorySize: 5 });
		// Clear any previous localStorage entries
		if (typeof localStorage !== 'undefined') {
			localStorage.clear();
		}
	});

	describe('generateKey', () => {
		it('should generate key from URL without params', () => {
			const key = cache.generateKey('https://api.example.com/data');
			expect(key).toBe('https://api.example.com/data');
		});

		it('should generate key with sorted params', () => {
			const key = cache.generateKey('https://api.example.com/data', { b: '2', a: '1' });
			expect(key).toBe('https://api.example.com/data?a=1&b=2');
		});
	});

	describe('set and get', () => {
		it('should store and retrieve data from memory cache', () => {
			cache.set('test-key', { value: 42 }, 60000);
			const result = cache.get('test-key');

			expect(result).not.toBeNull();
			expect(result?.data).toEqual({ value: 42 });
			expect(result?.fromCache).toBe('memory');
			expect(result?.isStale).toBe(false);
		});

		it('should return null for non-existent key', () => {
			const result = cache.get('non-existent');
			expect(result).toBeNull();
		});

		it('should mark data as stale after TTL', () => {
			vi.useFakeTimers();

			cache.set('stale-test', { value: 'test' }, 1000);

			// Fast forward past TTL but within stale period
			vi.advanceTimersByTime(1500);

			const result = cache.get('stale-test');
			expect(result?.isStale).toBe(true);

			vi.useRealTimers();
		});

		it('should return null after stale period expires', () => {
			vi.useFakeTimers();

			cache.set('expire-test', { value: 'test' }, 1000, true);

			// Fast forward past stale period (2x TTL)
			vi.advanceTimersByTime(3000);

			const result = cache.get('expire-test');
			expect(result).toBeNull();

			vi.useRealTimers();
		});
	});

	describe('LRU eviction', () => {
		it('should evict oldest entry from memory when at capacity', () => {
			// Create a cache without localStorage access for this test
			const memOnlyCache = new CacheManager({ prefix: 'mem_', maxMemorySize: 3 });

			// Fill cache to capacity
			for (let i = 0; i < 3; i++) {
				memOnlyCache.set(`key-${i}`, i, 60000);
			}

			// Verify all entries exist
			expect(memOnlyCache.getStats().memoryEntries).toBe(3);

			// Add one more to trigger eviction
			memOnlyCache.set('key-new', 'new', 60000);

			// Memory should still be at max capacity
			expect(memOnlyCache.getStats().memoryEntries).toBe(3);

			// Newest key should exist
			expect(memOnlyCache.get('key-new')?.data).toBe('new');
		});
	});

	describe('invalidate', () => {
		it('should invalidate entries matching pattern', () => {
			cache.set('api/users/1', { id: 1 }, 60000);
			cache.set('api/users/2', { id: 2 }, 60000);
			cache.set('api/posts/1', { id: 1 }, 60000);

			cache.invalidate('users');

			// Note: invalidate clears all storage entries, not just matching ones
			// This is by design for simplicity
		});
	});

	describe('clear', () => {
		it('should clear all entries', () => {
			cache.set('key-1', 1, 60000);
			cache.set('key-2', 2, 60000);

			cache.clear();

			expect(cache.get('key-1')).toBeNull();
			expect(cache.get('key-2')).toBeNull();
		});
	});

	describe('getStats', () => {
		it('should return correct statistics', () => {
			cache.set('key-1', 'value-1', 60000);
			cache.set('key-2', 'value-2', 60000);

			const stats = cache.getStats();

			expect(stats.memoryEntries).toBe(2);
		});
	});
});



================================================
FILE: src/lib/services/cache.ts
================================================
/**
 * CacheManager - Two-tier caching with memory (L1) and localStorage (L2)
 */

export interface CacheEntry<T = unknown> {
	data: T;
	timestamp: number;
	ttl: number;
	staleUntil: number;
}

export interface CacheResult<T = unknown> {
	data: T;
	fromCache: 'memory' | 'storage';
	isStale: boolean;
}

export interface CacheManagerOptions {
	prefix?: string;
	maxMemorySize?: number;
	debug?: boolean;
}

export interface CacheStats {
	memoryEntries: number;
	storageEntries: number;
	storageSizeKB: number;
}

export class CacheManager {
	private memoryCache: Map<string, CacheEntry>;
	private readonly storagePrefix: string;
	private readonly maxMemorySize: number;
	private readonly debug: boolean;

	constructor(options: CacheManagerOptions = {}) {
		this.memoryCache = new Map();
		this.storagePrefix = options.prefix || 'sm_cache_';
		this.maxMemorySize = options.maxMemorySize || 100;
		this.debug = options.debug || false;
	}

	/**
	 * Generate a cache key from URL and params
	 */
	generateKey(url: string, params: Record<string, string | number | boolean> = {}): string {
		const sortedParams = Object.keys(params)
			.sort()
			.map((k) => `${k}=${params[k]}`)
			.join('&');
		return `${url}${sortedParams ? '?' + sortedParams : ''}`;
	}

	/**
	 * Get from cache - checks memory first, then localStorage
	 */
	get<T = unknown>(key: string): CacheResult<T> | null {
		// L1: Memory check
		if (this.memoryCache.has(key)) {
			const entry = this.memoryCache.get(key) as CacheEntry<T>;
			if (this.isValid(entry)) {
				this.log(`Cache HIT (memory): ${key.substring(0, 50)}...`);
				return { data: entry.data, fromCache: 'memory', isStale: this.isStale(entry) };
			}
			this.memoryCache.delete(key);
		}

		// L2: Storage check
		if (typeof localStorage === 'undefined') {
			this.log(`Cache MISS (no localStorage): ${key.substring(0, 50)}...`);
			return null;
		}

		try {
			const stored = localStorage.getItem(this.storagePrefix + this.hashKey(key));
			if (stored) {
				const entry = JSON.parse(stored) as CacheEntry<T>;
				if (this.isValid(entry)) {
					// Promote to memory cache
					this.setMemory(key, entry);
					this.log(`Cache HIT (storage): ${key.substring(0, 50)}...`);
					return { data: entry.data, fromCache: 'storage', isStale: this.isStale(entry) };
				}
				localStorage.removeItem(this.storagePrefix + this.hashKey(key));
			}
		} catch (e) {
			// Storage read error - continue without cache
			this.log(`Storage read error: ${(e as Error).message}`);
		}

		this.log(`Cache MISS: ${key.substring(0, 50)}...`);
		return null;
	}

	/**
	 * Set in both caches
	 */
	set<T = unknown>(key: string, data: T, ttl: number, staleWhileRevalidate = true): void {
		const now = Date.now();
		const entry: CacheEntry<T> = {
			data,
			timestamp: now,
			ttl,
			staleUntil: staleWhileRevalidate ? now + ttl * 2 : now + ttl
		};

		this.setMemory(key, entry);
		this.setStorage(key, entry);
		this.log(`Cache SET: ${key.substring(0, 50)}... (TTL: ${ttl / 1000}s)`);
	}

	/**
	 * Memory cache with LRU eviction
	 */
	private setMemory<T>(key: string, entry: CacheEntry<T>): void {
		// LRU eviction - remove oldest entry if at capacity
		if (this.memoryCache.size >= this.maxMemorySize) {
			const firstKey = this.memoryCache.keys().next().value;
			if (firstKey) {
				this.memoryCache.delete(firstKey);
			}
		}
		this.memoryCache.set(key, entry as CacheEntry);
	}

	/**
	 * Storage with error handling and quota management
	 */
	private setStorage<T>(key: string, entry: CacheEntry<T>): void {
		if (typeof localStorage === 'undefined') {
			return;
		}

		try {
			const serialized = JSON.stringify(entry);
			localStorage.setItem(this.storagePrefix + this.hashKey(key), serialized);
		} catch (e) {
			if ((e as Error).name === 'QuotaExceededError') {
				this.pruneStorage();
				try {
					localStorage.setItem(this.storagePrefix + this.hashKey(key), JSON.stringify(entry));
				} catch {
					this.log(`Storage quota exceeded, could not save: ${key.substring(0, 30)}...`);
				}
			}
		}
	}

	/**
	 * Check if entry is still valid (not beyond stale period)
	 */
	private isValid(entry: CacheEntry): boolean {
		return Date.now() < entry.staleUntil;
	}

	/**
	 * Check if entry is stale (past TTL but still within stale period)
	 */
	private isStale(entry: CacheEntry): boolean {
		return Date.now() > entry.timestamp + entry.ttl;
	}

	/**
	 * Hash long keys to fit in localStorage key limits
	 */
	private hashKey(key: string): string {
		let hash = 0;
		for (let i = 0; i < key.length; i++) {
			const char = key.charCodeAt(i);
			hash = (hash << 5) - hash + char;
			hash = hash & hash; // Convert to 32-bit integer
		}
		return Math.abs(hash).toString(36);
	}

	/**
	 * Remove oldest cache entries to free up space
	 */
	private pruneStorage(): void {
		if (typeof localStorage === 'undefined') {
			return;
		}

		const keys: Array<{ key: string; timestamp: number }> = [];
		for (let i = 0; i < localStorage.length; i++) {
			const key = localStorage.key(i);
			if (key?.startsWith(this.storagePrefix)) {
				try {
					const entry = JSON.parse(localStorage.getItem(key) || '') as CacheEntry;
					keys.push({ key, timestamp: entry.timestamp });
				} catch {
					// Invalid entry - remove it
					localStorage.removeItem(key);
				}
			}
		}
		// Sort by timestamp (oldest first) and remove half
		keys.sort((a, b) => a.timestamp - b.timestamp);
		keys.slice(0, Math.ceil(keys.length / 2)).forEach((k) => localStorage.removeItem(k.key));
		this.log(`Pruned ${Math.ceil(keys.length / 2)} old cache entries`);
	}

	/**
	 * Invalidate cache entries matching a pattern
	 */
	invalidate(pattern: string): void {
		let count = 0;

		// Clear from memory
		for (const [key] of this.memoryCache) {
			if (key.includes(pattern)) {
				this.memoryCache.delete(key);
				count++;
			}
		}

		// Clear from storage
		if (typeof localStorage !== 'undefined') {
			for (let i = localStorage.length - 1; i >= 0; i--) {
				const key = localStorage.key(i);
				if (key?.startsWith(this.storagePrefix)) {
					localStorage.removeItem(key);
					count++;
				}
			}
		}

		this.log(`Invalidated ${count} entries matching: ${pattern}`);
	}

	/**
	 * Clear all cache entries
	 */
	clear(): void {
		this.memoryCache.clear();

		if (typeof localStorage !== 'undefined') {
			for (let i = localStorage.length - 1; i >= 0; i--) {
				const key = localStorage.key(i);
				if (key?.startsWith(this.storagePrefix)) {
					localStorage.removeItem(key);
				}
			}
		}

		this.log('Cache cleared');
	}

	/**
	 * Get cache statistics
	 */
	getStats(): CacheStats {
		let storageCount = 0;
		let storageSize = 0;

		if (typeof localStorage !== 'undefined') {
			for (let i = 0; i < localStorage.length; i++) {
				const key = localStorage.key(i);
				if (key?.startsWith(this.storagePrefix)) {
					storageCount++;
					storageSize += (localStorage.getItem(key) || '').length;
				}
			}
		}

		return {
			memoryEntries: this.memoryCache.size,
			storageEntries: storageCount,
			storageSizeKB: Math.round((storageSize / 1024) * 100) / 100
		};
	}

	/**
	 * Debug logging
	 */
	private log(message: string): void {
		if (this.debug) {
			console.log(`[CacheManager] ${message}`);
		}
	}
}

// Export singleton instance
export const cacheManager = new CacheManager({ prefix: 'sm_' });



================================================
FILE: src/lib/services/circuit-breaker.test.ts
================================================
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { CircuitBreaker, CircuitBreakerRegistry, CircuitBreakerStates } from './circuit-breaker';

describe('CircuitBreaker', () => {
	let breaker: CircuitBreaker;

	beforeEach(() => {
		breaker = new CircuitBreaker('test-service', {
			failureThreshold: 3,
			resetTimeout: 1000,
			halfOpenMaxRequests: 1
		});
	});

	describe('initial state', () => {
		it('should start in CLOSED state', () => {
			expect(breaker.state).toBe(CircuitBreakerStates.CLOSED);
		});

		it('should allow requests when CLOSED', () => {
			expect(breaker.canRequest()).toBe(true);
		});
	});

	describe('failure tracking', () => {
		it('should remain CLOSED below failure threshold', () => {
			breaker.recordFailure();
			breaker.recordFailure();

			expect(breaker.state).toBe(CircuitBreakerStates.CLOSED);
			expect(breaker.canRequest()).toBe(true);
		});

		it('should transition to OPEN after reaching failure threshold', () => {
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordFailure();

			expect(breaker.state).toBe(CircuitBreakerStates.OPEN);
			expect(breaker.canRequest()).toBe(false);
		});
	});

	describe('success tracking', () => {
		it('should reset failure count on success', () => {
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordSuccess();

			const state = breaker.getState();
			expect(state.failures).toBe(0);
		});
	});

	describe('recovery', () => {
		it('should transition to HALF_OPEN after reset timeout', () => {
			vi.useFakeTimers();

			// Open the circuit
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordFailure();

			expect(breaker.state).toBe(CircuitBreakerStates.OPEN);

			// Fast forward past reset timeout
			vi.advanceTimersByTime(1500);

			// canRequest() should transition to HALF_OPEN
			expect(breaker.canRequest()).toBe(true);
			expect(breaker.state).toBe(CircuitBreakerStates.HALF_OPEN);

			vi.useRealTimers();
		});

		it('should transition to CLOSED on success in HALF_OPEN', () => {
			vi.useFakeTimers();

			// Open and wait for HALF_OPEN
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordFailure();
			vi.advanceTimersByTime(1500);
			breaker.canRequest();

			// Record success
			breaker.recordSuccess();

			expect(breaker.state).toBe(CircuitBreakerStates.CLOSED);

			vi.useRealTimers();
		});

		it('should transition back to OPEN on failure in HALF_OPEN', () => {
			vi.useFakeTimers();

			// Open and wait for HALF_OPEN
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordFailure();
			vi.advanceTimersByTime(1500);
			breaker.canRequest();

			// Record failure
			breaker.recordFailure();

			expect(breaker.state).toBe(CircuitBreakerStates.OPEN);

			vi.useRealTimers();
		});
	});

	describe('reset', () => {
		it('should reset to initial state', () => {
			breaker.recordFailure();
			breaker.recordFailure();
			breaker.recordFailure();

			breaker.reset();

			expect(breaker.state).toBe(CircuitBreakerStates.CLOSED);
			expect(breaker.canRequest()).toBe(true);
		});
	});

	describe('getState', () => {
		it('should return current state information', () => {
			breaker.recordSuccess();
			breaker.recordSuccess();
			breaker.recordFailure();

			const state = breaker.getState();

			expect(state.state).toBe(CircuitBreakerStates.CLOSED);
			expect(state.failures).toBe(1);
			expect(state.successes).toBe(2);
			expect(state.canRequest).toBe(true);
		});
	});
});

describe('CircuitBreakerRegistry', () => {
	let registry: CircuitBreakerRegistry;

	beforeEach(() => {
		registry = new CircuitBreakerRegistry();
	});

	it('should create and return circuit breakers', () => {
		const breaker1 = registry.get('service-1');
		const breaker2 = registry.get('service-2');

		expect(breaker1.serviceId).toBe('service-1');
		expect(breaker2.serviceId).toBe('service-2');
	});

	it('should return same instance for same service', () => {
		const breaker1 = registry.get('service-1');
		const breaker2 = registry.get('service-1');

		expect(breaker1).toBe(breaker2);
	});

	it('should track open circuit count', () => {
		const breaker1 = registry.get('service-1', { failureThreshold: 1 });
		const breaker2 = registry.get('service-2', { failureThreshold: 1 });

		breaker1.recordFailure();
		breaker2.recordFailure();

		expect(registry.getOpenCount()).toBe(2);
	});

	it('should reset all circuit breakers', () => {
		const breaker1 = registry.get('service-1', { failureThreshold: 1 });
		const breaker2 = registry.get('service-2', { failureThreshold: 1 });

		breaker1.recordFailure();
		breaker2.recordFailure();

		registry.resetAll();

		expect(registry.getOpenCount()).toBe(0);
	});
});



================================================
FILE: src/lib/services/circuit-breaker.ts
================================================
/**
 * CircuitBreaker - Circuit breaker pattern for failing services
 */

export const CircuitBreakerStates = {
	CLOSED: 'CLOSED', // Normal operation - requests flow through
	OPEN: 'OPEN', // Blocking requests - service is failing
	HALF_OPEN: 'HALF_OPEN' // Testing recovery - allowing limited requests
} as const;

export type CircuitBreakerState = (typeof CircuitBreakerStates)[keyof typeof CircuitBreakerStates];

export interface CircuitBreakerOptions {
	failureThreshold?: number;
	resetTimeout?: number;
	halfOpenMaxRequests?: number;
}

export interface CircuitBreakerStatus {
	state: CircuitBreakerState;
	failures: number;
	successes: number;
	lastFailure: number | null;
	canRequest: boolean;
	timeSinceLastFailure: number | null;
	timeUntilRetry: number;
}

export class CircuitBreaker {
	readonly serviceId: string;
	private readonly failureThreshold: number;
	private readonly resetTimeout: number;
	private readonly halfOpenMaxRequests: number;

	private _state: CircuitBreakerState = CircuitBreakerStates.CLOSED;
	private failures = 0;
	private successes = 0;
	private lastFailureTime: number | null = null;
	private halfOpenRequests = 0;

	constructor(serviceId: string, options: CircuitBreakerOptions = {}) {
		this.serviceId = serviceId;
		this.failureThreshold = options.failureThreshold || 3;
		this.resetTimeout = options.resetTimeout || 30000;
		this.halfOpenMaxRequests = options.halfOpenMaxRequests || 1;
	}

	get state(): CircuitBreakerState {
		return this._state;
	}

	/**
	 * Check if a request can proceed
	 */
	canRequest(): boolean {
		switch (this._state) {
			case CircuitBreakerStates.CLOSED:
				return true;

			case CircuitBreakerStates.OPEN:
				// Check if reset timeout has passed
				if (this.lastFailureTime && Date.now() - this.lastFailureTime >= this.resetTimeout) {
					this._state = CircuitBreakerStates.HALF_OPEN;
					this.halfOpenRequests = 0;
					console.log(`[CircuitBreaker] ${this.serviceId}: OPEN -> HALF_OPEN (testing recovery)`);
					return true;
				}
				return false;

			case CircuitBreakerStates.HALF_OPEN:
				return this.halfOpenRequests < this.halfOpenMaxRequests;

			default:
				return false;
		}
	}

	/**
	 * Record a successful request
	 */
	recordSuccess(): void {
		this.successes++;

		if (this._state === CircuitBreakerStates.HALF_OPEN) {
			// Recovery confirmed - close the circuit
			this._state = CircuitBreakerStates.CLOSED;
			console.log(`[CircuitBreaker] ${this.serviceId}: HALF_OPEN -> CLOSED (recovered)`);
		}

		this.failures = 0;
		this.halfOpenRequests = 0;
	}

	/**
	 * Record a failed request
	 */
	recordFailure(): void {
		this.failures++;
		this.lastFailureTime = Date.now();

		if (this._state === CircuitBreakerStates.HALF_OPEN) {
			// Recovery failed - reopen the circuit
			this._state = CircuitBreakerStates.OPEN;
			console.warn(`[CircuitBreaker] ${this.serviceId}: HALF_OPEN -> OPEN (recovery failed)`);
		} else if (this.failures >= this.failureThreshold) {
			// Threshold reached - open the circuit
			this._state = CircuitBreakerStates.OPEN;
			console.warn(
				`[CircuitBreaker] ${this.serviceId}: CLOSED -> OPEN (${this.failures} failures)`
			);
		}
	}

	/**
	 * Track a half-open request
	 */
	trackHalfOpenRequest(): void {
		if (this._state === CircuitBreakerStates.HALF_OPEN) {
			this.halfOpenRequests++;
		}
	}

	/**
	 * Get current state information
	 */
	getState(): CircuitBreakerStatus {
		return {
			state: this._state,
			failures: this.failures,
			successes: this.successes,
			lastFailure: this.lastFailureTime,
			canRequest: this.canRequest(),
			timeSinceLastFailure: this.lastFailureTime ? Date.now() - this.lastFailureTime : null,
			timeUntilRetry:
				this._state === CircuitBreakerStates.OPEN && this.lastFailureTime
					? Math.max(0, this.resetTimeout - (Date.now() - this.lastFailureTime))
					: 0
		};
	}

	/**
	 * Force reset the circuit breaker
	 */
	reset(): void {
		this._state = CircuitBreakerStates.CLOSED;
		this.failures = 0;
		this.successes = 0;
		this.lastFailureTime = null;
		this.halfOpenRequests = 0;
		console.log(`[CircuitBreaker] ${this.serviceId}: Reset to CLOSED`);
	}
}

/**
 * Registry to manage circuit breakers for multiple services
 */
export class CircuitBreakerRegistry {
	private breakers: Map<string, CircuitBreaker> = new Map();

	/**
	 * Get or create a circuit breaker for a service
	 */
	get(serviceId: string, options: CircuitBreakerOptions = {}): CircuitBreaker {
		if (!this.breakers.has(serviceId)) {
			this.breakers.set(serviceId, new CircuitBreaker(serviceId, options));
		}
		return this.breakers.get(serviceId)!;
	}

	/**
	 * Get status of all circuit breakers
	 */
	getStatus(): Record<string, CircuitBreakerStatus> {
		const status: Record<string, CircuitBreakerStatus> = {};
		for (const [id, breaker] of this.breakers) {
			status[id] = breaker.getState();
		}
		return status;
	}

	/**
	 * Reset all circuit breakers
	 */
	resetAll(): void {
		for (const breaker of this.breakers.values()) {
			breaker.reset();
		}
	}

	/**
	 * Get count of open circuits
	 */
	getOpenCount(): number {
		let count = 0;
		for (const breaker of this.breakers.values()) {
			if (breaker.state === CircuitBreakerStates.OPEN) count++;
		}
		return count;
	}
}

// Export singleton registry
export const circuitBreakerRegistry = new CircuitBreakerRegistry();



================================================
FILE: src/lib/services/client.ts
================================================
/**
 * ServiceClient - Unified fetch client with caching, retries, and circuit breaker
 */

import { CacheManager } from './cache';
import { CircuitBreakerRegistry, type CircuitBreaker } from './circuit-breaker';
import { RequestDeduplicator } from './deduplicator';
import { ServiceRegistry, type ServiceConfig, type ServiceId } from './registry';
import { ServiceError, NetworkError, TimeoutError, CircuitOpenError } from './errors';

export interface RequestOptions {
	params?: Record<string, string | number | boolean>;
	useCache?: boolean;
	retries?: number;
	timeout?: number;
	accept?: string;
	headers?: Record<string, string>;
	fetchOptions?: RequestInit;
	responseType?: 'json' | 'text';
}

export interface RequestResult<T = unknown> {
	data: T;
	fromCache: false | 'memory' | 'storage' | 'fallback' | 'stale-fallback';
	stale?: boolean;
	circuitOpen?: boolean;
	attempt?: number;
	error?: string;
}

export interface ServiceClientOptions {
	debug?: boolean;
}

export interface HealthStatus {
	circuitBreakers: Record<string, ReturnType<CircuitBreaker['getState']>>;
	openCircuits: number;
	inFlightRequests: number;
	cacheStats: ReturnType<CacheManager['getStats']>;
}

export class ServiceClient {
	private readonly cache: CacheManager;
	private readonly circuitBreakers: CircuitBreakerRegistry;
	private readonly deduplicator: RequestDeduplicator;
	private readonly debug: boolean;

	constructor(options: ServiceClientOptions = {}) {
		this.cache = new CacheManager({ prefix: 'sm_', debug: options.debug });
		this.circuitBreakers = new CircuitBreakerRegistry();
		this.deduplicator = new RequestDeduplicator();
		this.debug = options.debug || false;
	}

	/**
	 * Main request method - handles caching, circuit breaker, deduplication
	 */
	async request<T = unknown>(
		serviceId: ServiceId | string,
		endpoint: string,
		options: RequestOptions = {}
	): Promise<RequestResult<T>> {
		const config = ServiceRegistry.get(serviceId);
		if (!config) {
			throw new ServiceError(`Unknown service: ${serviceId}`, serviceId);
		}

		const url = this.buildUrl(config, endpoint, options.params);
		const cacheKey = this.cache.generateKey(url, options.params);

		// 1. Check cache first (unless explicitly disabled)
		if (options.useCache !== false && config.cache) {
			const cached = this.cache.get<T>(cacheKey);
			if (cached && !cached.isStale) {
				return { data: cached.data, fromCache: cached.fromCache, stale: false };
			}
			if (cached && cached.isStale && config.cache.staleWhileRevalidate) {
				// Return stale data immediately, revalidate in background
				this.revalidateInBackground(serviceId, endpoint, options, cacheKey, config);
				return { data: cached.data, fromCache: cached.fromCache, stale: true };
			}
		}

		// 2. Check circuit breaker
		const breaker = this.circuitBreakers.get(serviceId, config.circuitBreaker);
		if (!breaker.canRequest()) {
			// Circuit is open - try to return cached data
			const cached = this.cache.get<T>(cacheKey);
			if (cached) {
				return { data: cached.data, fromCache: 'fallback', circuitOpen: true };
			}
			throw new CircuitOpenError(serviceId);
		}

		// 3. Deduplicate concurrent requests
		return this.deduplicator.dedupe(cacheKey, () =>
			this.executeRequest<T>(serviceId, url, options, cacheKey, breaker, config)
		);
	}

	/**
	 * Execute the actual request with retries
	 */
	private async executeRequest<T>(
		serviceId: string,
		url: string,
		options: RequestOptions,
		cacheKey: string,
		breaker: CircuitBreaker,
		config: ServiceConfig
	): Promise<RequestResult<T>> {
		const retries = options.retries ?? config.retries ?? 2;
		let lastError: Error | undefined;

		for (let attempt = 0; attempt <= retries; attempt++) {
			try {
				if (attempt > 0) {
					this.log(`Retry attempt ${attempt} for ${serviceId}`);
				}

				breaker.trackHalfOpenRequest();
				const data = await this.fetchWithTimeout<T>(url, options, config);
				breaker.recordSuccess();

				// Cache successful response
				if (config.cache) {
					this.cache.set(cacheKey, data, config.cache.ttl, config.cache.staleWhileRevalidate);
				}

				return { data, fromCache: false, attempt };
			} catch (error) {
				lastError = error as Error;
				this.log(`Request failed (attempt ${attempt + 1}/${retries + 1}): ${lastError.message}`);

				// Don't retry on certain errors
				if (
					error instanceof CircuitOpenError ||
					(error instanceof NetworkError &&
						(error.status === 404 || error.status === 401 || error.status === 403))
				) {
					break;
				}

				if (attempt < retries) {
					await this.delay(this.getBackoffDelay(attempt));
				}
			}
		}

		breaker.recordFailure();

		// Try returning stale cache on failure
		const cached = this.cache.get<T>(cacheKey);
		if (cached) {
			console.warn(
				`[ServiceClient] ${serviceId}: Returning stale cache after ${retries + 1} failed attempts`
			);
			return { data: cached.data, fromCache: 'stale-fallback', error: lastError?.message };
		}

		throw lastError;
	}

	/**
	 * Fetch with AbortController timeout
	 */
	private async fetchWithTimeout<T>(
		url: string,
		options: RequestOptions,
		config: ServiceConfig
	): Promise<T> {
		const controller = new AbortController();
		const timeout = options.timeout || config.timeout || 10000;
		const timeoutId = setTimeout(() => controller.abort(), timeout);

		try {
			const fetchOptions: RequestInit = {
				...options.fetchOptions,
				signal: controller.signal,
				headers: {
					Accept: options.accept || 'application/json',
					...options.headers
				}
			};

			const response = await fetch(url, fetchOptions);

			if (!response.ok) {
				throw new NetworkError(`HTTP ${response.status}: ${response.statusText}`, response.status);
			}

			// Handle different response types
			const contentType = response.headers.get('content-type') || '';
			if (
				options.responseType === 'text' ||
				contentType.includes('text/') ||
				contentType.includes('xml')
			) {
				return (await response.text()) as T;
			}
			return (await response.json()) as T;
		} catch (error) {
			if ((error as Error).name === 'AbortError') {
				throw new TimeoutError(url, timeout);
			}
			throw error;
		} finally {
			clearTimeout(timeoutId);
		}
	}

	/**
	 * Build URL from config and endpoint
	 */
	private buildUrl(
		config: ServiceConfig,
		endpoint: string,
		params: Record<string, string | number | boolean> = {}
	): string {
		let baseUrl = config.baseUrl || '';

		// Handle full URLs (for CORS proxy passthrough)
		if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {
			baseUrl = '';
		}

		const fullUrl = baseUrl + endpoint;
		const url = new URL(fullUrl);

		// Add query params
		Object.entries(params).forEach(([key, value]) => {
			if (value !== undefined && value !== null) {
				url.searchParams.set(key, String(value));
			}
		});

		return url.toString();
	}

	/**
	 * Calculate exponential backoff delay with jitter
	 */
	private getBackoffDelay(attempt: number): number {
		// Base: 1s, 2s, 4s... + random 0-500ms jitter
		const baseDelay = Math.pow(2, attempt) * 1000;
		const jitter = Math.random() * 500;
		return Math.min(baseDelay + jitter, 10000); // Max 10 seconds
	}

	/**
	 * Delay helper
	 */
	private delay(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}

	/**
	 * Revalidate in background (fire and forget)
	 */
	private revalidateInBackground(
		serviceId: ServiceId | string,
		endpoint: string,
		options: RequestOptions,
		cacheKey: string,
		config: ServiceConfig
	): void {
		const breaker = this.circuitBreakers.get(serviceId, config.circuitBreaker);
		const url = this.buildUrl(config, endpoint, options.params);

		this.executeRequest(serviceId, url, { ...options, useCache: false }, cacheKey, breaker, config)
			.then(() => this.log(`Background revalidation complete: ${serviceId}`))
			.catch(() => this.log(`Background revalidation failed: ${serviceId}`));
	}

	/**
	 * Fetch through CORS proxy with fallback
	 */
	async fetchWithProxy<T = string>(targetUrl: string, options: RequestOptions = {}): Promise<T> {
		const proxies = ServiceRegistry.getCorsProxies();
		const config = ServiceRegistry.get('CORS_PROXY');
		if (!config) {
			throw new ServiceError('CORS_PROXY service not configured');
		}

		let lastError: Error | undefined;

		for (let i = 0; i < proxies.length; i++) {
			const proxy = proxies[i];
			const proxyUrl = proxy + encodeURIComponent(targetUrl);

			try {
				const response = await this.fetchWithTimeout<string>(
					proxyUrl,
					{
						...options,
						accept: 'application/rss+xml, application/xml, text/xml, */*',
						responseType: 'text'
					},
					config
				);

				// Validate response (check for error pages)
				if (
					response &&
					!response.includes('<!DOCTYPE html>') &&
					!response.includes('error code:')
				) {
					return response as T;
				}
			} catch (e) {
				this.log(`Proxy ${i + 1} failed: ${(e as Error).message}`);
				lastError = e as Error;
			}
		}

		throw lastError || new NetworkError('All CORS proxies failed');
	}

	/**
	 * Get health status of all services
	 */
	getHealthStatus(): HealthStatus {
		return {
			circuitBreakers: this.circuitBreakers.getStatus(),
			openCircuits: this.circuitBreakers.getOpenCount(),
			inFlightRequests: this.deduplicator.getCount(),
			cacheStats: this.cache.getStats()
		};
	}

	/**
	 * Clear cache for a specific service pattern
	 */
	clearServiceCache(pattern: string): void {
		this.cache.invalidate(pattern);
	}

	/**
	 * Reset all circuit breakers
	 */
	resetCircuitBreakers(): void {
		this.circuitBreakers.resetAll();
	}

	/**
	 * Debug logging
	 */
	private log(message: string): void {
		if (this.debug) {
			console.log(`[ServiceClient] ${message}`);
		}
	}
}

// Export singleton instance
export const serviceClient = new ServiceClient({ debug: false });



================================================
FILE: src/lib/services/deduplicator.test.ts
================================================
import { describe, it, expect, beforeEach } from 'vitest';
import { RequestDeduplicator } from './deduplicator';

describe('RequestDeduplicator', () => {
	let deduplicator: RequestDeduplicator;

	beforeEach(() => {
		deduplicator = new RequestDeduplicator();
	});

	describe('dedupe', () => {
		it('should return same promise for concurrent requests', async () => {
			let callCount = 0;
			const requestFn = () =>
				new Promise<string>((resolve) => {
					callCount++;
					setTimeout(() => resolve('result'), 100);
				});

			// Start two concurrent requests
			const promise1 = deduplicator.dedupe('test-key', requestFn);
			const promise2 = deduplicator.dedupe('test-key', requestFn);

			// Both should be the same promise
			expect(promise1).toBe(promise2);

			// Request function should only be called once
			expect(callCount).toBe(1);

			// Both should resolve to same value
			const [result1, result2] = await Promise.all([promise1, promise2]);
			expect(result1).toBe('result');
			expect(result2).toBe('result');
		});

		it('should make new request after previous completes', async () => {
			let callCount = 0;
			const requestFn = () =>
				new Promise<number>((resolve) => {
					callCount++;
					resolve(callCount);
				});

			// First request
			const result1 = await deduplicator.dedupe('test-key', requestFn);
			expect(result1).toBe(1);

			// Second request (first is done)
			const result2 = await deduplicator.dedupe('test-key', requestFn);
			expect(result2).toBe(2);

			expect(callCount).toBe(2);
		});

		it('should track different keys separately', async () => {
			let callCount = 0;
			const requestFn = () =>
				new Promise<number>((resolve) => {
					callCount++;
					resolve(callCount);
				});

			// Concurrent requests with different keys
			const [result1, result2] = await Promise.all([
				deduplicator.dedupe('key-1', requestFn),
				deduplicator.dedupe('key-2', requestFn)
			]);

			expect(callCount).toBe(2);
			expect(result1).not.toBe(result2);
		});
	});

	describe('isInFlight', () => {
		it('should return true for in-flight requests', () => {
			deduplicator.dedupe('test-key', () => new Promise((resolve) => setTimeout(resolve, 1000)));

			expect(deduplicator.isInFlight('test-key')).toBe(true);
		});

		it('should return false after request completes', async () => {
			await deduplicator.dedupe('test-key', () => Promise.resolve('done'));

			expect(deduplicator.isInFlight('test-key')).toBe(false);
		});
	});

	describe('getCount', () => {
		it('should return number of in-flight requests', () => {
			deduplicator.dedupe('key-1', () => new Promise((resolve) => setTimeout(resolve, 1000)));
			deduplicator.dedupe('key-2', () => new Promise((resolve) => setTimeout(resolve, 1000)));

			expect(deduplicator.getCount()).toBe(2);
		});
	});

	describe('clear', () => {
		it('should clear all tracked requests', () => {
			deduplicator.dedupe('key-1', () => new Promise((resolve) => setTimeout(resolve, 1000)));
			deduplicator.dedupe('key-2', () => new Promise((resolve) => setTimeout(resolve, 1000)));

			deduplicator.clear();

			expect(deduplicator.getCount()).toBe(0);
		});
	});

	describe('error handling', () => {
		it('should clean up after rejected promise', async () => {
			const requestFn = () => Promise.reject(new Error('test error'));

			try {
				await deduplicator.dedupe('test-key', requestFn);
			} catch {
				// Expected to throw
			}

			// Should be cleaned up
			expect(deduplicator.isInFlight('test-key')).toBe(false);
		});
	});
});



================================================
FILE: src/lib/services/deduplicator.ts
================================================
/**
 * RequestDeduplicator - Prevent duplicate in-flight requests
 */

export class RequestDeduplicator {
	private inFlight: Map<string, Promise<unknown>> = new Map();

	/**
	 * Get an existing in-flight request promise if one exists
	 */
	get<T>(key: string): Promise<T> | null {
		return (this.inFlight.get(key) as Promise<T>) || null;
	}

	/**
	 * Track a new in-flight request
	 */
	track<T>(key: string, promise: Promise<T>): Promise<T> {
		this.inFlight.set(key, promise);

		// Clean up when promise resolves or rejects
		promise
			.finally(() => this.inFlight.delete(key))
			.catch(() => {
				// Prevent unhandled rejection
			});

		return promise;
	}

	/**
	 * Deduplicate: return existing promise or track new one
	 */
	dedupe<T>(key: string, requestFn: () => Promise<T>): Promise<T> {
		const existing = this.get<T>(key);
		if (existing) {
			console.log(`[Deduplicator] Reusing in-flight request: ${key.substring(0, 50)}...`);
			return existing;
		}
		return this.track(key, requestFn());
	}

	/**
	 * Check if a request is currently in-flight
	 */
	isInFlight(key: string): boolean {
		return this.inFlight.has(key);
	}

	/**
	 * Get count of in-flight requests
	 */
	getCount(): number {
		return this.inFlight.size;
	}

	/**
	 * Get all in-flight keys (for debugging)
	 */
	getInFlightKeys(): string[] {
		return Array.from(this.inFlight.keys());
	}

	/**
	 * Clear all tracked requests (use with caution)
	 */
	clear(): void {
		this.inFlight.clear();
	}
}

// Export singleton instance
export const requestDeduplicator = new RequestDeduplicator();



================================================
FILE: src/lib/services/errors.ts
================================================
/**
 * Custom error classes for service layer
 */

export class ServiceError extends Error {
	readonly serviceId: string | null;

	constructor(message: string, serviceId: string | null = null) {
		super(message);
		this.name = 'ServiceError';
		this.serviceId = serviceId;
	}
}

export class NetworkError extends Error {
	readonly status: number | null;

	constructor(message: string, status: number | null = null) {
		super(message);
		this.name = 'NetworkError';
		this.status = status;
	}
}

export class TimeoutError extends Error {
	readonly url: string;
	readonly timeout: number | null;

	constructor(url: string, timeout: number | null = null) {
		super(`Request timed out: ${url}`);
		this.name = 'TimeoutError';
		this.url = url;
		this.timeout = timeout;
	}
}

export class CircuitOpenError extends Error {
	readonly serviceId: string;

	constructor(serviceId: string) {
		super(`Circuit breaker open for service: ${serviceId}`);
		this.name = 'CircuitOpenError';
		this.serviceId = serviceId;
	}
}



================================================
FILE: src/lib/services/index.ts
================================================
/**
 * Service layer exports
 */

// Errors
export { ServiceError, NetworkError, TimeoutError, CircuitOpenError } from './errors';

// Cache Manager
export {
	CacheManager,
	cacheManager,
	type CacheEntry,
	type CacheResult,
	type CacheManagerOptions,
	type CacheStats
} from './cache';

// Circuit Breaker
export {
	CircuitBreaker,
	CircuitBreakerRegistry,
	CircuitBreakerStates,
	circuitBreakerRegistry,
	type CircuitBreakerState,
	type CircuitBreakerOptions,
	type CircuitBreakerStatus
} from './circuit-breaker';

// Request Deduplicator
export { RequestDeduplicator, requestDeduplicator } from './deduplicator';

// Service Registry
export {
	ServiceRegistry,
	SERVICE_CONFIG,
	type ServiceConfig,
	type ServiceId,
	type CacheConfig,
	type CircuitBreakerConfig
} from './registry';

// Service Client
export {
	ServiceClient,
	serviceClient,
	type RequestOptions,
	type RequestResult,
	type ServiceClientOptions,
	type HealthStatus
} from './client';



================================================
FILE: src/lib/services/registry.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { ServiceRegistry } from './registry';

describe('ServiceRegistry', () => {
	describe('get', () => {
		it('should return config for registered service', () => {
			const config = ServiceRegistry.get('GDELT');

			expect(config).not.toBeNull();
			expect(config?.id).toBe('gdelt');
			expect(config?.baseUrl).toBe('https://api.gdeltproject.org');
		});

		it('should return null for unknown service', () => {
			const config = ServiceRegistry.get('UNKNOWN');

			expect(config).toBeNull();
		});
	});

	describe('getServiceIds', () => {
		it('should return all registered service IDs', () => {
			const ids = ServiceRegistry.getServiceIds();

			expect(ids).toContain('GDELT');
			expect(ids).toContain('COINGECKO');
			expect(ids).toContain('FRED');
			expect(ids).toContain('USGS');
			expect(ids).toContain('CORS_PROXY');
		});
	});

	describe('has', () => {
		it('should return true for registered services', () => {
			expect(ServiceRegistry.has('GDELT')).toBe(true);
			expect(ServiceRegistry.has('COINGECKO')).toBe(true);
		});

		it('should return false for unknown services', () => {
			expect(ServiceRegistry.has('UNKNOWN')).toBe(false);
		});
	});

	describe('getCorsProxies', () => {
		it('should return list of CORS proxies', () => {
			const proxies = ServiceRegistry.getCorsProxies();

			expect(proxies).toBeInstanceOf(Array);
			expect(proxies.length).toBeGreaterThan(0);
			expect(proxies[0]).toContain('situation-monitor-proxy');
		});
	});

	describe('getAll', () => {
		it('should return all service configurations', () => {
			const all = ServiceRegistry.getAll();

			expect(all.GDELT).toBeDefined();
			expect(all.COINGECKO).toBeDefined();
		});
	});

	describe('service configurations', () => {
		it('should have valid cache config for GDELT', () => {
			const config = ServiceRegistry.get('GDELT');

			expect(config?.cache?.ttl).toBe(3 * 60 * 1000);
			expect(config?.cache?.staleWhileRevalidate).toBe(true);
		});

		it('should have valid circuit breaker config for COINGECKO', () => {
			const config = ServiceRegistry.get('COINGECKO');

			expect(config?.circuitBreaker?.failureThreshold).toBe(3);
			expect(config?.circuitBreaker?.resetTimeout).toBe(120000);
		});

		it('should have longer TTL for FRED (weekly data)', () => {
			const config = ServiceRegistry.get('FRED');

			expect(config?.cache?.ttl).toBe(60 * 60 * 1000); // 1 hour
		});
	});
});



================================================
FILE: src/lib/services/registry.ts
================================================
/**
 * ServiceRegistry - Service configurations for all external APIs
 */

export interface CacheConfig {
	ttl: number;
	staleWhileRevalidate: boolean;
}

export interface CircuitBreakerConfig {
	failureThreshold: number;
	resetTimeout: number;
}

export interface ServiceConfig {
	id: string;
	baseUrl: string | null;
	timeout: number;
	retries: number;
	cache?: CacheConfig;
	circuitBreaker?: CircuitBreakerConfig;
	proxies?: string[];
}

export type ServiceId = 'GDELT' | 'COINGECKO' | 'FRED' | 'USGS' | 'CORS_PROXY';

const SERVICE_CONFIG: Record<ServiceId, ServiceConfig> = {
	GDELT: {
		id: 'gdelt',
		baseUrl: 'https://api.gdeltproject.org',
		timeout: 15000,
		retries: 1,
		cache: {
			ttl: 3 * 60 * 1000, // 3 minutes (real-time news)
			staleWhileRevalidate: true
		},
		circuitBreaker: {
			failureThreshold: 2,
			resetTimeout: 60000 // 1 minute
		}
	},

	COINGECKO: {
		id: 'coingecko',
		baseUrl: 'https://api.coingecko.com',
		timeout: 10000,
		retries: 2,
		cache: {
			ttl: 60 * 1000, // 1 minute (crypto volatility)
			staleWhileRevalidate: false
		},
		circuitBreaker: {
			failureThreshold: 3,
			resetTimeout: 120000 // 2 minutes (API can be flaky)
		}
	},

	FRED: {
		id: 'fred',
		baseUrl: 'https://fred.stlouisfed.org',
		timeout: 10000,
		retries: 2,
		cache: {
			ttl: 60 * 60 * 1000, // 1 hour (weekly data)
			staleWhileRevalidate: true
		},
		circuitBreaker: {
			failureThreshold: 3,
			resetTimeout: 60000
		}
	},

	USGS: {
		id: 'usgs',
		baseUrl: 'https://earthquake.usgs.gov',
		timeout: 10000,
		retries: 2,
		cache: {
			ttl: 5 * 60 * 1000, // 5 minutes
			staleWhileRevalidate: true
		},
		circuitBreaker: {
			failureThreshold: 3,
			resetTimeout: 60000
		}
	},

	CORS_PROXY: {
		id: 'cors_proxy',
		baseUrl: null, // Uses proxy URLs from list
		proxies: [
			'https://situation-monitor-proxy.seanthielen-e.workers.dev/?url=',
			'https://api.allorigins.win/raw?url='
		],
		timeout: 12000,
		retries: 1, // Already has proxy fallback
		cache: {
			ttl: 5 * 60 * 1000,
			staleWhileRevalidate: true
		},
		circuitBreaker: {
			failureThreshold: 5,
			resetTimeout: 120000
		}
	}
};

export class ServiceRegistry {
	/**
	 * Get configuration for a service
	 */
	static get(serviceId: ServiceId | string): ServiceConfig | null {
		return SERVICE_CONFIG[serviceId as ServiceId] || null;
	}

	/**
	 * Get all service IDs
	 */
	static getServiceIds(): ServiceId[] {
		return Object.keys(SERVICE_CONFIG) as ServiceId[];
	}

	/**
	 * Get all service configurations
	 */
	static getAll(): Record<ServiceId, ServiceConfig> {
		return { ...SERVICE_CONFIG };
	}

	/**
	 * Check if a service is registered
	 */
	static has(serviceId: string): serviceId is ServiceId {
		return Object.hasOwn(SERVICE_CONFIG, serviceId);
	}

	/**
	 * Get CORS proxies list
	 */
	static getCorsProxies(): string[] {
		return SERVICE_CONFIG.CORS_PROXY.proxies || [];
	}
}

export { SERVICE_CONFIG };



================================================
FILE: src/lib/stores/fed.ts
================================================
/**
 * Federal Reserve store - manages Fed news and economic indicators
 */

import { writable, derived } from 'svelte/store';
import type { FedIndicators, FedNewsItem } from '$lib/api/fred';

// ============================================================================
// State Types
// ============================================================================

export interface FedIndicatorsState {
	data: FedIndicators | null;
	loading: boolean;
	error: string | null;
	lastUpdated: number | null;
}

export interface FedNewsState {
	items: FedNewsItem[];
	loading: boolean;
	error: string | null;
	lastUpdated: number | null;
}

// ============================================================================
// Indicators Store
// ============================================================================

function createFedIndicatorsStore() {
	const { subscribe, update } = writable<FedIndicatorsState>({
		data: null,
		loading: false,
		error: null,
		lastUpdated: null
	});

	return {
		subscribe,

		setLoading(loading: boolean) {
			update((state) => ({
				...state,
				loading,
				error: loading ? null : state.error
			}));
		},

		setError(error: string | null) {
			update((state) => ({
				...state,
				loading: false,
				error
			}));
		},

		setData(data: FedIndicators) {
			update(() => ({
				data,
				loading: false,
				error: null,
				lastUpdated: Date.now()
			}));
		}
	};
}

export const fedIndicators = createFedIndicatorsStore();

// ============================================================================
// News Store
// ============================================================================

function createFedNewsStore() {
	const { subscribe, update } = writable<FedNewsState>({
		items: [],
		loading: false,
		error: null,
		lastUpdated: null
	});

	return {
		subscribe,

		setLoading(loading: boolean) {
			update((state) => ({
				...state,
				loading,
				error: loading ? null : state.error
			}));
		},

		setError(error: string | null) {
			update((state) => ({
				...state,
				loading: false,
				error
			}));
		},

		setItems(items: FedNewsItem[]) {
			update(() => ({
				items,
				loading: false,
				error: null,
				lastUpdated: Date.now()
			}));
		}
	};
}

export const fedNews = createFedNewsStore();

// ============================================================================
// Derived Stores
// ============================================================================

export const isFedLoading = derived(
	[fedIndicators, fedNews],
	([$indicators, $news]) => $indicators.loading || $news.loading
);

export const fedVideos = derived(fedNews, ($news) => $news.items.filter((item) => item.hasVideo));



================================================
FILE: src/lib/stores/index.ts
================================================
/**
 * Stores barrel file - re-exports all stores
 */

// Settings store
export {
	settings,
	enabledPanels,
	disabledPanels,
	draggablePanels,
	type PanelSettings,
	type SettingsState
} from './settings';

// Monitors store
export {
	monitors,
	enabledMonitors,
	monitorCount,
	matchCount,
	hasMatches,
	type MonitorMatch,
	type MonitorsState
} from './monitors';

// News store
export {
	news,
	politicsNews,
	techNews,
	financeNews,
	govNews,
	aiNews,
	intelNews,
	allNewsItems,
	alerts,
	isLoading as isNewsLoading,
	hasErrors as hasNewsErrors,
	type CategoryState,
	type NewsState
} from './news';

// Markets store
export {
	markets,
	indices,
	sectors,
	commodities,
	crypto,
	isMarketsLoading,
	marketsLastUpdated,
	vix,
	type MarketsState
} from './markets';

// Refresh store
export {
	refresh,
	isRefreshing,
	currentStage,
	lastRefresh,
	autoRefreshEnabled,
	timeSinceRefresh,
	categoriesWithErrors,
	REFRESH_STAGES,
	type RefreshStage,
	type StageConfig,
	type RefreshState
} from './refresh';

// Fed store
export {
	fedIndicators,
	fedNews,
	isFedLoading,
	fedVideos,
	type FedIndicatorsState,
	type FedNewsState
} from './fed';



================================================
FILE: src/lib/stores/markets.test.ts
================================================
/**
 * Tests for markets store
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';

// Mock $app/environment
vi.mock('$app/environment', () => ({
	browser: true
}));

describe('Markets Store', () => {
	beforeEach(async () => {
		vi.resetModules();
	});

	it('should start with empty markets', async () => {
		const { markets } = await import('./markets');

		const state = get(markets);
		expect(state.indices.items).toEqual([]);
		expect(state.sectors.items).toEqual([]);
		expect(state.commodities.items).toEqual([]);
		expect(state.crypto.items).toEqual([]);
	});

	it('should set indices data', async () => {
		const { markets, indices } = await import('./markets');

		const indexData = [
			{ symbol: '^DJI', name: 'Dow Jones', price: 38000, change: 150, changePercent: 0.4 },
			{ symbol: '^GSPC', name: 'S&P 500', price: 5000, change: 25, changePercent: 0.5 }
		];

		markets.setIndices(indexData);

		const data = get(indices);
		expect(data.items.length).toBe(2);
		expect(data.loading).toBe(false);
		expect(data.lastUpdated).not.toBeNull();
	});

	it('should set sectors data', async () => {
		const { markets, sectors } = await import('./markets');

		const sectorData = [
			{ symbol: 'XLK', name: 'Tech', price: 200, change: 2, changePercent: 1.0 },
			{ symbol: 'XLF', name: 'Finance', price: 40, change: -0.5, changePercent: -1.25 }
		];

		markets.setSectors(sectorData);

		const data = get(sectors);
		expect(data.items.length).toBe(2);
	});

	it('should set commodities data', async () => {
		const { markets, commodities, vix } = await import('./markets');

		const commodityData = [
			{ symbol: '^VIX', name: 'VIX', price: 15, change: 0.5, changePercent: 3.4 },
			{ symbol: 'GC=F', name: 'Gold', price: 2000, change: 10, changePercent: 0.5 }
		];

		markets.setCommodities(commodityData);

		const data = get(commodities);
		expect(data.items.length).toBe(2);

		const vixData = get(vix);
		expect(vixData?.symbol).toBe('^VIX');
		expect(vixData?.price).toBe(15);
	});

	it('should set crypto data', async () => {
		const { markets, crypto } = await import('./markets');

		const cryptoData = [
			{
				id: 'bitcoin',
				symbol: 'BTC',
				name: 'Bitcoin',
				current_price: 95000,
				price_change_24h: 1500,
				price_change_percentage_24h: 1.6
			},
			{
				id: 'ethereum',
				symbol: 'ETH',
				name: 'Ethereum',
				current_price: 3500,
				price_change_24h: -50,
				price_change_percentage_24h: -1.4
			}
		];

		markets.setCrypto(cryptoData);

		const data = get(crypto);
		expect(data.items.length).toBe(2);
		expect(data.items[0].id).toBe('bitcoin');
	});

	it('should set loading state', async () => {
		const { markets, isMarketsLoading } = await import('./markets');

		markets.setLoading('indices', true);
		expect(get(isMarketsLoading)).toBe(true);

		markets.setLoading('indices', false);
		expect(get(isMarketsLoading)).toBe(false);
	});

	it('should set error state', async () => {
		const { markets, indices } = await import('./markets');

		markets.setError('indices', 'API error');

		const data = get(indices);
		expect(data.error).toBe('API error');
		expect(data.loading).toBe(false);
	});

	it('should update single market item', async () => {
		const { markets, indices } = await import('./markets');

		markets.setIndices([
			{ symbol: '^DJI', name: 'Dow', price: 38000, change: 0, changePercent: 0 }
		]);

		markets.updateItem('indices', '^DJI', { price: 38100, change: 100, changePercent: 0.26 });

		const data = get(indices);
		expect(data.items[0].price).toBe(38100);
		expect(data.items[0].change).toBe(100);
	});

	it('should get market summary', async () => {
		const { markets } = await import('./markets');

		markets.setIndices([
			{ symbol: 'A', name: 'A', price: 100, change: 5, changePercent: 5 },
			{ symbol: 'B', name: 'B', price: 100, change: 3, changePercent: 3 },
			{ symbol: 'C', name: 'C', price: 100, change: -1, changePercent: -1 }
		]);

		const summary = markets.getSummary();
		expect(summary.marketTrend).toBe('up');
		expect(summary.topGainer?.symbol).toBe('A');
		expect(summary.topLoser?.symbol).toBe('C');
	});

	it('should derive last updated correctly', async () => {
		const { markets, marketsLastUpdated } = await import('./markets');

		expect(get(marketsLastUpdated)).toBeNull();

		markets.setIndices([{ symbol: 'A', name: 'A', price: 100, change: 0, changePercent: 0 }]);

		const lastUpdated = get(marketsLastUpdated);
		expect(lastUpdated).not.toBeNull();
		expect(lastUpdated).toBeLessThanOrEqual(Date.now());
	});

	it('should clear all data', async () => {
		const { markets } = await import('./markets');

		markets.setIndices([{ symbol: 'A', name: 'A', price: 100, change: 0, changePercent: 0 }]);
		markets.setCrypto([
			{
				id: 'btc',
				symbol: 'BTC',
				name: 'Bitcoin',
				current_price: 100,
				price_change_24h: 0,
				price_change_percentage_24h: 0
			}
		]);

		markets.clearAll();

		const state = get(markets);
		expect(state.indices.items).toEqual([]);
		expect(state.crypto.items).toEqual([]);
	});
});



================================================
FILE: src/lib/stores/markets.ts
================================================
/**
 * Markets store - stocks, crypto, commodities, indices
 */

import { writable, derived, get } from 'svelte/store';
import type { MarketItem, CryptoItem, SectorPerformance } from '$lib/types';

export interface MarketsState {
	// Stock indices (DOW, S&P, NASDAQ, Russell)
	indices: {
		items: MarketItem[];
		loading: boolean;
		error: string | null;
		lastUpdated: number | null;
	};

	// Sector ETFs (XLK, XLF, etc.)
	sectors: {
		items: SectorPerformance[];
		loading: boolean;
		error: string | null;
		lastUpdated: number | null;
	};

	// Commodities (Gold, Oil, VIX, etc.)
	commodities: {
		items: MarketItem[];
		loading: boolean;
		error: string | null;
		lastUpdated: number | null;
	};

	// Crypto (BTC, ETH, SOL)
	crypto: {
		items: CryptoItem[];
		loading: boolean;
		error: string | null;
		lastUpdated: number | null;
	};

	initialized: boolean;
}

type MarketCategory = 'indices' | 'sectors' | 'commodities' | 'crypto';

// Create initial state
function createInitialState(): MarketsState {
	const emptySection = {
		items: [],
		loading: false,
		error: null,
		lastUpdated: null
	};

	return {
		indices: { ...emptySection },
		sectors: { ...emptySection },
		commodities: { ...emptySection },
		crypto: { ...emptySection },
		initialized: false
	};
}

// Create the store
function createMarketsStore() {
	const { subscribe, set, update } = writable<MarketsState>(createInitialState());

	return {
		subscribe,

		/**
		 * Initialize store
		 */
		init() {
			update((state) => ({ ...state, initialized: true }));
		},

		/**
		 * Set loading state for a category
		 */
		setLoading(category: MarketCategory, loading: boolean) {
			update((state) => ({
				...state,
				[category]: {
					...state[category],
					loading,
					error: loading ? null : state[category].error
				}
			}));
		},

		/**
		 * Set error state for a category
		 */
		setError(category: MarketCategory, error: string | null) {
			update((state) => ({
				...state,
				[category]: {
					...state[category],
					loading: false,
					error
				}
			}));
		},

		/**
		 * Set indices data
		 */
		setIndices(items: MarketItem[]) {
			update((state) => ({
				...state,
				indices: {
					items,
					loading: false,
					error: null,
					lastUpdated: Date.now()
				}
			}));
		},

		/**
		 * Set sectors data
		 */
		setSectors(items: SectorPerformance[]) {
			update((state) => ({
				...state,
				sectors: {
					items,
					loading: false,
					error: null,
					lastUpdated: Date.now()
				}
			}));
		},

		/**
		 * Set commodities data
		 */
		setCommodities(items: MarketItem[]) {
			update((state) => ({
				...state,
				commodities: {
					items,
					loading: false,
					error: null,
					lastUpdated: Date.now()
				}
			}));
		},

		/**
		 * Set crypto data
		 */
		setCrypto(items: CryptoItem[]) {
			update((state) => ({
				...state,
				crypto: {
					items,
					loading: false,
					error: null,
					lastUpdated: Date.now()
				}
			}));
		},

		/**
		 * Update a single market item
		 */
		updateItem(category: 'indices' | 'commodities', symbol: string, updates: Partial<MarketItem>) {
			update((state) => {
				const items = state[category].items as MarketItem[];
				const index = items.findIndex((i) => i.symbol === symbol);
				if (index === -1) return state;

				const newItems = [...items];
				newItems[index] = { ...newItems[index], ...updates };

				return {
					...state,
					[category]: {
						...state[category],
						items: newItems
					}
				};
			});
		},

		/**
		 * Update a single crypto item
		 */
		updateCrypto(id: string, updates: Partial<CryptoItem>) {
			update((state) => {
				const index = state.crypto.items.findIndex((i) => i.id === id);
				if (index === -1) return state;

				const newItems = [...state.crypto.items];
				newItems[index] = { ...newItems[index], ...updates };

				return {
					...state,
					crypto: {
						...state.crypto,
						items: newItems
					}
				};
			});
		},

		/**
		 * Get market summary
		 */
		getSummary(): {
			marketTrend: 'up' | 'down' | 'mixed';
			topGainer: MarketItem | null;
			topLoser: MarketItem | null;
		} {
			const state = get({ subscribe });
			const allItems = [...state.indices.items, ...state.sectors.items, ...state.commodities.items];

			if (allItems.length === 0) {
				return { marketTrend: 'mixed', topGainer: null, topLoser: null };
			}

			const gainers = allItems.filter((i) => i.changePercent > 0);
			const losers = allItems.filter((i) => i.changePercent < 0);

			let marketTrend: 'up' | 'down' | 'mixed' = 'mixed';
			if (gainers.length > losers.length * 1.5) {
				marketTrend = 'up';
			} else if (losers.length > gainers.length * 1.5) {
				marketTrend = 'down';
			}

			const sorted = [...allItems].sort((a, b) => b.changePercent - a.changePercent);
			const topGainer = sorted[0] ?? null;
			const topLoser = sorted[sorted.length - 1] ?? null;

			return { marketTrend, topGainer, topLoser };
		},

		/**
		 * Check if any category is loading
		 */
		isAnyLoading(): boolean {
			const state = get({ subscribe });
			return (
				state.indices.loading ||
				state.sectors.loading ||
				state.commodities.loading ||
				state.crypto.loading
			);
		},

		/**
		 * Clear all data
		 */
		clearAll() {
			set(createInitialState());
		}
	};
}

// Export singleton store
export const markets = createMarketsStore();

// Derived stores
export const indices = derived(markets, ($markets) => $markets.indices);
export const sectors = derived(markets, ($markets) => $markets.sectors);
export const commodities = derived(markets, ($markets) => $markets.commodities);
export const crypto = derived(markets, ($markets) => $markets.crypto);

// Market status derived stores
export const isMarketsLoading = derived(
	markets,
	($markets) =>
		$markets.indices.loading ||
		$markets.sectors.loading ||
		$markets.commodities.loading ||
		$markets.crypto.loading
);

export const marketsLastUpdated = derived(markets, ($markets) => {
	const times = [
		$markets.indices.lastUpdated,
		$markets.sectors.lastUpdated,
		$markets.commodities.lastUpdated,
		$markets.crypto.lastUpdated
	].filter((t): t is number => t !== null);

	return times.length > 0 ? Math.max(...times) : null;
});

// VIX convenience store (commonly needed)
export const vix = derived(markets, ($markets) => {
	return $markets.commodities.items.find((i) => i.symbol === '^VIX') ?? null;
});



================================================
FILE: src/lib/stores/monitors.test.ts
================================================
/**
 * Tests for monitors store
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';

// Mock $app/environment before importing the store
vi.mock('$app/environment', () => ({
	browser: true
}));

// Mock localStorage
const localStorageMock = (() => {
	let store: Record<string, string> = {};
	return {
		getItem: vi.fn((key: string) => store[key] || null),
		setItem: vi.fn((key: string, value: string) => {
			store[key] = value;
		}),
		removeItem: vi.fn((key: string) => {
			delete store[key];
		}),
		clear: vi.fn(() => {
			store = {};
		})
	};
})();

Object.defineProperty(globalThis, 'localStorage', {
	value: localStorageMock
});

describe('Monitors Store', () => {
	beforeEach(async () => {
		localStorageMock.clear();
		vi.clearAllMocks();
		vi.resetModules();
	});

	it('should start with empty monitors', async () => {
		const { monitors } = await import('./monitors');

		const state = get(monitors);
		expect(state.monitors).toEqual([]);
		expect(state.matches).toEqual([]);
	});

	it('should add a new monitor', async () => {
		const { monitors } = await import('./monitors');

		const newMonitor = monitors.addMonitor({
			name: 'Test Monitor',
			keywords: ['test', 'keyword'],
			enabled: true
		});

		expect(newMonitor).not.toBeNull();
		expect(newMonitor?.name).toBe('Test Monitor');
		expect(newMonitor?.keywords).toEqual(['test', 'keyword']);
		expect(newMonitor?.id).toMatch(/^mon_/);
	});

	it('should update a monitor', async () => {
		const { monitors } = await import('./monitors');

		const monitor = monitors.addMonitor({
			name: 'Original',
			keywords: ['original'],
			enabled: true
		});

		const updated = monitors.updateMonitor(monitor!.id, {
			name: 'Updated',
			keywords: ['updated', 'new']
		});

		expect(updated).toBe(true);

		const found = monitors.getMonitor(monitor!.id);
		expect(found?.name).toBe('Updated');
		expect(found?.keywords).toEqual(['updated', 'new']);
	});

	it('should delete a monitor', async () => {
		const { monitors } = await import('./monitors');

		const monitor = monitors.addMonitor({
			name: 'To Delete',
			keywords: ['delete'],
			enabled: true
		});

		const deleted = monitors.deleteMonitor(monitor!.id);
		expect(deleted).toBe(true);

		const found = monitors.getMonitor(monitor!.id);
		expect(found).toBeUndefined();
	});

	it('should toggle monitor enabled state', async () => {
		const { monitors } = await import('./monitors');

		const monitor = monitors.addMonitor({
			name: 'Toggle Test',
			keywords: ['toggle'],
			enabled: true
		});

		monitors.toggleMonitor(monitor!.id);
		expect(monitors.getMonitor(monitor!.id)?.enabled).toBe(false);

		monitors.toggleMonitor(monitor!.id);
		expect(monitors.getMonitor(monitor!.id)?.enabled).toBe(true);
	});

	it('should scan for matches', async () => {
		const { monitors } = await import('./monitors');

		monitors.addMonitor({
			name: 'Ukraine Monitor',
			keywords: ['ukraine', 'zelensky'],
			enabled: true
		});

		const newsItems = [
			{
				id: '1',
				title: 'Ukraine announces new policy',
				source: 'BBC',
				link: 'https://bbc.com/1',
				timestamp: Date.now(),
				category: 'politics' as const
			},
			{
				id: '2',
				title: 'Tech stocks rise',
				source: 'CNBC',
				link: 'https://cnbc.com/2',
				timestamp: Date.now(),
				category: 'finance' as const
			}
		];

		const matches = monitors.scanForMatches(newsItems);

		expect(matches.length).toBe(1);
		expect(matches[0].item.title).toContain('Ukraine');
		expect(matches[0].matchedKeywords).toContain('ukraine');
	});

	it('should not match disabled monitors', async () => {
		const { monitors } = await import('./monitors');

		monitors.addMonitor({
			name: 'Disabled Monitor',
			keywords: ['test'],
			enabled: false
		});

		const newsItems = [
			{
				id: '1',
				title: 'Test headline',
				source: 'Test',
				link: 'https://test.com',
				timestamp: Date.now(),
				category: 'politics' as const
			}
		];

		const matches = monitors.scanForMatches(newsItems);
		expect(matches.length).toBe(0);
	});

	it('should persist monitors to localStorage', async () => {
		const { monitors } = await import('./monitors');

		monitors.addMonitor({
			name: 'Persistent Monitor',
			keywords: ['persist'],
			enabled: true
		});

		expect(localStorageMock.setItem).toHaveBeenCalledWith('customMonitors', expect.any(String));
	});

	it('should derive enabled monitors correctly', async () => {
		const { monitors, enabledMonitors, monitorCount } = await import('./monitors');

		monitors.addMonitor({ name: 'Enabled', keywords: ['a'], enabled: true });
		monitors.addMonitor({ name: 'Disabled', keywords: ['b'], enabled: false });
		monitors.addMonitor({ name: 'Also Enabled', keywords: ['c'], enabled: true });

		expect(get(enabledMonitors).length).toBe(2);
		expect(get(monitorCount)).toBe(3);
	});
});



================================================
FILE: src/lib/stores/monitors.ts
================================================
/**
 * Monitors store - custom user monitors CRUD
 */

import { writable, derived, get } from 'svelte/store';
import { browser } from '$app/environment';
import type { CustomMonitor, NewsItem } from '$lib/types';

const STORAGE_KEY = 'customMonitors';
const MAX_MONITORS = 20;

export interface MonitorMatch {
	monitor: CustomMonitor;
	item: NewsItem;
	matchedKeywords: string[];
}

export interface MonitorsState {
	monitors: CustomMonitor[];
	matches: MonitorMatch[];
	initialized: boolean;
}

// Load monitors from localStorage
function loadMonitors(): CustomMonitor[] {
	if (!browser) return [];

	try {
		const data = localStorage.getItem(STORAGE_KEY);
		return data ? JSON.parse(data) : [];
	} catch (e) {
		console.warn('Failed to load monitors from localStorage:', e);
		return [];
	}
}

// Save monitors to localStorage
function saveMonitors(monitors: CustomMonitor[]): void {
	if (!browser) return;

	try {
		localStorage.setItem(STORAGE_KEY, JSON.stringify(monitors));
	} catch (e) {
		console.warn('Failed to save monitors to localStorage:', e);
	}
}

// Generate a unique ID
function generateId(): string {
	return `mon_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// Create the store
function createMonitorsStore() {
	const initialState: MonitorsState = {
		monitors: loadMonitors(),
		matches: [],
		initialized: false
	};

	const { subscribe, set, update } = writable<MonitorsState>(initialState);

	return {
		subscribe,

		/**
		 * Initialize store (call after hydration)
		 */
		init() {
			update((state) => ({ ...state, initialized: true }));
		},

		/**
		 * Get all monitors
		 */
		getMonitors(): CustomMonitor[] {
			return get({ subscribe }).monitors;
		},

		/**
		 * Get a specific monitor by ID
		 */
		getMonitor(id: string): CustomMonitor | undefined {
			return get({ subscribe }).monitors.find((m) => m.id === id);
		},

		/**
		 * Add a new monitor
		 */
		addMonitor(
			monitor: Omit<CustomMonitor, 'id' | 'createdAt' | 'matchCount'>
		): CustomMonitor | null {
			const state = get({ subscribe });

			if (state.monitors.length >= MAX_MONITORS) {
				console.warn(`Maximum monitors (${MAX_MONITORS}) reached`);
				return null;
			}

			const newMonitor: CustomMonitor = {
				...monitor,
				id: generateId(),
				createdAt: Date.now(),
				matchCount: 0
			};

			update((s) => {
				const newMonitors = [...s.monitors, newMonitor];
				saveMonitors(newMonitors);
				return { ...s, monitors: newMonitors };
			});

			return newMonitor;
		},

		/**
		 * Update an existing monitor
		 */
		updateMonitor(id: string, updates: Partial<Omit<CustomMonitor, 'id' | 'createdAt'>>): boolean {
			let found = false;

			update((state) => {
				const index = state.monitors.findIndex((m) => m.id === id);
				if (index === -1) return state;

				found = true;
				const newMonitors = [...state.monitors];
				newMonitors[index] = { ...newMonitors[index], ...updates };
				saveMonitors(newMonitors);
				return { ...state, monitors: newMonitors };
			});

			return found;
		},

		/**
		 * Delete a monitor
		 */
		deleteMonitor(id: string): boolean {
			let found = false;

			update((state) => {
				const index = state.monitors.findIndex((m) => m.id === id);
				if (index === -1) return state;

				found = true;
				const newMonitors = state.monitors.filter((m) => m.id !== id);
				const newMatches = state.matches.filter((m) => m.monitor.id !== id);
				saveMonitors(newMonitors);
				return { ...state, monitors: newMonitors, matches: newMatches };
			});

			return found;
		},

		/**
		 * Toggle monitor enabled state
		 */
		toggleMonitor(id: string): void {
			update((state) => {
				const index = state.monitors.findIndex((m) => m.id === id);
				if (index === -1) return state;

				const newMonitors = [...state.monitors];
				newMonitors[index] = {
					...newMonitors[index],
					enabled: !newMonitors[index].enabled
				};
				saveMonitors(newMonitors);
				return { ...state, monitors: newMonitors };
			});
		},

		/**
		 * Scan news items for monitor matches
		 */
		scanForMatches(newsItems: NewsItem[]): MonitorMatch[] {
			const state = get({ subscribe });
			const matches: MonitorMatch[] = [];

			for (const monitor of state.monitors) {
				if (!monitor.enabled) continue;

				for (const item of newsItems) {
					const textToSearch = `${item.title} ${item.description || ''}`.toLowerCase();
					const matchedKeywords: string[] = [];

					for (const keyword of monitor.keywords) {
						if (textToSearch.includes(keyword.toLowerCase())) {
							matchedKeywords.push(keyword);
						}
					}

					if (matchedKeywords.length > 0) {
						matches.push({ monitor, item, matchedKeywords });
					}
				}
			}

			// Update match counts and store matches
			update((s) => {
				const newMonitors = s.monitors.map((m) => ({
					...m,
					matchCount: matches.filter((match) => match.monitor.id === m.id).length
				}));
				saveMonitors(newMonitors);
				return { ...s, monitors: newMonitors, matches };
			});

			return matches;
		},

		/**
		 * Clear all matches
		 */
		clearMatches(): void {
			update((state) => ({ ...state, matches: [] }));
		},

		/**
		 * Reset all monitors
		 */
		reset(): void {
			if (browser) {
				localStorage.removeItem(STORAGE_KEY);
			}
			set({ monitors: [], matches: [], initialized: true });
		}
	};
}

// Export singleton store
export const monitors = createMonitorsStore();

// Derived stores
export const enabledMonitors = derived(monitors, ($monitors) =>
	$monitors.monitors.filter((m) => m.enabled)
);

export const monitorCount = derived(monitors, ($monitors) => $monitors.monitors.length);

export const matchCount = derived(monitors, ($monitors) => $monitors.matches.length);

export const hasMatches = derived(monitors, ($monitors) => $monitors.matches.length > 0);



================================================
FILE: src/lib/stores/news.test.ts
================================================
/**
 * Tests for news store
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';

// Mock $app/environment
vi.mock('$app/environment', () => ({
	browser: true
}));

describe('News Store', () => {
	beforeEach(async () => {
		vi.resetModules();
	});

	it('should start with empty categories', async () => {
		const { news } = await import('./news');

		const state = get(news);
		expect(state.categories.politics.items).toEqual([]);
		expect(state.categories.tech.items).toEqual([]);
		expect(state.categories.finance.items).toEqual([]);
	});

	it('should set items for a category', async () => {
		const { news, politicsNews } = await import('./news');

		const items = [
			{
				id: '1',
				title: 'Test headline',
				source: 'BBC',
				link: 'https://bbc.com/1',
				timestamp: Date.now(),
				category: 'politics' as const
			}
		];

		news.setItems('politics', items);

		const politics = get(politicsNews);
		expect(politics.items.length).toBe(1);
		expect(politics.items[0].title).toBe('Test headline');
		expect(politics.loading).toBe(false);
		expect(politics.lastUpdated).not.toBeNull();
	});

	it('should enrich items with alert detection', async () => {
		const { news } = await import('./news');

		const items = [
			{
				id: '1',
				title: 'Military strike in region',
				source: 'BBC',
				link: 'https://bbc.com/1',
				timestamp: Date.now(),
				category: 'politics' as const
			},
			{
				id: '2',
				title: 'New tech startup launches',
				source: 'TechCrunch',
				link: 'https://tc.com/2',
				timestamp: Date.now(),
				category: 'tech' as const
			}
		];

		news.setItems('politics', [items[0]]);
		news.setItems('tech', [items[1]]);

		const state = get(news);
		expect(state.categories.politics.items[0].isAlert).toBe(true);
		expect(state.categories.politics.items[0].alertKeyword).toBe('military');
		expect(state.categories.tech.items[0].isAlert).toBe(false);
	});

	it('should set loading state', async () => {
		const { news, politicsNews } = await import('./news');

		news.setLoading('politics', true);
		expect(get(politicsNews).loading).toBe(true);

		news.setLoading('politics', false);
		expect(get(politicsNews).loading).toBe(false);
	});

	it('should set error state', async () => {
		const { news, politicsNews, hasErrors } = await import('./news');

		news.setError('politics', 'Failed to fetch');

		const politics = get(politicsNews);
		expect(politics.error).toBe('Failed to fetch');
		expect(politics.loading).toBe(false);

		expect(get(hasErrors)).toBe(true);
	});

	it('should append items without duplicates', async () => {
		const { news, techNews } = await import('./news');

		const initial = [
			{
				id: '1',
				title: 'First item',
				source: 'TC',
				link: 'https://tc.com/1',
				timestamp: Date.now(),
				category: 'tech' as const
			}
		];

		const more = [
			{
				id: '1',
				title: 'First item',
				source: 'TC',
				link: 'https://tc.com/1',
				timestamp: Date.now(),
				category: 'tech' as const
			},
			{
				id: '2',
				title: 'Second item',
				source: 'TC',
				link: 'https://tc.com/2',
				timestamp: Date.now(),
				category: 'tech' as const
			}
		];

		news.setItems('tech', initial);
		news.appendItems('tech', more);

		const tech = get(techNews);
		expect(tech.items.length).toBe(2);
	});

	it('should get all items across categories', async () => {
		const { news } = await import('./news');

		news.setItems('politics', [
			{
				id: '1',
				title: 'Politics',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics' as const
			}
		]);
		news.setItems('tech', [
			{
				id: '2',
				title: 'Tech',
				source: 'B',
				link: 'b',
				timestamp: Date.now(),
				category: 'tech' as const
			}
		]);

		const all = news.getAllItems();
		expect(all.length).toBe(2);
	});

	it('should derive alerts correctly', async () => {
		const { news, alerts } = await import('./news');

		news.setItems('politics', [
			{
				id: '1',
				title: 'War breaks out',
				source: 'BBC',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics' as const
			},
			{
				id: '2',
				title: 'Normal news',
				source: 'BBC',
				link: 'b',
				timestamp: Date.now(),
				category: 'politics' as const
			}
		]);

		const alertItems = get(alerts);
		expect(alertItems.length).toBe(1);
		expect(alertItems[0].title).toBe('War breaks out');
	});

	it('should clear all categories', async () => {
		const { news } = await import('./news');

		news.setItems('politics', [
			{
				id: '1',
				title: 'Test',
				source: 'A',
				link: 'a',
				timestamp: Date.now(),
				category: 'politics' as const
			}
		]);

		news.clearAll();

		const state = get(news);
		expect(state.categories.politics.items).toEqual([]);
	});
});



================================================
FILE: src/lib/stores/news.ts
================================================
/**
 * News store - manages news data across all categories
 */

import { writable, derived, get } from 'svelte/store';
import type { NewsItem, NewsCategory } from '$lib/types';
import { containsAlertKeyword, detectRegion, detectTopics } from '$lib/config';

export interface CategoryState {
	items: NewsItem[];
	loading: boolean;
	error: string | null;
	lastUpdated: number | null;
}

export interface NewsState {
	categories: Record<NewsCategory, CategoryState>;
	initialized: boolean;
}

// All news categories
const NEWS_CATEGORIES: NewsCategory[] = ['politics', 'tech', 'finance', 'gov', 'ai', 'intel'];

// Create initial state for a category
function createCategoryState(): CategoryState {
	return {
		items: [],
		loading: false,
		error: null,
		lastUpdated: null
	};
}

// Create initial state
function createInitialState(): NewsState {
	const categories = {} as Record<NewsCategory, CategoryState>;
	for (const category of NEWS_CATEGORIES) {
		categories[category] = createCategoryState();
	}
	return { categories, initialized: false };
}

// Enrich news item with analysis
function enrichNewsItem(item: NewsItem): NewsItem {
	const text = `${item.title} ${item.description || ''}`;
	const alertResult = containsAlertKeyword(text);

	return {
		...item,
		isAlert: alertResult.isAlert,
		alertKeyword: alertResult.keyword,
		region: item.region ?? detectRegion(text) ?? undefined,
		topics: item.topics ?? detectTopics(text)
	};
}

// Create the store
function createNewsStore() {
	const { subscribe, set, update } = writable<NewsState>(createInitialState());

	return {
		subscribe,

		/**
		 * Initialize store
		 */
		init() {
			update((state) => ({ ...state, initialized: true }));
		},

		/**
		 * Set loading state for a category
		 */
		setLoading(category: NewsCategory, loading: boolean) {
			update((state) => ({
				...state,
				categories: {
					...state.categories,
					[category]: {
						...state.categories[category],
						loading,
						error: loading ? null : state.categories[category].error
					}
				}
			}));
		},

		/**
		 * Set error state for a category
		 */
		setError(category: NewsCategory, error: string | null) {
			update((state) => ({
				...state,
				categories: {
					...state.categories,
					[category]: {
						...state.categories[category],
						loading: false,
						error
					}
				}
			}));
		},

		/**
		 * Set items for a category
		 */
		setItems(category: NewsCategory, items: NewsItem[]) {
			const enrichedItems = items.map(enrichNewsItem);

			update((state) => ({
				...state,
				categories: {
					...state.categories,
					[category]: {
						items: enrichedItems,
						loading: false,
						error: null,
						lastUpdated: Date.now()
					}
				}
			}));
		},

		/**
		 * Append items to a category (for pagination)
		 */
		appendItems(category: NewsCategory, items: NewsItem[]) {
			const enrichedItems = items.map(enrichNewsItem);

			update((state) => {
				const existing = state.categories[category].items;
				const existingIds = new Set(existing.map((i) => i.id));
				const newItems = enrichedItems.filter((i) => !existingIds.has(i.id));

				return {
					...state,
					categories: {
						...state.categories,
						[category]: {
							...state.categories[category],
							items: [...existing, ...newItems],
							loading: false,
							error: null,
							lastUpdated: Date.now()
						}
					}
				};
			});
		},

		/**
		 * Get items for a category
		 */
		getItems(category: NewsCategory): NewsItem[] {
			return get({ subscribe }).categories[category].items;
		},

		/**
		 * Get all items across all categories
		 */
		getAllItems(): NewsItem[] {
			const state = get({ subscribe });
			const allItems: NewsItem[] = [];
			for (const category of NEWS_CATEGORIES) {
				allItems.push(...state.categories[category].items);
			}
			return allItems;
		},

		/**
		 * Get alert items (items with alert keywords)
		 */
		getAlertItems(): NewsItem[] {
			const state = get({ subscribe });
			const alerts: NewsItem[] = [];
			for (const category of NEWS_CATEGORIES) {
				alerts.push(...state.categories[category].items.filter((i) => i.isAlert));
			}
			return alerts.sort((a, b) => b.timestamp - a.timestamp);
		},

		/**
		 * Clear a category
		 */
		clearCategory(category: NewsCategory) {
			update((state) => ({
				...state,
				categories: {
					...state.categories,
					[category]: createCategoryState()
				}
			}));
		},

		/**
		 * Clear all categories
		 */
		clearAll() {
			set(createInitialState());
		},

		/**
		 * Check if any category is loading
		 */
		isAnyLoading(): boolean {
			const state = get({ subscribe });
			return NEWS_CATEGORIES.some((cat) => state.categories[cat].loading);
		}
	};
}

// Export singleton store
export const news = createNewsStore();

// Derived stores for each category
export const politicsNews = derived(news, ($news) => $news.categories.politics);
export const techNews = derived(news, ($news) => $news.categories.tech);
export const financeNews = derived(news, ($news) => $news.categories.finance);
export const govNews = derived(news, ($news) => $news.categories.gov);
export const aiNews = derived(news, ($news) => $news.categories.ai);
export const intelNews = derived(news, ($news) => $news.categories.intel);

// Derived store for all news items (reactive)
export const allNewsItems = derived(news, ($news) => {
	const allItems: NewsItem[] = [];
	for (const category of NEWS_CATEGORIES) {
		allItems.push(...$news.categories[category].items);
	}
	return allItems;
});

// Derived store for alerts
export const alerts = derived(news, ($news) => {
	const allAlerts: NewsItem[] = [];
	for (const category of NEWS_CATEGORIES) {
		allAlerts.push(...$news.categories[category].items.filter((i) => i.isAlert));
	}
	return allAlerts.sort((a, b) => b.timestamp - a.timestamp);
});

// Derived store for loading state
export const isLoading = derived(news, ($news) =>
	NEWS_CATEGORIES.some((cat) => $news.categories[cat].loading)
);

// Derived store for any errors
export const hasErrors = derived(news, ($news) =>
	NEWS_CATEGORIES.some((cat) => $news.categories[cat].error !== null)
);



================================================
FILE: src/lib/stores/refresh.test.ts
================================================
/**
 * Tests for refresh store
 */

import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { get } from 'svelte/store';

// Mock $app/environment
vi.mock('$app/environment', () => ({
	browser: true
}));

// Mock localStorage
const localStorageMock = (() => {
	let store: Record<string, string> = {};
	return {
		getItem: vi.fn((key: string) => store[key] || null),
		setItem: vi.fn((key: string, value: string) => {
			store[key] = value;
		}),
		removeItem: vi.fn((key: string) => {
			delete store[key];
		}),
		clear: vi.fn(() => {
			store = {};
		})
	};
})();

Object.defineProperty(globalThis, 'localStorage', {
	value: localStorageMock
});

describe('Refresh Store', () => {
	beforeEach(async () => {
		localStorageMock.clear();
		vi.clearAllMocks();
		vi.resetModules();
		vi.useFakeTimers();
	});

	afterEach(() => {
		vi.useRealTimers();
	});

	it('should start with default state', async () => {
		const { isRefreshing, lastRefresh } = await import('./refresh');

		expect(get(isRefreshing)).toBe(false);
		expect(get(lastRefresh)).toBeNull();
	});

	it('should start and end refresh cycle', async () => {
		const { refresh, isRefreshing, currentStage, lastRefresh } = await import('./refresh');

		refresh.startRefresh();
		expect(get(isRefreshing)).toBe(true);
		expect(get(currentStage)).toBe('critical');

		refresh.endRefresh();
		expect(get(isRefreshing)).toBe(false);
		expect(get(currentStage)).toBeNull();
		expect(get(lastRefresh)).not.toBeNull();
	});

	it('should progress through stages', async () => {
		const { refresh, currentStage } = await import('./refresh');

		refresh.startRefresh();
		expect(get(currentStage)).toBe('critical');

		refresh.nextStage();
		expect(get(currentStage)).toBe('secondary');

		refresh.nextStage();
		expect(get(currentStage)).toBe('tertiary');

		refresh.nextStage();
		expect(get(currentStage)).toBeNull();
	});

	it('should track category loading states', async () => {
		const { refresh } = await import('./refresh');

		refresh.setCategoryLoading('news', true);

		const state = get(refresh);
		expect(state.categoryStates['news'].loading).toBe(true);

		refresh.setCategoryUpdated('news');
		const updated = get(refresh);
		expect(updated.categoryStates['news'].loading).toBe(false);
		expect(updated.categoryStates['news'].lastUpdated).not.toBeNull();
	});

	it('should track category errors', async () => {
		const { refresh, categoriesWithErrors } = await import('./refresh');

		refresh.setCategoryError('markets', 'API timeout');

		const errors = get(categoriesWithErrors);
		expect(errors.length).toBe(1);
		expect(errors[0].category).toBe('markets');
		expect(errors[0].error).toBe('API timeout');
	});

	it('should toggle auto-refresh', async () => {
		const { refresh, autoRefreshEnabled } = await import('./refresh');

		expect(get(autoRefreshEnabled)).toBe(true);

		refresh.toggleAutoRefresh();
		expect(get(autoRefreshEnabled)).toBe(false);

		refresh.toggleAutoRefresh();
		expect(get(autoRefreshEnabled)).toBe(true);
	});

	it('should persist auto-refresh settings', async () => {
		const { refresh } = await import('./refresh');

		refresh.setAutoRefreshInterval(120000);

		expect(localStorageMock.setItem).toHaveBeenCalledWith('refreshSettings', expect.any(String));

		const savedData = JSON.parse(
			localStorageMock.setItem.mock.calls[localStorageMock.setItem.mock.calls.length - 1][1]
		);
		expect(savedData.autoRefreshInterval).toBe(120000);
	});

	it('should record refresh history', async () => {
		const { refresh } = await import('./refresh');

		refresh.startRefresh();
		vi.advanceTimersByTime(1000);
		refresh.endRefresh();

		const state = get(refresh);
		expect(state.refreshHistory.length).toBe(1);
		expect(state.refreshHistory[0].success).toBe(true);
		expect(state.refreshHistory[0].duration).toBeGreaterThanOrEqual(1000);
	});

	it('should record errors in refresh history', async () => {
		const { refresh } = await import('./refresh');

		refresh.startRefresh();
		refresh.endRefresh(['API error', 'Timeout']);

		const state = get(refresh);
		expect(state.refreshHistory[0].success).toBe(false);
		expect(state.refreshHistory[0].errors).toEqual(['API error', 'Timeout']);
	});

	it('should check if category needs refresh', async () => {
		const { refresh } = await import('./refresh');

		// Never updated - needs refresh
		expect(refresh.categoryNeedsRefresh('news', 60000)).toBe(true);

		// Just updated - doesn't need refresh
		refresh.setCategoryUpdated('news');
		expect(refresh.categoryNeedsRefresh('news', 60000)).toBe(false);

		// After time passes - needs refresh
		vi.advanceTimersByTime(70000);
		expect(refresh.categoryNeedsRefresh('news', 60000)).toBe(true);
	});

	it('should limit refresh history to 10 entries', async () => {
		const { refresh } = await import('./refresh');

		// Create 15 refresh cycles
		for (let i = 0; i < 15; i++) {
			refresh.startRefresh();
			refresh.endRefresh();
		}

		const state = get(refresh);
		expect(state.refreshHistory.length).toBe(10);
	});
});



================================================
FILE: src/lib/stores/refresh.ts
================================================
/**
 * Refresh store - loading states, timestamps, and refresh orchestration
 */

import { writable, derived, get } from 'svelte/store';
import { browser } from '$app/environment';

// Refresh stages (matches existing 3-stage approach)
export type RefreshStage = 'critical' | 'secondary' | 'tertiary';

export interface StageConfig {
	name: RefreshStage;
	categories: string[];
	delayMs: number;
}

// Staged refresh configuration
export const REFRESH_STAGES: StageConfig[] = [
	{
		name: 'critical',
		categories: ['news', 'markets', 'alerts'],
		delayMs: 0
	},
	{
		name: 'secondary',
		categories: ['crypto', 'commodities', 'intel'],
		delayMs: 2000
	},
	{
		name: 'tertiary',
		categories: ['contracts', 'whales', 'layoffs', 'polymarket'],
		delayMs: 4000
	}
];

export interface RefreshState {
	// Global refresh state
	isRefreshing: boolean;
	currentStage: RefreshStage | null;
	lastRefresh: number | null;

	// Per-category states
	categoryStates: Record<
		string,
		{
			loading: boolean;
			lastUpdated: number | null;
			error: string | null;
		}
	>;

	// Auto-refresh settings
	autoRefreshEnabled: boolean;
	autoRefreshInterval: number; // in milliseconds

	// Refresh history (for debugging/analytics)
	refreshHistory: Array<{
		timestamp: number;
		duration: number;
		success: boolean;
		errors: string[];
	}>;

	initialized: boolean;
}

const DEFAULT_AUTO_REFRESH_INTERVAL = 60 * 60 * 1000; // 1 hour
const STORAGE_KEY = 'refreshSettings';

// Load settings from localStorage
function loadSettings(): { autoRefreshEnabled: boolean; autoRefreshInterval: number; lastRefresh: number | null } {
	if (!browser) {
		return {
			autoRefreshEnabled: true,
			autoRefreshInterval: DEFAULT_AUTO_REFRESH_INTERVAL,
			lastRefresh: null
		};
	}

	try {
		const data = localStorage.getItem(STORAGE_KEY);
		if (data) {
			const parsed = JSON.parse(data);
			return {
				autoRefreshEnabled: parsed.autoRefreshEnabled ?? true,
				autoRefreshInterval: parsed.autoRefreshInterval ?? DEFAULT_AUTO_REFRESH_INTERVAL,
				lastRefresh: parsed.lastRefresh ?? null
			};
		}
	} catch (e) {
		console.warn('Failed to load refresh settings:', e);
	}

	return {
		autoRefreshEnabled: true,
		autoRefreshInterval: DEFAULT_AUTO_REFRESH_INTERVAL,
		lastRefresh: null
	};
}

// Save settings to localStorage
function saveSettings(enabled: boolean, interval: number, lastRefresh?: number | null): void {
	if (!browser) return;

	try {
		const existing = localStorage.getItem(STORAGE_KEY);
		const existingData = existing ? JSON.parse(existing) : {};
		localStorage.setItem(
			STORAGE_KEY,
			JSON.stringify({
				autoRefreshEnabled: enabled,
				autoRefreshInterval: interval,
				lastRefresh: lastRefresh ?? existingData.lastRefresh ?? null
			})
		);
	} catch (e) {
		console.warn('Failed to save refresh settings:', e);
	}
}

// Create initial state
function createInitialState(): RefreshState {
	const settings = loadSettings();

	return {
		isRefreshing: false,
		currentStage: null,
		lastRefresh: settings.lastRefresh,
		categoryStates: {},
		autoRefreshEnabled: settings.autoRefreshEnabled,
		autoRefreshInterval: settings.autoRefreshInterval,
		refreshHistory: [],
		initialized: false
	};
}

// Create the store
function createRefreshStore() {
	const { subscribe, set, update } = writable<RefreshState>(createInitialState());

	let autoRefreshTimer: ReturnType<typeof setInterval> | null = null;
	let refreshStartTime: number | null = null;

	// Setup auto-refresh timer
	function setupAutoRefresh(callback: () => void) {
		const state = get({ subscribe });

		if (autoRefreshTimer) {
			clearInterval(autoRefreshTimer);
			autoRefreshTimer = null;
		}

		if (state.autoRefreshEnabled && browser) {
			autoRefreshTimer = setInterval(callback, state.autoRefreshInterval);
		}
	}

	return {
		subscribe,

		/**
		 * Initialize store
		 */
		init() {
			update((state) => ({ ...state, initialized: true }));
		},

		/**
		 * Start a refresh cycle
		 */
		startRefresh() {
			refreshStartTime = Date.now();
			update((state) => ({
				...state,
				isRefreshing: true,
				currentStage: 'critical'
			}));
		},

		/**
		 * Move to the next stage
		 */
		nextStage() {
			update((state) => {
				const currentIndex = REFRESH_STAGES.findIndex((s) => s.name === state.currentStage);
				const nextStage = REFRESH_STAGES[currentIndex + 1];

				return {
					...state,
					currentStage: nextStage?.name ?? null
				};
			});
		},

		/**
		 * End refresh cycle
		 */
		endRefresh(errors: string[] = []) {
			const duration = refreshStartTime ? Date.now() - refreshStartTime : 0;
			refreshStartTime = null;
			const now = Date.now();

			update((state) => {
				const historyEntry = {
					timestamp: now,
					duration,
					success: errors.length === 0,
					errors
				};

				// Keep last 10 refresh entries
				const newHistory = [historyEntry, ...state.refreshHistory].slice(0, 10);

				// Persist lastRefresh to localStorage
				saveSettings(state.autoRefreshEnabled, state.autoRefreshInterval, now);

				return {
					...state,
					isRefreshing: false,
					currentStage: null,
					lastRefresh: now,
					refreshHistory: newHistory
				};
			});
		},

		/**
		 * Set loading state for a category
		 */
		setCategoryLoading(category: string, loading: boolean) {
			update((state) => ({
				...state,
				categoryStates: {
					...state.categoryStates,
					[category]: {
						...state.categoryStates[category],
						loading,
						error: loading ? null : (state.categoryStates[category]?.error ?? null),
						lastUpdated: state.categoryStates[category]?.lastUpdated ?? null
					}
				}
			}));
		},

		/**
		 * Set category updated
		 */
		setCategoryUpdated(category: string) {
			update((state) => ({
				...state,
				categoryStates: {
					...state.categoryStates,
					[category]: {
						loading: false,
						error: null,
						lastUpdated: Date.now()
					}
				}
			}));
		},

		/**
		 * Set category error
		 */
		setCategoryError(category: string, error: string) {
			update((state) => ({
				...state,
				categoryStates: {
					...state.categoryStates,
					[category]: {
						...state.categoryStates[category],
						loading: false,
						error,
						lastUpdated: state.categoryStates[category]?.lastUpdated ?? null
					}
				}
			}));
		},

		/**
		 * Toggle auto-refresh
		 */
		toggleAutoRefresh(callback?: () => void) {
			update((state) => {
				const newEnabled = !state.autoRefreshEnabled;
				saveSettings(newEnabled, state.autoRefreshInterval);

				if (callback) {
					setupAutoRefresh(callback);
				}

				return {
					...state,
					autoRefreshEnabled: newEnabled
				};
			});
		},

		/**
		 * Set auto-refresh interval
		 */
		setAutoRefreshInterval(intervalMs: number, callback?: () => void) {
			update((state) => {
				saveSettings(state.autoRefreshEnabled, intervalMs);

				if (callback) {
					setupAutoRefresh(callback);
				}

				return {
					...state,
					autoRefreshInterval: intervalMs
				};
			});
		},

		/**
		 * Setup auto-refresh with callback
		 */
		setupAutoRefresh(callback: () => void) {
			setupAutoRefresh(callback);
		},

		/**
		 * Stop auto-refresh
		 */
		stopAutoRefresh() {
			if (autoRefreshTimer) {
				clearInterval(autoRefreshTimer);
				autoRefreshTimer = null;
			}
		},

		/**
		 * Get time since last refresh
		 */
		getTimeSinceRefresh(): number | null {
			const state = get({ subscribe });
			if (!state.lastRefresh) return null;
			return Date.now() - state.lastRefresh;
		},

		/**
		 * Check if a category needs refresh
		 */
		categoryNeedsRefresh(category: string, maxAge: number): boolean {
			const state = get({ subscribe });
			const categoryState = state.categoryStates[category];
			if (!categoryState?.lastUpdated) return true;
			return Date.now() - categoryState.lastUpdated > maxAge;
		},

		/**
		 * Reset store
		 */
		reset() {
			if (autoRefreshTimer) {
				clearInterval(autoRefreshTimer);
				autoRefreshTimer = null;
			}
			set(createInitialState());
		}
	};
}

// Export singleton store
export const refresh = createRefreshStore();

// Derived stores
export const isRefreshing = derived(refresh, ($refresh) => $refresh.isRefreshing);

export const currentStage = derived(refresh, ($refresh) => $refresh.currentStage);

export const lastRefresh = derived(refresh, ($refresh) => $refresh.lastRefresh);

export const autoRefreshEnabled = derived(refresh, ($refresh) => $refresh.autoRefreshEnabled);

// Time since last refresh (updates every second when subscribed)
export const timeSinceRefresh = derived(refresh, ($refresh) => {
	if (!$refresh.lastRefresh) return null;
	return Date.now() - $refresh.lastRefresh;
});

// Categories with errors
export const categoriesWithErrors = derived(refresh, ($refresh) => {
	return Object.entries($refresh.categoryStates)
		.filter(([, state]) => state.error !== null)
		.map(([category, state]) => ({ category, error: state.error }));
});



================================================
FILE: src/lib/stores/settings.test.ts
================================================
/**
 * Tests for settings store
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { get } from 'svelte/store';

// Mock $app/environment before importing the store
vi.mock('$app/environment', () => ({
	browser: true
}));

// Mock localStorage
const localStorageMock = (() => {
	let store: Record<string, string> = {};
	return {
		getItem: vi.fn((key: string) => store[key] || null),
		setItem: vi.fn((key: string, value: string) => {
			store[key] = value;
		}),
		removeItem: vi.fn((key: string) => {
			delete store[key];
		}),
		clear: vi.fn(() => {
			store = {};
		})
	};
})();

Object.defineProperty(globalThis, 'localStorage', {
	value: localStorageMock
});

describe('Settings Store', () => {
	beforeEach(async () => {
		localStorageMock.clear();
		vi.clearAllMocks();

		// Re-import the store to reset state
		vi.resetModules();
	});

	it('should have default state with all panels enabled', async () => {
		const { settings } = await import('./settings');

		const state = get(settings);
		expect(state.initialized).toBe(false);

		// Check that common panels are enabled by default
		expect(state.enabled['map']).toBe(true);
		expect(state.enabled['politics']).toBe(true);
		expect(state.enabled['tech']).toBe(true);
	});

	it('should toggle panel visibility', async () => {
		const { settings } = await import('./settings');

		// Initially enabled
		expect(get(settings).enabled['tech']).toBe(true);

		// Toggle off
		settings.togglePanel('tech');
		expect(get(settings).enabled['tech']).toBe(false);

		// Toggle on
		settings.togglePanel('tech');
		expect(get(settings).enabled['tech']).toBe(true);
	});

	it('should persist panel settings to localStorage', async () => {
		const { settings } = await import('./settings');

		settings.togglePanel('finance');

		expect(localStorageMock.setItem).toHaveBeenCalledWith(
			'situationMonitorPanels',
			expect.any(String)
		);

		const savedData = JSON.parse(
			localStorageMock.setItem.mock.calls[localStorageMock.setItem.mock.calls.length - 1][1]
		);
		expect(savedData['finance']).toBe(false);
	});

	it('should update panel order', async () => {
		const { settings } = await import('./settings');

		const newOrder = ['tech', 'finance', 'politics', 'map'] as const;
		settings.updateOrder([...newOrder]);

		const state = get(settings);
		expect(state.order.slice(0, 4)).toEqual([...newOrder]);
	});

	it('should update panel size', async () => {
		const { settings } = await import('./settings');

		settings.updateSize('map', { width: 800, height: 600 });

		const state = get(settings);
		expect(state.sizes['map']).toEqual({ width: 800, height: 600 });
	});

	it('should initialize store', async () => {
		const { settings } = await import('./settings');

		expect(get(settings).initialized).toBe(false);
		settings.init();
		expect(get(settings).initialized).toBe(true);
	});

	it('should reset to defaults', async () => {
		const { settings } = await import('./settings');

		// Make some changes
		settings.togglePanel('tech');
		settings.updateSize('map', { width: 1000 });

		// Reset
		settings.reset();

		const state = get(settings);
		expect(state.enabled['tech']).toBe(true);
		expect(state.sizes['map']).toBeUndefined();
	});

	it('should derive enabled panels correctly', async () => {
		const { settings, enabledPanels } = await import('./settings');

		// Disable some panels
		settings.togglePanel('whales');
		settings.togglePanel('polymarket');

		const enabled = get(enabledPanels);
		expect(enabled).not.toContain('whales');
		expect(enabled).not.toContain('polymarket');
		expect(enabled).toContain('map');
		expect(enabled).toContain('politics');
	});
});



================================================
FILE: src/lib/stores/settings.ts
================================================
/**
 * Settings store - panel visibility, order, and sizes
 */

import { writable, derived, get } from 'svelte/store';
import { browser } from '$app/environment';
import {
	PANELS,
	NON_DRAGGABLE_PANELS,
	PRESETS,
	ONBOARDING_STORAGE_KEY,
	PRESET_STORAGE_KEY,
	type PanelId
} from '$lib/config';

// Storage keys
const STORAGE_KEYS = {
	panels: 'situationMonitorPanels',
	order: 'panelOrder',
	sizes: 'panelSizes'
} as const;

// Types
export interface PanelSettings {
	enabled: Record<PanelId, boolean>;
	order: PanelId[];
	sizes: Record<PanelId, { width?: number; height?: number }>;
}

export interface SettingsState extends PanelSettings {
	initialized: boolean;
}

// Default settings
function getDefaultSettings(): PanelSettings {
	const allPanelIds = Object.keys(PANELS) as PanelId[];

	return {
		enabled: Object.fromEntries(allPanelIds.map((id) => [id, true])) as Record<PanelId, boolean>,
		order: allPanelIds,
		sizes: {} as Record<PanelId, { width?: number; height?: number }>
	};
}

// Load from localStorage
function loadFromStorage(): Partial<PanelSettings> {
	if (!browser) return {};

	try {
		const panels = localStorage.getItem(STORAGE_KEYS.panels);
		const order = localStorage.getItem(STORAGE_KEYS.order);
		const sizes = localStorage.getItem(STORAGE_KEYS.sizes);

		return {
			enabled: panels ? JSON.parse(panels) : undefined,
			order: order ? JSON.parse(order) : undefined,
			sizes: sizes ? JSON.parse(sizes) : undefined
		};
	} catch (e) {
		console.warn('Failed to load settings from localStorage:', e);
		return {};
	}
}

// Save to localStorage
function saveToStorage(key: keyof typeof STORAGE_KEYS, value: unknown): void {
	if (!browser) return;

	try {
		localStorage.setItem(STORAGE_KEYS[key], JSON.stringify(value));
	} catch (e) {
		console.warn(`Failed to save ${key} to localStorage:`, e);
	}
}

// Create the store
function createSettingsStore() {
	const defaults = getDefaultSettings();
	const saved = loadFromStorage();

	const initialState: SettingsState = {
		enabled: { ...defaults.enabled, ...saved.enabled },
		order: saved.order ?? defaults.order,
		sizes: { ...defaults.sizes, ...saved.sizes },
		initialized: false
	};

	const { subscribe, set, update } = writable<SettingsState>(initialState);

	return {
		subscribe,

		/**
		 * Initialize store (call after hydration)
		 */
		init() {
			update((state) => ({ ...state, initialized: true }));
		},

		/**
		 * Check if a panel is enabled
		 */
		isPanelEnabled(panelId: PanelId): boolean {
			const state = get({ subscribe });
			return state.enabled[panelId] ?? true;
		},

		/**
		 * Toggle panel visibility
		 */
		togglePanel(panelId: PanelId) {
			update((state) => {
				const newEnabled = {
					...state.enabled,
					[panelId]: !state.enabled[panelId]
				};
				saveToStorage('panels', newEnabled);
				return { ...state, enabled: newEnabled };
			});
		},

		/**
		 * Enable a specific panel
		 */
		enablePanel(panelId: PanelId) {
			update((state) => {
				const newEnabled = { ...state.enabled, [panelId]: true };
				saveToStorage('panels', newEnabled);
				return { ...state, enabled: newEnabled };
			});
		},

		/**
		 * Disable a specific panel
		 */
		disablePanel(panelId: PanelId) {
			update((state) => {
				const newEnabled = { ...state.enabled, [panelId]: false };
				saveToStorage('panels', newEnabled);
				return { ...state, enabled: newEnabled };
			});
		},

		/**
		 * Update panel order (for drag-drop)
		 */
		updateOrder(newOrder: PanelId[]) {
			update((state) => {
				saveToStorage('order', newOrder);
				return { ...state, order: newOrder };
			});
		},

		/**
		 * Move a panel to a new position
		 */
		movePanel(panelId: PanelId, toIndex: number) {
			// Don't allow moving non-draggable panels
			if (NON_DRAGGABLE_PANELS.includes(panelId)) return;

			update((state) => {
				const currentIndex = state.order.indexOf(panelId);
				if (currentIndex === -1) return state;

				const newOrder = [...state.order];
				newOrder.splice(currentIndex, 1);
				newOrder.splice(toIndex, 0, panelId);

				saveToStorage('order', newOrder);
				return { ...state, order: newOrder };
			});
		},

		/**
		 * Update panel size
		 */
		updateSize(panelId: PanelId, size: { width?: number; height?: number }) {
			update((state) => {
				const newSizes = {
					...state.sizes,
					[panelId]: { ...state.sizes[panelId], ...size }
				};
				saveToStorage('sizes', newSizes);
				return { ...state, sizes: newSizes };
			});
		},

		/**
		 * Reset all settings to defaults
		 */
		reset() {
			const defaults = getDefaultSettings();
			if (browser) {
				localStorage.removeItem(STORAGE_KEYS.panels);
				localStorage.removeItem(STORAGE_KEYS.order);
				localStorage.removeItem(STORAGE_KEYS.sizes);
			}
			set({ ...defaults, initialized: true });
		},

		/**
		 * Get panel size
		 */
		getPanelSize(panelId: PanelId): { width?: number; height?: number } | undefined {
			const state = get({ subscribe });
			return state.sizes[panelId];
		},

		/**
		 * Check if onboarding is complete
		 */
		isOnboardingComplete(): boolean {
			if (!browser) return true;
			return localStorage.getItem(ONBOARDING_STORAGE_KEY) === 'true';
		},

		/**
		 * Get selected preset
		 */
		getSelectedPreset(): string | null {
			if (!browser) return null;
			return localStorage.getItem(PRESET_STORAGE_KEY);
		},

		/**
		 * Apply a preset configuration
		 */
		applyPreset(presetId: string) {
			const preset = PRESETS[presetId];
			if (!preset) {
				console.error('Unknown preset:', presetId);
				return;
			}

			// Build panel settings - disable all panels first, then enable preset panels
			const allPanelIds = Object.keys(PANELS) as PanelId[];
			const newEnabled = Object.fromEntries(
				allPanelIds.map((id) => [id, preset.panels.includes(id)])
			) as Record<PanelId, boolean>;

			update((state) => {
				saveToStorage('panels', newEnabled);
				return { ...state, enabled: newEnabled };
			});

			// Mark onboarding complete and save preset
			if (browser) {
				localStorage.setItem(ONBOARDING_STORAGE_KEY, 'true');
				localStorage.setItem(PRESET_STORAGE_KEY, presetId);
			}
		},

		/**
		 * Reset onboarding to show modal again
		 */
		resetOnboarding() {
			if (browser) {
				localStorage.removeItem(ONBOARDING_STORAGE_KEY);
				localStorage.removeItem(PRESET_STORAGE_KEY);
			}
		}
	};
}

// Export singleton store
export const settings = createSettingsStore();

// Derived stores for convenience
export const enabledPanels = derived(settings, ($settings) =>
	$settings.order.filter((id) => $settings.enabled[id])
);

export const disabledPanels = derived(settings, ($settings) =>
	$settings.order.filter((id) => !$settings.enabled[id])
);

export const draggablePanels = derived(enabledPanels, ($enabled) =>
	$enabled.filter((id) => !NON_DRAGGABLE_PANELS.includes(id))
);



================================================
FILE: src/lib/types/index.ts
================================================
// Core data types for Situation Monitor

/**
 * News feed category
 */
export type NewsCategory = 'politics' | 'tech' | 'finance' | 'gov' | 'ai' | 'intel';

/**
 * A news item from any source (RSS, GDELT, etc.)
 */
export interface NewsItem {
	id: string;
	title: string;
	link: string;
	pubDate?: string;
	timestamp: number;
	description?: string;
	content?: string;
	source: string;
	category: NewsCategory;
	isAlert?: boolean;
	alertKeyword?: string;
	region?: string;
	topics?: string[];
}

/**
 * RSS feed configuration
 */
export interface FeedConfig {
	name: string;
	url: string;
	category: NewsCategory;
}

/**
 * Market data for stocks/crypto
 */
export interface MarketItem {
	symbol: string;
	name: string;
	price: number;
	change: number;
	changePercent: number;
	type?: 'stock' | 'crypto' | 'commodity' | 'index';
}

/**
 * Sector performance data (ETFs like XLK, XLF, etc.)
 */
export interface SectorPerformance {
	symbol: string;
	name: string;
	price: number;
	change: number;
	changePercent: number;
}

/**
 * Cryptocurrency data from CoinGecko
 */
export interface CryptoItem {
	id: string;
	symbol: string;
	name: string;
	current_price: number;
	price_change_24h: number;
	price_change_percentage_24h: number;
	market_cap?: number;
	volume_24h?: number;
}

/**
 * Sector heatmap data
 */
export interface SectorData {
	symbol: string;
	name: string;
	change: number;
	color: string;
}

/**
 * Commodity data
 */
export interface CommodityData {
	name: string;
	price: number;
	change: number;
	unit: string;
}

/**
 * Federal Reserve balance sheet data
 */
export interface FedBalanceData {
	value: number;
	change: number;
	changePercent: number;
	percentOfMax: number;
}

/**
 * Earthquake data from USGS
 */
export interface EarthquakeData {
	id: string;
	magnitude: number;
	place: string;
	time: number;
	lat: number;
	lon: number;
	depth: number;
	url: string;
}

/**
 * Polymarket prediction data
 */
export interface PredictionData {
	id: string;
	title: string;
	probability: number;
	volume: number;
	url: string;
}

/**
 * Whale transaction data
 */
export interface WhaleTransaction {
	hash: string;
	from: string;
	to: string;
	value: number;
	token: string;
	timestamp: number;
	type: 'transfer' | 'swap' | 'mint' | 'burn';
}

/**
 * Government contract data
 */
export interface GovContract {
	id: string;
	title: string;
	agency: string;
	value: number;
	vendor: string;
	date: string;
	url: string;
}

/**
 * Layoff announcement data
 */
export interface LayoffData {
	company: string;
	count: number;
	percentage?: number;
	date: string;
	source: string;
	url: string;
}

/**
 * Map hotspot configuration
 */
export interface Hotspot {
	id: string;
	name: string;
	location: string;
	lat: number;
	lon: number;
	level: 'low' | 'medium' | 'high' | 'critical';
	category: string;
	description?: string;
	keywords?: string[];
}

/**
 * Custom monitor created by user
 */
export interface CustomMonitor {
	id: string;
	name: string;
	keywords: string[];
	enabled: boolean;
	color?: string;
	location?: {
		name: string;
		lat: number;
		lon: number;
	};
	createdAt: number;
	updatedAt?: number;
	matchCount: number;
}

/**
 * Panel configuration
 */
export interface PanelConfig {
	id: string;
	title: string;
	category: string;
	enabled: boolean;
	order: number;
}

/**
 * Correlation analysis result
 */
export interface CorrelationResult {
	topic: string;
	count: number;
	sources: string[];
	momentum: 'rising' | 'stable' | 'falling';
	sentiment?: 'positive' | 'neutral' | 'negative';
}

/**
 * Narrative tracking result
 */
export interface NarrativeResult {
	narrative: string;
	mentions: number;
	firstSeen: number;
	lastSeen: number;
	trend: 'emerging' | 'established' | 'fading';
	relatedTopics: string[];
}

/**
 * Main character ranking result
 */
export interface MainCharacterResult {
	name: string;
	mentions: number;
	sources: string[];
	sentiment: 'positive' | 'neutral' | 'negative' | 'mixed';
}

/**
 * Service client configuration
 */
export interface ServiceConfig {
	name: string;
	baseUrl: string;
	timeout: number;
	retries: number;
	cacheTtl: number;
	circuitBreaker: {
		failureThreshold: number;
		resetTimeout: number;
	};
}

/**
 * Cache entry
 */
export interface CacheEntry<T> {
	data: T;
	timestamp: number;
	ttl: number;
}

/**
 * Circuit breaker state
 */
export type CircuitBreakerState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';

/**
 * API response wrapper
 */
export interface ApiResponse<T> {
	data: T;
	status: 'ok' | 'error';
	error?: string;
	cached?: boolean;
	timestamp: number;
}

/**
 * Refresh state
 */
export interface RefreshState {
	isRefreshing: boolean;
	stage: 0 | 1 | 2 | 3;
	lastUpdated: Date | null;
	error: string | null;
}

/**
 * Settings state
 */
export interface SettingsState {
	panels: Record<string, boolean>;
	panelOrder: string[];
	theme: 'dark' | 'light';
}

/**
 * News item for a world leader
 */
export interface LeaderNews {
	source: string;
	title: string;
	link: string;
	pubDate: string;
}

/**
 * World leader tracking data
 */
export interface WorldLeader {
	id: string;
	name: string;
	title: string;
	country: string;
	flag: string;
	keywords: string[];
	since: string;
	party: string;
	focus?: string[];
	news?: LeaderNews[];
}



================================================
FILE: src/lib/utils/format.ts
================================================
/**
 * Formatting utilities
 */

/**
 * Format relative time from a date
 */
export function timeAgo(dateInput: string | number | Date): string {
	const date = new Date(dateInput);
	const now = new Date();
	const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

	if (seconds < 60) return 'just now';
	if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
	if (seconds < 86400) return Math.floor(seconds / 3600) + 'h';
	return Math.floor(seconds / 86400) + 'd';
}

/**
 * Get relative time with more detail
 */
export function getRelativeTime(dateInput: string | number | Date): string {
	const date = new Date(dateInput);
	const now = new Date();
	const diff = now.getTime() - date.getTime();
	const hours = Math.floor(diff / (1000 * 60 * 60));
	const days = Math.floor(hours / 24);

	if (hours < 1) return 'Just now';
	if (hours < 24) return `${hours}h ago`;
	if (days < 7) return `${days}d ago`;
	return date.toLocaleDateString();
}

/**
 * Format currency value
 */
export function formatCurrency(
	value: number,
	options: { decimals?: number; compact?: boolean; symbol?: string } = {}
): string {
	const { decimals = 2, compact = false, symbol = '$' } = options;

	if (compact) {
		if (Math.abs(value) >= 1e12) return symbol + (value / 1e12).toFixed(1) + 'T';
		if (Math.abs(value) >= 1e9) return symbol + (value / 1e9).toFixed(1) + 'B';
		if (Math.abs(value) >= 1e6) return symbol + (value / 1e6).toFixed(1) + 'M';
		if (Math.abs(value) >= 1e3) return symbol + (value / 1e3).toFixed(0) + 'K';
	}

	return symbol + value.toLocaleString('en-US', { maximumFractionDigits: decimals });
}

/**
 * Format number with compact notation
 */
export function formatNumber(value: number, decimals = 2): string {
	if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + 'B';
	if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + 'M';
	if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(1) + 'K';
	return value.toFixed(decimals);
}

/**
 * Format percent change with sign
 */
export function formatPercentChange(value: number, decimals = 2): string {
	const sign = value > 0 ? '+' : '';
	return sign + value.toFixed(decimals) + '%';
}

/**
 * Get CSS class for positive/negative change
 */
export function getChangeClass(value: number): 'up' | 'down' | '' {
	if (value > 0) return 'up';
	if (value < 0) return 'down';
	return '';
}

/**
 * Escape HTML for safe display
 */
export function escapeHtml(text: string): string {
	const div = document.createElement('div');
	div.textContent = text;
	return div.innerHTML;
}

/**
 * Get date from days ago
 */
export function getDateDaysAgo(days: number): string {
	const date = new Date();
	date.setDate(date.getDate() - days);
	return date.toISOString().split('T')[0];
}

/**
 * Get today's date formatted
 */
export function getToday(): string {
	return new Date().toISOString().split('T')[0];
}

/**
 * Convert lat/lon to map position (equirectangular projection)
 */
export function latLonToXY(
	lat: number,
	lon: number,
	width: number,
	height: number
): { x: number; y: number } {
	const x = ((lon + 180) / 360) * width;
	const y = ((90 - lat) / 180) * height;
	return { x, y };
}



================================================
FILE: src/lib/utils/index.ts
================================================
/**
 * Utilities barrel file
 */

export {
	timeAgo,
	getRelativeTime,
	formatCurrency,
	formatNumber,
	formatPercentChange,
	getChangeClass,
	escapeHtml,
	getDateDaysAgo,
	getToday,
	latLonToXY
} from './format';



================================================
FILE: src/routes/+layout.svelte
================================================
<script lang="ts">
	import '../app.css';

	interface Props {
		children: import('svelte').Snippet;
	}

	let { children }: Props = $props();
</script>

<div class="min-h-screen bg-bg text-text-primary">
	{@render children()}
</div>



================================================
FILE: src/routes/+layout.ts
================================================
// Enable prerendering for static site generation
export const prerender = true;
export const ssr = false;



================================================
FILE: src/routes/+page.svelte
================================================
<script lang="ts">
	import { onMount } from 'svelte';
	import { Header, Dashboard } from '$lib/components/layout';
	import { SettingsModal, MonitorFormModal, OnboardingModal } from '$lib/components/modals';
	import {
		NewsPanel,
		MarketsPanel,
		HeatmapPanel,
		CommoditiesPanel,
		CryptoPanel,
		MainCharPanel,
		CorrelationPanel,
		NarrativePanel,
		MonitorsPanel,
		MapPanel,
		WhalePanel,
		PolymarketPanel,
		ContractsPanel,
		LayoffsPanel,
		IntelPanel,
		SituationPanel,
		WorldLeadersPanel,
		PrinterPanel,
		FedPanel
	} from '$lib/components/panels';
	import {
		news,
		markets,
		monitors,
		settings,
		refresh,
		allNewsItems,
		fedIndicators,
		fedNews
	} from '$lib/stores';
	import {
		fetchAllNews,
		fetchAllMarkets,
		fetchPolymarket,
		fetchWhaleTransactions,
		fetchGovContracts,
		fetchLayoffs,
		fetchWorldLeaders,
		fetchFedIndicators,
		fetchFedNews
	} from '$lib/api';
	import type { Prediction, WhaleTransaction, Contract, Layoff } from '$lib/api';
	import type { CustomMonitor, WorldLeader } from '$lib/types';
	import type { PanelId } from '$lib/config';

	// Modal state
	let settingsOpen = $state(false);
	let monitorFormOpen = $state(false);
	let onboardingOpen = $state(false);
	let editingMonitor = $state<CustomMonitor | null>(null);

	// Misc panel data
	let predictions = $state<Prediction[]>([]);
	let whales = $state<WhaleTransaction[]>([]);
	let contracts = $state<Contract[]>([]);
	let layoffs = $state<Layoff[]>([]);
	let leaders = $state<WorldLeader[]>([]);
	let leadersLoading = $state(false);

	// Data fetching
	async function loadNews() {
		// Set loading for all categories
		const categories = ['politics', 'tech', 'finance', 'gov', 'ai', 'intel'] as const;
		categories.forEach((cat) => news.setLoading(cat, true));

		try {
			const data = await fetchAllNews();
			Object.entries(data).forEach(([category, items]) => {
				news.setItems(category as keyof typeof data, items);
			});
		} catch (error) {
			categories.forEach((cat) => news.setError(cat, String(error)));
		}
	}

	async function loadMarkets() {
		try {
			const data = await fetchAllMarkets();
			markets.setIndices(data.indices);
			markets.setSectors(data.sectors);
			markets.setCommodities(data.commodities);
			markets.setCrypto(data.crypto);
		} catch (error) {
			console.error('Failed to load markets:', error);
		}
	}

	async function loadMiscData() {
		try {
			const [predictionsData, whalesData, contractsData, layoffsData] = await Promise.all([
				fetchPolymarket(),
				fetchWhaleTransactions(),
				fetchGovContracts(),
				fetchLayoffs()
			]);
			predictions = predictionsData;
			whales = whalesData;
			contracts = contractsData;
			layoffs = layoffsData;
		} catch (error) {
			console.error('Failed to load misc data:', error);
		}
	}

	async function loadWorldLeaders() {
		if (!isPanelVisible('leaders')) return;
		leadersLoading = true;
		try {
			leaders = await fetchWorldLeaders();
		} catch (error) {
			console.error('Failed to load world leaders:', error);
		} finally {
			leadersLoading = false;
		}
	}

	async function loadFedData() {
		if (!isPanelVisible('fed')) return;
		fedIndicators.setLoading(true);
		fedNews.setLoading(true);
		try {
			const [indicatorsData, newsData] = await Promise.all([fetchFedIndicators(), fetchFedNews()]);
			fedIndicators.setData(indicatorsData);
			fedNews.setItems(newsData);
		} catch (error) {
			console.error('Failed to load Fed data:', error);
			fedIndicators.setError(String(error));
			fedNews.setError(String(error));
		}
	}

	// Refresh handlers
	async function handleRefresh() {
		refresh.startRefresh();
		try {
			await Promise.all([loadNews(), loadMarkets()]);
			refresh.endRefresh();
		} catch (error) {
			refresh.endRefresh([String(error)]);
		}
	}

	// Monitor handlers
	function handleCreateMonitor() {
		editingMonitor = null;
		monitorFormOpen = true;
	}

	function handleEditMonitor(monitor: CustomMonitor) {
		editingMonitor = monitor;
		monitorFormOpen = true;
	}

	function handleDeleteMonitor(id: string) {
		monitors.deleteMonitor(id);
	}

	function handleToggleMonitor(id: string) {
		monitors.toggleMonitor(id);
	}

	// Get panel visibility
	function isPanelVisible(id: PanelId): boolean {
		return $settings.enabled[id] !== false;
	}

	// Handle preset selection from onboarding
	function handleSelectPreset(presetId: string) {
		settings.applyPreset(presetId);
		onboardingOpen = false;
		// Refresh data after applying preset
		handleRefresh();
	}

	// Show onboarding again (called from settings)
	function handleReconfigure() {
		settingsOpen = false;
		settings.resetOnboarding();
		onboardingOpen = true;
	}

	// Initial load
	onMount(() => {
		// Check if first visit
		if (!settings.isOnboardingComplete()) {
			onboardingOpen = true;
		}

		// Load initial data and track as refresh
		async function initialLoad() {
			refresh.startRefresh();
			try {
				await Promise.all([
					loadNews(),
					loadMarkets(),
					loadMiscData(),
					loadWorldLeaders(),
					loadFedData()
				]);
				refresh.endRefresh();
			} catch (error) {
				refresh.endRefresh([String(error)]);
			}
		}
		initialLoad();
		refresh.setupAutoRefresh(handleRefresh);

		return () => {
			refresh.stopAutoRefresh();
		};
	});
</script>

<svelte:head>
	<title>Situation Monitor</title>
	<meta name="description" content="Real-time global situation monitoring dashboard" />
</svelte:head>

<div class="app">
	<Header onSettingsClick={() => (settingsOpen = true)} />

	<main class="main-content">
		<Dashboard>
			<!-- Map Panel - Full width -->
			{#if isPanelVisible('map')}
				<div class="panel-slot map-slot">
					<MapPanel monitors={$monitors.monitors} />
				</div>
			{/if}

			<!-- News Panels -->
			{#if isPanelVisible('politics')}
				<div class="panel-slot">
					<NewsPanel category="politics" panelId="politics" title="Politics" />
				</div>
			{/if}

			{#if isPanelVisible('tech')}
				<div class="panel-slot">
					<NewsPanel category="tech" panelId="tech" title="Tech" />
				</div>
			{/if}

			{#if isPanelVisible('finance')}
				<div class="panel-slot">
					<NewsPanel category="finance" panelId="finance" title="Finance" />
				</div>
			{/if}

			{#if isPanelVisible('gov')}
				<div class="panel-slot">
					<NewsPanel category="gov" panelId="gov" title="Government" />
				</div>
			{/if}

			{#if isPanelVisible('ai')}
				<div class="panel-slot">
					<NewsPanel category="ai" panelId="ai" title="AI" />
				</div>
			{/if}

			<!-- Markets Panels -->
			{#if isPanelVisible('markets')}
				<div class="panel-slot">
					<MarketsPanel />
				</div>
			{/if}

			{#if isPanelVisible('heatmap')}
				<div class="panel-slot">
					<HeatmapPanel />
				</div>
			{/if}

			{#if isPanelVisible('commodities')}
				<div class="panel-slot">
					<CommoditiesPanel />
				</div>
			{/if}

			{#if isPanelVisible('crypto')}
				<div class="panel-slot">
					<CryptoPanel />
				</div>
			{/if}

			<!-- Analysis Panels -->
			{#if isPanelVisible('mainchar')}
				<div class="panel-slot">
					<MainCharPanel />
				</div>
			{/if}

			{#if isPanelVisible('correlation')}
				<div class="panel-slot">
					<CorrelationPanel news={$allNewsItems} />
				</div>
			{/if}

			{#if isPanelVisible('narrative')}
				<div class="panel-slot">
					<NarrativePanel news={$allNewsItems} />
				</div>
			{/if}

			<!-- Intel Panel -->
			{#if isPanelVisible('intel')}
				<div class="panel-slot">
					<IntelPanel />
				</div>
			{/if}

			<!-- Fed Panel -->
			{#if isPanelVisible('fed')}
				<div class="panel-slot">
					<FedPanel />
				</div>
			{/if}

			<!-- World Leaders Panel -->
			{#if isPanelVisible('leaders')}
				<div class="panel-slot">
					<WorldLeadersPanel {leaders} loading={leadersLoading} />
				</div>
			{/if}

			<!-- Situation Panels -->
			{#if isPanelVisible('venezuela')}
				<div class="panel-slot">
					<SituationPanel
						panelId="venezuela"
						config={{
							title: 'Venezuela Watch',
							subtitle: 'Humanitarian crisis monitoring',
							criticalKeywords: ['maduro', 'caracas', 'venezuela', 'guaido']
						}}
						news={$allNewsItems.filter(
							(n) =>
								n.title.toLowerCase().includes('venezuela') ||
								n.title.toLowerCase().includes('maduro')
						)}
					/>
				</div>
			{/if}

			{#if isPanelVisible('greenland')}
				<div class="panel-slot">
					<SituationPanel
						panelId="greenland"
						config={{
							title: 'Greenland Watch',
							subtitle: 'Arctic geopolitics monitoring',
							criticalKeywords: ['greenland', 'arctic', 'nuuk', 'denmark']
						}}
						news={$allNewsItems.filter(
							(n) =>
								n.title.toLowerCase().includes('greenland') ||
								n.title.toLowerCase().includes('arctic')
						)}
					/>
				</div>
			{/if}

			{#if isPanelVisible('iran')}
				<div class="panel-slot">
					<SituationPanel
						panelId="iran"
						config={{
							title: 'Iran Crisis',
							subtitle: 'Revolution protests, regime instability & nuclear program',
							criticalKeywords: [
								'protest',
								'uprising',
								'revolution',
								'crackdown',
								'killed',
								'nuclear',
								'strike',
								'attack',
								'irgc',
								'khamenei'
							]
						}}
						news={$allNewsItems.filter(
							(n) =>
								n.title.toLowerCase().includes('iran') ||
								n.title.toLowerCase().includes('tehran') ||
								n.title.toLowerCase().includes('irgc')
						)}
					/>
				</div>
			{/if}

			<!-- Placeholder panels for additional data sources -->
			{#if isPanelVisible('whales')}
				<div class="panel-slot">
					<WhalePanel {whales} />
				</div>
			{/if}

			{#if isPanelVisible('polymarket')}
				<div class="panel-slot">
					<PolymarketPanel {predictions} />
				</div>
			{/if}

			{#if isPanelVisible('contracts')}
				<div class="panel-slot">
					<ContractsPanel {contracts} />
				</div>
			{/if}

			{#if isPanelVisible('layoffs')}
				<div class="panel-slot">
					<LayoffsPanel {layoffs} />
				</div>
			{/if}

			<!-- Money Printer Panel -->
			{#if isPanelVisible('printer')}
				<div class="panel-slot">
					<PrinterPanel />
				</div>
			{/if}

			<!-- Custom Monitors (always last) -->
			{#if isPanelVisible('monitors')}
				<div class="panel-slot">
					<MonitorsPanel
						monitors={$monitors.monitors}
						matches={$monitors.matches}
						onCreateMonitor={handleCreateMonitor}
						onEditMonitor={handleEditMonitor}
						onDeleteMonitor={handleDeleteMonitor}
						onToggleMonitor={handleToggleMonitor}
					/>
				</div>
			{/if}
		</Dashboard>
	</main>

	<!-- Modals -->
	<SettingsModal
		open={settingsOpen}
		onClose={() => (settingsOpen = false)}
		onReconfigure={handleReconfigure}
	/>
	<MonitorFormModal
		open={monitorFormOpen}
		onClose={() => (monitorFormOpen = false)}
		editMonitor={editingMonitor}
	/>
	<OnboardingModal open={onboardingOpen} onSelectPreset={handleSelectPreset} />
</div>

<style>
	.app {
		min-height: 100vh;
		display: flex;
		flex-direction: column;
		background: var(--bg);
	}

	.main-content {
		flex: 1;
		padding: 0.5rem;
		overflow-y: auto;
	}

	.map-slot {
		column-span: all;
		margin-bottom: 0.5rem;
	}

	@media (max-width: 768px) {
		.main-content {
			padding: 0.25rem;
		}
	}
</style>



================================================
FILE: tests/e2e/app.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Situation Monitor - SvelteKit App', () => {
	test('homepage loads correctly', async ({ page }) => {
		await page.goto('/');

		// Check page title
		await expect(page).toHaveTitle('Situation Monitor');

		// Check header is visible
		await expect(page.locator('h1')).toHaveText('Situation Monitor');

		// Check placeholder panels are rendered
		await expect(page.locator('text=Politics')).toBeVisible();
		await expect(page.locator('text=Tech')).toBeVisible();
		await expect(page.locator('text=Finance')).toBeVisible();
		await expect(page.locator('text=Markets')).toBeVisible();
	});

	test('phase indicator shows Phase 0 complete', async ({ page }) => {
		await page.goto('/');

		await expect(page.locator('text=Phase 0 Complete')).toBeVisible();
	});
});



================================================
FILE: tests/e2e/legacy.spec.ts
================================================
import { test, expect } from '@playwright/test';

test.describe('Situation Monitor - Legacy App', () => {
	test('legacy app loads correctly', async ({ page }) => {
		await page.goto('/legacy.html');

		// Check page title
		await expect(page).toHaveTitle('Situation Monitor');

		// Check header is visible
		await expect(page.locator('h1.title')).toHaveText('Situation Monitor');

		// Check status element exists
		await expect(page.locator('#status')).toBeVisible();

		// Check panels exist
		await expect(page.locator('[data-panel="politics"]')).toBeVisible();
		await expect(page.locator('[data-panel="tech"]')).toBeVisible();
		await expect(page.locator('[data-panel="finance"]')).toBeVisible();
	});

	test('legacy app can refresh', async ({ page }) => {
		await page.goto('/legacy.html');

		// Wait for initial load
		await page.waitForSelector('#status');

		// The refresh button should exist
		await expect(page.locator('#refreshBtn')).toBeVisible();
	});
});



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy Redirect to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Create redirect page
        run: |
          mkdir -p build
          cat > build/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>Redirecting to Situation Monitor...</title>
            <meta http-equiv="refresh" content="0; url=https://hipcityreg-situation-monitor.vercel.app">
            <link rel="canonical" href="https://hipcityreg-situation-monitor.vercel.app">
            <style>
              body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background: #0a0a0a;
                color: #888;
              }
              a { color: #4ade80; }
            </style>
          </head>
          <body>
            <p>Redirecting to <a href="https://hipcityreg-situation-monitor.vercel.app">hipcityreg-situation-monitor.vercel.app</a>...</p>
          </body>
          </html>
          EOF
          cat > build/404.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <title>Redirecting to Situation Monitor...</title>
            <meta http-equiv="refresh" content="0; url=https://hipcityreg-situation-monitor.vercel.app">
            <link rel="canonical" href="https://hipcityreg-situation-monitor.vercel.app">
          </head>
          <body>
            <p>Redirecting to <a href="https://hipcityreg-situation-monitor.vercel.app">hipcityreg-situation-monitor.vercel.app</a>...</p>
          </body>
          </html>
          EOF

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: build

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


